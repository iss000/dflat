AS65 Assembler for R6502 [1.42].                                     Page    1
---------------------------------- bank0.s -----------------------------------

-------------------------------- Symbol Table --------------------------------

              Symbol   Value        Decimal

                 ACR : $000b             11   *
              AM_ABS : $0001              1   *
           AM_ABSIND : $000a             10   *
          AM_ABSINDX : $000b             11   *
             AM_ABSX : $0002              2   *
             AM_ABSY : $0003              3   *
              AM_ACC : $000d             13   *
              AM_DIR : $0010             16   *
              AM_IMM : $000c             12   *
              AM_IMP : $000d             13   *
             AM_NONE : $0000              0   *
              AM_REL : $000f             15   *
               AM_ZP : $0004              4   *
            AM_ZPIND : $0007              7   *
           AM_ZPINDX : $0008              8   *
           AM_ZPINDY : $0009              9   *
              AM_ZPX : $0005              5   *
              AM_ZPY : $0006              6   *
            asm_init : $fff1          65521
               BANK0 : $0001              1
      bin_to_bcd_bit : $c36b          50027
              buf_ef : $003c             60
              buf_hi : $003a             58
              buf_lo : $0039             57
              buf_sz : $003b             59
     CMD_ERR_NOERROR : $0000              0   *
    CMD_ERR_NOTFOUND : $0001              1   *
        CMD_ERR_PARM : $0002              2   *
         CMD_ERR_VAL : $0003              3   *
           CRSR_DOWN : $000a             10   *
           CRSR_LEFT : $0008              8   *
          CRSR_RIGHT : $0009              9   *
             CRSR_UP : $000b             11   *
           CTRL_CAPS : $0014             20   *
        call_irq_brk : $c0d9          49369
     call_irq_master : $c0d6          49366
   call_irq_usercia0 : $c0dc          49372
       cmd_check_cmd : $d4d7          54487
         cmd_check_d : $d4ea          54506
         cmd_check_s : $d4ee          54510
         cmd_dumpmem : $d51e          54558
    cmd_dumpmemASCII : $d542          54594
      cmd_dumpmemFin : $d577          54647
   cmd_dumpmem_ascii : $d554          54612
   cmd_dumpmem_block : $d524          54564
    cmd_dumpmem_byte : $d533          54579
  cmd_dump_skip_ctrl : $d55e          54622
   cmd_dump_skip_del : $d563          54627
           cmd_error : $d4df          54495
       cmd_find_parm : $d5c2          54722
              cmd_hi : $0096            150   *
          cmd_incmem : $d57e          54654
              cmd_lo : $0095            149   *
   cmd_next_parm_err : $d5cc          54732
       cmd_not_found : $d4f2          54514
           cmd_parse : $d4e9          54505
      cmd_parse_byte : $d593          54675
  cmd_parse_byte_err : $d5ad          54701
AS65 Assembler for R6502 [1.42].                                     Page    2
---------------------------------- bank0.s -----------------------------------

 cmd_parse_byte_errp : $d5ac          54700
 cmd_parse_next_parm : $d5c1          54721
      cmd_parse_word : $d5af          54703
            cmd_peek : $d585          54661
            cmd_poke : $d58a          54666
           cmd_ready : $d4c3          54467
          cmd_setmem : $d4f8          54520
     cmd_setmem_byte : $d4fd          54525
      cmd_setmem_err : $d51c          54556
        cmd_word_err : $d5bf          54719
        command_line : $d4c3          54467
       con_bin_digit : $c250          49744
        con_bin_done : $c266          49766
         con_bin_err : $c270          49776
         con_bin_jmp : $c1ee          49646
        con_bin_to_a : $c248          49736
    con_bin_to_a_int : $c24c          49740
         con_dec_jmp : $c1e2          49634
        con_dec_to_a : $c272          49778
    con_dec_to_a_int : $c276          49782
       con_hex_digit : $c211          49681
        con_hex_done : $c23e          49726
         con_hex_err : $c23c          49724
         con_hex_jmp : $c1e8          49640
  con_hex_skip_x_f_1 : $c21e          49694
        con_hex_to_a : $c209          49673
    con_hex_to_a_int : $c20d          49677
           con_n_err : $c1f1          49649
       con_n_not_dec : $c1e5          49637
       con_n_not_hex : $c1eb          49643
          con_n_to_a : $c1d1          49617
   con_n_to_a_detect : $c1f3          49651
                DDRA : $0003              3   *
                DDRB : $0002              2   *
         DFERR_ABORT : $0012             18   *
         DFERR_BREAK : $000d             13   *
           DFERR_DIM : $0003              3   *
         DFERR_FNAME : $000b             11   *
     DFERR_IMMEDIATE : $0007              7   *
       DFERR_NEXTFOR : $000a             10   *
        DFERR_NODATA : $000e             14   *
          DFERR_NOIF : $0009              9   *
        DFERR_NOLINE : $0010             16   *
         DFERR_NOORG : $0014             20   *
        DFERR_NOPROC : $0005              5   *
            DFERR_OK : $0000              0   *
      DFERR_PROCPARM : $0006              6   *
      DFERR_QUANTITY : $0013             19   *
        DFERR_RETURN : $0011             17   *
       DFERR_STRLONG : $000c             12   *
        DFERR_SYNTAX : $0001              1   *
      DFERR_TYPEMISM : $0002              2   *
    DFERR_UNCLOSEDIF : $0008              8   *
         DFERR_UNTIL : $0004              4   *
          DFERR_WEND : $000f             15   *
          DFRT_ABORT : $0089            137   *
            DFRT_ASM : $0097            151   *
           DFRT_DATA : $0096            150   *
            DFRT_DEF : $0086            134   *
           DFRT_ELSE : $0093            147   *
         DFRT_ELSEIF : $0095            149   *
         DFRT_ENDDEF : $0087            135   *
AS65 Assembler for R6502 [1.42].                                     Page    3
---------------------------------- bank0.s -----------------------------------

          DFRT_ENDIF : $0094            148   *
            DFRT_FOR : $008e            142   *
             DFRT_IF : $0092            146   *
           DFRT_NEXT : $008f            143   *
         DFRT_REPEAT : $008c            140   *
         DFRT_RETURN : $0088            136   *
           DFRT_WEND : $0091            145   *
          DFRT_WHILE : $0090            144   *
            DFST_INT : $0003              3   *
            DFST_PTR : $00ff            255   *
            DFST_STR : $0004              4   *
            DFTK_BYT : $0020             32   *
         DFTK_BYTBIN : $0007              7   *
         DFTK_BYTDEC : $0005              5   *
         DFTK_BYTHEX : $0006              6   *
            DFTK_CHR : $0000              0   *
            DFTK_EOL : $0000              0   *
         DFTK_ESCVAL : $0020             32   *
            DFTK_FLT : $0080            128   *
             DFTK_FN : $0002              2   *
            DFTK_INT : $0010             16   *
         DFTK_INTBIN : $000b             11   *
         DFTK_INTDEC : $0009              9   *
         DFTK_INTHEX : $000a             10   *
             DFTK_KW : $0001              1   *
         DFTK_LINLEN : $0000              0   *
         DFTK_LINNUM : $0001              1   *
             DFTK_OP : $0008              8   *
          DFTK_OPMSK : $0007              7   *
           DFTK_PROC : $0012             18   *
          DFTK_RESVC : $000c             12   *
          DFTK_RESVD : $000d             13   *
          DFTK_RESVE : $000e             14   *
          DFTK_RESVF : $000f             15   *
          DFTK_RESV1 : $0001              1   *
          DFTK_RESV2 : $0002              2   *
          DFTK_RESV3 : $0003              3   *
          DFTK_RESV4 : $0004              4   *
          DFTK_RESV8 : $0008              8   *
          DFTK_RTMSK : $00f8            248   *
          DFTK_STEND : $001f             31   *
            DFTK_STR : $0040             64   *
         DFTK_STRLIT : $0010             16   *
          DFTK_STROP : $0004              4   *
          DFTK_TOKEN : $0080            128   *
            DFTK_VAR : $0011             17   *
        DFTK_VARPARM : $0026             38   *
           DFVVT_BYT : $0002              2   *
          DFVVT_DIM1 : $0003              3   *
          DFVVT_DIM2 : $0004              4   *
           DFVVT_FLT : $0008              8   *
            DFVVT_HI : $0002              2   *
           DFVVT_INT : $0001              1   *
            DFVVT_LO : $0001              1   *
          DFVVT_PROC : $0040             64   *
           DFVVT_PTR : $0080            128   *
           DFVVT_STR : $0004              4   *
            DFVVT_SZ : $0008              8   *
          DFVVT_TYPE : $0000              0   *
           DF_MEMTOP : $9800          38912   *
        DF_PROGSTART : $071f           1823   *
          dflat_zp_e : $00ac            172
AS65 Assembler for R6502 [1.42].                                     Page    4
---------------------------------- bank0.s -----------------------------------

          dflat_zp_s : $005c             92
     dflat_zp_save_e : $00a2            162
     dflat_zp_save_s : $005c             92
          df_asmadmd : $009d            157
           df_asmlen : $00a1            161
         df_asmopcde : $009e            158
         df_asmoprnd : $009f            159
           df_asmopt : $009c            156
            df_asmpc : $009a            154
  df_asm_altaddrmode : $fd9b          64923
       df_asm_length : $fd8a          64906
    df_asm_tokensyms : $fdac          64940
            df_brkpc : $0063             99
           df_brkval : $0065            101
         df_checkkey : $005c             92
         df_checkmsk : $005d             93
            df_clear : $f7cc          63436
          df_currdat : $0095            149
          df_currlin : $0087            135
         df_curstidx : $0081            129
           df_datoff : $0097            151
           df_eolidx : $007f            127
           df_exeoff : $0089            137
           df_ifnest : $0094            148
            df_immed : $005f             95
             df_init : $f7bf          63423
          df_initrun : $e1b9          57785
       df_lexer_line : $db25          56101
  df_lexer_skip_lnum : $db46          56134
          df_linbuff : $0400           1024
          df_lineidx : $0093            147
          df_lineptr : $0091            145
           df_linoff : $007d            125
           df_memtop : $061d           1565
          df_msg_acc : $f98c          63884
           df_msg_pc : $f988          63880
         df_msg_xreg : $f98f          63887
         df_msg_yreg : $f992          63890
          df_nextlin : $008a            138
         df_nxtstidx : $0080            128
     df_ost_peekType : $f795          63381
       df_ost_popInt : $f79b          63387
     df_ost_popParmX : $f77e          63358
       df_ost_popPtr : $f7a3          63395
       df_ost_popStr : $f79f          63391
      df_ost_pushInt : $f76b          63339
     df_ost_pushIntA : $f76f          63343
    df_ost_pushParmX : $f755          63317
      df_ost_pushPtr : $f77a          63354
      df_ost_pushStr : $f776          63350
          df_parmtop : $0078            120
               df_pc : $0061             97
    df_pg_check_line : $e06d          57453
df_pg_check_next_line : $e056          57430
df_pg_copyinputtolinbuff : $e108          57608
  df_pg_delete_block : $e0d0          57552
   df_pg_delete_byte : $e0d6          57558
df_pg_delete_next_byte : $e0f7          57591
         df_pg_dflat : $e112          57618
     df_pg_find_line : $e04a          57418
    df_pg_getcommand : $e128          57640
     df_pg_inputline : $e100          57600
AS65 Assembler for R6502 [1.42].                                     Page    5
---------------------------------- bank0.s -----------------------------------

  df_pg_inputline_ok : $e108          57608
 df_pg_insertlinbyte : $e1a9          57769
    df_pg_insertline : $e18a          57738
  df_pg_insert_block : $e09b          57499
   df_pg_insert_byte : $e0a7          57511
df_pg_insert_next_byte : $e0c5          57541
   df_pg_line_number : $e16a          57706
       df_pg_nothing : $e169          57705
    df_pg_prompt_msg : $e1b2          57778
    df_pg_runcommand : $e13d          57661
 df_pg_skip_del_line : $e180          57728
      df_pg_tokenise : $e151          57681
           df_prgend : $0068            104
          df_prgstrt : $0066            102
         df_procargs : $008d            141
          df_procloc : $008e            142
         df_procmode : $008c            140
          df_procptr : $008f            143
df_pr_line_gt_target : $e062          57442
    df_pr_line_match : $e090          57488
              df_raw : $0400           1024
              df_rnd : $0098            152
     df_rst_peekByte : $f734          63284
      df_rst_popByte : $f72b          63275
      df_rst_popWord : $f748          63304
     df_rst_pushByte : $f722          63266
     df_rst_pushWord : $f73a          63290
          df_rtspace : $0500           1280
           df_rtstck : $0500           1280
           df_rtstop : $0077            119
         df_rt_abort : $f58e          62862
           df_rt_add : $e77c          59260
          df_rt_addr : $f477          62583
         df_rt_aequb : $e858          59480
      df_rt_aequbFin : $e862          59490
           df_rt_and : $e82b          59435
  df_rt_array_exists : $e494          58516
     df_rt_arry_parm : $e39f          58271
    df_rt_arry_parm2 : $e3a6          58278
df_rt_arry_parm2_arry2 : $e3be          58302
df_rt_arry_parm2_skiparry2 : $e3c5          58309
df_rt_arry_parm2_term : $e3ae          58286
           df_rt_asc : $f567          62823
           df_rt_asl : $e805          59397
        df_rt_aslbit : $e80b          59403
       df_rt_asldone : $e815          59413
    df_rt_asm_ABSREL : $fcdf          64735
    df_rt_asm_AM_ABS : $fcf6          64758
   df_rt_asm_AM_ABSX : $fd03          64771
   df_rt_asm_AM_ABSY : $fcf1          64753
    df_rt_asm_AM_IMM : $fd08          64776
    df_rt_asm_AM_IMP : $fcda          64730
df_rt_asm_AM_INDIRECT : $fd12          64786
    df_rt_asm_AM_REL : $fd00          64768
  df_rt_asm_AM_ZPIND : $fd38          64824
df_rt_asm_AM_ZPINDORY : $fd28          64808
  df_rt_asm_addrmode : $fcbe          64702
  df_rt_asm_assemble : $fa8f          64143
df_rt_asm_assemble_done : $faa1          64161
 df_rt_asm_check_alt : $fb9b          64411
   df_rt_asm_command : $faa2          64162
      df_rt_asm_data : $fb00          64256
AS65 Assembler for R6502 [1.42].                                     Page    6
---------------------------------- bank0.s -----------------------------------

 df_rt_asm_data_done : $fb3e          64318
 df_rt_asm_data_next : $fb34          64308
df_rt_asm_data_write : $fb3f          64319
df_rt_asm_data_write_err : $fb6d          64365
df_rt_asm_data_write_hi : $fb5b          64347
df_rt_asm_data_write_skip1 : $fb42          64322
df_rt_asm_data_write_skip2 : $fb5f          64351
        df_rt_asm_db : $faf3          64243
  df_rt_asm_db_start : $faf8          64248
df_rt_asm_decode_token : $f12c          61740
df_rt_asm_decode_token_done : $f179          61817
df_rt_asm_decode_token_keyword : $f13e          61758
       df_rt_asm_dir : $fab4          64180
  df_rt_asm_do_label : $fa9e          64158
        df_rt_asm_ds : $fb6f          64367
        df_rt_asm_dw : $faf6          64246
    df_rt_asm_encode : $fbd3          64467
df_rt_asm_encode_print : $fc32          64562
df_rt_asm_encode_skiprel : $fc1b          64539
df_rt_asm_encode_writebyte : $fc21          64545
df_rt_asm_encode_writeword : $fc28          64552
df_rt_asm_err_quantity : $fc1f          64543
df_rt_asm_find_addr_mode : $fd46          64838
df_rt_asm_find_addr_mode_err : $fd5b          64859
df_rt_asm_find_addr_mode_loop : $fd4c          64844
df_rt_asm_get_operand : $fd3b          64827
     df_rt_asm_label : $fac6          64198
      df_rt_asm_mnem : $fb8c          64396
  df_rt_asm_mnem_chk : $fbaf          64431
 df_rt_asm_mnem_done : $fbbd          64445
  df_rt_asm_mnem_err : $fbd1          64465
  df_rt_asm_mnem_try : $fb92          64402
       df_rt_asm_opt : $faeb          64235
       df_rt_asm_org : $fad9          64217
   df_rt_asm_printCH : $fc99          64665
   df_rt_asm_printCR : $fc90          64656
 df_rt_asm_printline : $fca6          64678
  df_rt_asm_printOPC : $fc62          64610
  df_rt_asm_printOPR : $fc76          64630
df_rt_asm_printOPR_1 : $fc8b          64651
   df_rt_asm_printPC : $fc52          64594
  df_rt_asm_printSPC : $fc6d          64621
df_rt_asm_print_mmen : $fc42          64578
 df_rt_asm_print_rts : $fc51          64593
df_rt_asm_rel_postive : $fc15          64533
df_rt_asm_skip_to_sym : $fd5e          64862
df_rt_asm_skip_to_sym_done : $fd5d          64861
df_rt_asm_skip_to_sym_end : $fd7b          64891
df_rt_asm_skip_to_sym_next : $fd6c          64876
    df_rt_asm_string : $fb17          64279
 df_rt_asm_string_ch : $fb1e          64286
  df_rt_asm_tokenjmp : $ffe7          65511
        df_rt_assign : $ee69          61033
    df_rt_assign_str : $ee76          61046
         df_rt_asubb : $e863          59491
      df_rt_asubbFin : $e870          59504
   df_rt_binlen_skip : $f352          62290
         df_rt_bload : $f2c8          62152
    df_rt_bload_addr : $f2eb          62187
         df_rt_bsave : $f2fb          62203
   df_rt_bsave_parms : $f330          62256
         df_rt_bsuba : $e871          59505
AS65 Assembler for R6502 [1.42].                                     Page    7
---------------------------------- bank0.s -----------------------------------

      df_rt_bsubaFin : $e87e          59518
          df_rt_call : $f448          62536
       df_rt_calljsr : $f457          62551
     df_rt_check_pos : $eb04          60164
   df_rt_check_while : $e9aa          59818
           df_rt_chr : $f4bf          62655
        df_rt_circle : $ed9f          60831
           df_rt_cls : $ecfe          60670
         df_rt_comeq : $e8d9          59609
         df_rt_comgt : $e8d0          59600
        df_rt_comgte : $e8eb          59627
         df_rt_comlt : $e8c7          59591
        df_rt_comlte : $e8e2          59618
       df_rt_comment : $ee7a          61050
         df_rt_comne : $e8f4          59636
       df_rt_copyStr : $e361          58209
    df_rt_copyStr_ch : $e363          58211
  df_rt_copyStr_done : $e36c          58220
       df_rt_copy_fn : $f23d          62013
        df_rt_cursor : $ed73          60787
          df_rt_data : $ee7a          61050
 df_rt_datastatement : $eb6b          60267
   df_rt_datlinstart : $eb63          60259
    df_rt_datnextlin : $eb71          60273
      df_rt_datumerr : $eb99          60313
           df_rt_dec : $f504          62724
    df_rt_dec_binlen : $f34c          62284
          df_rt_deek : $f36e          62318
           df_rt_def : $f66c          63084
        df_rt_deferr : $f5ca          62922
  df_rt_def_find_var : $f679          63097
   df_rt_def_got_var : $f68b          63115
df_rt_def_got_varparm : $f688          63112
df_rt_def_initialise_parm : $f6c7          63175
  df_rt_def_load_var : $f6a7          63143
df_rt_def_load_var_done : $f6da          63194
 df_rt_def_parm_done : $f69f          63135
        df_rt_delete : $f24a          62026
           df_rt_dim : $ec73          60531
     df_rt_dim2_mul2 : $ece0          60640
       df_rt_dim2_nz : $eccb          60619
     df_rt_dim_alloc : $ecba          60602
      df_rt_dim_done : $ecfa          60666
       df_rt_dim_err : $ecfc          60668
   df_rt_dim_findesc : $ec78          60536
      df_rt_dim_loop : $ec75          60533
      df_rt_dim_main : $ec74          60532
  df_rt_dim_set_type : $ecef          60655
           df_rt_dir : $f257          62039
           df_rt_div : $e7c3          59331
      df_rt_doassign : $ee6c          61036
          df_rt_doke : $f17a          61818
        df_rt_doline : $edb8          60856
       df_rt_dosound : $f1c1          61889
       df_rt_do_else : $ea76          60022
      df_rt_do_fname : $f239          62009
       df_rt_elapsed : $f42d          62509
          df_rt_else : $ea26          59942
        df_rt_elseif : $ea26          59942
        df_rt_enddef : $f6e4          63204
         df_rt_endif : $ea21          59937
           df_rt_eor : $e849          59465
AS65 Assembler for R6502 [1.42].                                     Page    8
---------------------------------- bank0.s -----------------------------------

           df_rt_eos : $ee7c          61052
      df_rt_eos_true : $ee8a          61066
            df_rt_eq : $e8b3          59571
        df_rt_escjmp : $e74f          59215
      df_rt_eval_byt : $e4af          58543
   df_rt_eval_bytbin : $e377          58231
   df_rt_eval_bytdec : $e377          58231
   df_rt_eval_bythex : $e377          58231
      df_rt_eval_chr : $e377          58231
      df_rt_eval_esc : $e2ab          58027
  df_rt_eval_esc_tab : $e2ba          58042
   df_rt_eval_intbin : $e377          58231
   df_rt_eval_intdec : $e377          58231
   df_rt_eval_inthex : $e377          58231
     df_rt_eval_lvar : $e400          58368
   df_rt_eval_lvskip : $e3dd          58333
     df_rt_eval_proc : $e4c0          58560
 df_rt_eval_proc_err : $e4cd          58573
      df_rt_eval_ptr : $e4b9          58553
 df_rt_eval_reserved : $e383          58243
   df_rt_eval_strlit : $e385          58245
df_rt_eval_strlit_ch : $e395          58261
df_rt_eval_strlit_done : $e39c          58268
      df_rt_eval_var : $e3ca          58314
df_rt_eval_var_dim2adj : $e448          58440
df_rt_eval_var_dim2adjx : $e454          58452
df_rt_eval_var_dim2adjy : $e44f          58447
df_rt_eval_var_do_arry : $e41d          58397
df_rt_eval_var_nomult : $e46b          58475
df_rt_eval_var_notarry : $e3f0          58352
 df_rt_eval_var_push : $e483          58499
df_rt_eval_var_simple : $e40d          58381
  df_rt_eval_var_str : $e4b8          58552
df_rt_exec_check_key : $e589          58761
   df_rt_exec_ctrl_c : $e591          58769
   df_rt_exec_ctrl_z : $e593          58771
      df_rt_exec_end : $e587          58759
 df_rt_exec_find_tok : $e54b          58699
df_rt_exec_found_tok : $e550          58704
 df_rt_exec_init_ptr : $e544          58692
     df_rt_exec_jump : $e595          58773
   df_rt_exec_no_key : $e564          58724
     df_rt_exec_proc : $f622          63010
     df_rt_exec_stat : $e53e          58686
         df_rt_false : $e885          59525
  df_rt_file_cleanup : $f28a          62090
     df_rt_file_errc : $f274          62068
 df_rt_findelseendif : $e9e9          59881
    df_rt_findescval : $e64a          58954
df_rt_findescval_loop : $e64d          58957
      df_rt_findproc : $e602          58882
  df_rt_findproc_cmd : $e614          58900
  df_rt_findproc_err : $e648          58952
df_rt_findproc_nextstat : $e634          58932
      df_rt_findwend : $e977          59767
    df_rt_fname_case : $f23f          62015
           df_rt_for : $ea79          60025
 df_rt_generate_lvar : $ee46          60998
           df_rt_get : $f3ff          62463
     df_rt_getdatatk : $eb7f          60287
       df_rt_getlvar : $e664          58980
       df_rt_getnval : $e220          57888
AS65 Assembler for R6502 [1.42].                                     Page    9
---------------------------------- bank0.s -----------------------------------

      df_rt_get2Ints : $e4cf          58575
      df_rt_get2Strs : $e4de          58590
      df_rt_get_push : $f410          62480
     df_rt_get_pushp : $f40f          62479
      df_rt_get_sync : $f404          62468
            df_rt_gt : $e89f          59551
           df_rt_gte : $e8a9          59561
      df_rt_gte_calc : $e8ac          59564
           df_rt_hex : $f4d3          62675
         df_rt_hires : $ed7c          60796
            df_rt_if : $ea38          59960
         df_rt_ifcmd : $e9ec          59884
        df_rt_ifelse : $ea0a          59914
        df_rt_ifeval : $ea3a          59962
  df_rt_ifskipelseif : $ea01          59905
       df_rt_if_done : $ea25          59941
      df_rt_if_found : $ea17          59927
      df_rt_if_match : $e9e1          59873
       df_rt_if_stat : $e9cb          59851
   df_rt_if_stat_err : $e9df          59871
     df_rt_init_done : $e21f          57887
 df_rt_init_filename : $f208          61960
 df_rt_init_stat_ptr : $e52b          58667
      df_rt_init_vvt : $e1e4          57828
 df_rt_init_vvt_skip : $e211          57873
df_rt_init_vvt_skip_proc : $e209          57865
 df_rt_init_vvt_slot : $e1ee          57838
df_rt_init_vvt_slot_undim : $e1fa          57850
df_rt_init_vvt_z_loop : $e20b          57867
           df_rt_ink : $ed85          60805
         df_rt_input : $ec08          60424
     df_rt_input_err : $ec42          60482
     df_rt_input_num : $ec2b          60459
     df_rt_input_str : $ec23          60451
    df_rt_ldtokenise : $f2b0          62128
          df_rt_left : $f511          62737
           df_rt_len : $f55b          62811
          df_rt_line : $edbf          60863
        df_rt_lineto : $edb1          60849
          df_rt_list : $ef2d          61229
  df_rt_listcheckvnt : $ee98          61080
   df_rt_listgotnext : $eec6          61126
   df_rt_listnextvnt : $eebf          61119
   df_rt_listpn_done : $eed6          61142
       df_rt_listprg : $ef54          61268
    df_rt_listprgend : $ef5c          61276
      df_rt_listproc : $eed7          61143
    df_rt_listprocch : $eea4          61092
    df_rt_listproccr : $eeaf          61103
 df_rt_listprocnames : $ee8c          61068
 df_rt_listprocpause : $eeb5          61109
    df_rt_listp_copy : $eede          61150
    df_rt_listp_done : $ef21          61217
 df_rt_listp_findcmd : $ef07          61191
 df_rt_listp_findend : $ef00          61184
df_rt_listp_notfound : $ef2b          61227
      df_rt_listwait : $eebc          61116
      df_rt_list_all : $ef40          61248
 df_rt_list_all_line : $efa3          61347
   df_rt_list_decode : $efaf          61359
df_rt_list_decode_esc : $efe1          61409
df_rt_list_decode_token : $f0ee          61678
AS65 Assembler for R6502 [1.42].                                     Page   10
---------------------------------- bank0.s -----------------------------------

df_rt_list_decode_token_normal : $f0f5          61685
   df_rt_list_donvvt : $f0dc          61660
df_rt_list_do_decode_tkn : $f0fc          61692
   df_rt_list_escval : $efbf          61375
  df_rt_list_findvvt : $f086          61574
df_rt_list_find_asm_sym : $f149          61769
 df_rt_list_find_sym : $f105          61701
   df_rt_list_gotvvt : $f0b3          61619
df_rt_list_gotvvtend : $f09f          61599
df_rt_list_got_asm_sym : $f167          61799
df_rt_list_got_last_sym : $f116          61718
  df_rt_list_got_sym : $f11a          61722
     df_rt_list_line : $ef62          61282
df_rt_list_line_cont : $ef7c          61308
 df_rt_list_line_fin : $efa0          61344
df_rt_list_line_only : $efa6          61350
df_rt_list_line_only_fin : $efa2          61346
    df_rt_list_linno : $ef47          61255
   df_rt_list_linnum : $f0dd          61661
  df_rt_list_nexttok : $efc8          61384
df_rt_list_next_asm_ch : $f14e          61774
  df_rt_list_next_ch : $f10a          61706
df_rt_list_next_line : $ef83          61315
    df_rt_list_pause : $ef71          61297
  df_rt_list_synckey : $ef6d          61293
    df_rt_list_token : $efc5          61381
   df_rt_list_vvtend : $f092          61586
       df_rt_loadbin : $f31c          62236
  df_rt_loadbin_byte : $f31e          62238
   df_rt_loadbin_inc : $f328          62248
      df_rt_loadline : $f298          62104
         df_rt_local : $ec44          60484
    df_rt_local_done : $ec6c          60524
 df_rt_local_findesc : $ec4b          60491
           df_rt_lsr : $e818          59416
        df_rt_lsrbit : $e81e          59422
       df_rt_lsrdone : $e828          59432
       df_rt_lst_bin : $f04c          61516
       df_rt_lst_bit : $f056          61526
 df_rt_lst_bit_skip0 : $f05e          61534
    df_rt_lst_bytbin : $f042          61506
    df_rt_lst_bythex : $f01d          61469
       df_rt_lst_chr : $f000          61440
df_rt_lst_const_done : $f02c          61484
   df_rt_lst_hex_pre : $f013          61459
    df_rt_lst_intbin : $f04a          61514
    df_rt_lst_intdec : $f066          61542
    df_rt_lst_inthex : $f030          61488
    df_rt_lst_lo_hex : $f020          61472
      df_rt_lst_proc : $f071          61553
  df_rt_lst_reserved : $efff          61439
    df_rt_lst_strlit : $f0c3          61635
  df_rt_lst_strlitch : $f0ca          61642
 df_rt_lst_strlitdon : $f0d5          61653
       df_rt_lst_var : $f071          61553
            df_rt_lt : $e88b          59531
           df_rt_lte : $e895          59541
      df_rt_lte_calc : $e898          59544
           df_rt_mem : $f3ab          62379
      df_rt_mem_calc : $f3ec          62444
      df_rt_mem_free : $f3b6          62390
       df_rt_mem_prg : $f3c9          62409
AS65 Assembler for R6502 [1.42].                                     Page   11
---------------------------------- bank0.s -----------------------------------

       df_rt_mem_var : $f3dc          62428
           df_rt_mid : $f53d          62781
           df_rt_mod : $e7e4          59364
       df_rt_monitor : $e94c          59724
          df_rt_mult : $e7a2          59298
         df_rt_music : $f1c4          61892
       df_rt_nassign : $ee29          60969
            df_rt_ne : $e8bd          59581
         df_rt_neval : $e226          57894
    df_rt_neval_done : $e272          57970
   df_rt_neval_donow : $e295          58005
     df_rt_neval_esc : $e250          57936
df_rt_neval_nextbyte : $e27a          57978
    df_rt_neval_optk : $e229          57897
 df_rt_neval_process : $e269          57961
  df_rt_neval_pushOp : $e2a6          58022
      df_rt_neval_tk : $e257          57943
   df_rt_neval_tk_fn : $e273          57971
   df_rt_neval_tk_op : $e27f          57983
  df_rt_neval_tk_opp : $e27e          57982
           df_rt_new : $e94f          59727
          df_rt_next : $eab7          60087
     df_rt_nextdatum : $eb53          60243
      df_rt_nextstat : $e5ad          58797
  df_rt_nextstat_err : $e5d9          58841
   df_rt_nextstat_ln : $e5c4          58820
    df_rt_next_check : $eb07          60167
      df_rt_next_err : $eb10          60176
      df_rt_noif_err : $ea36          59958
     df_rt_not_dimed : $e492          58514
     df_rt_not_noise : $f1a4          61860
  df_rt_no_autostart : $f2ad          62125
df_rt_openforbinload : $f2bf          62143
df_rt_openforbinsave : $f2b6          62134
            df_rt_or : $e83a          59450
         df_rt_paper : $ed8b          60811
     df_rt_parm_pop3 : $e505          58629
    df_rt_parm_2ints : $e4ed          58605
    df_rt_parm_3ints : $e4f8          58616
    df_rt_parm_4ints : $e50f          58639
    df_rt_parse_file : $f25a          62042
df_rt_parse_file_print : $f267          62055
          df_rt_peek : $f370          62320
         df_rt_pixel : $f420          62496
       df_rt_pixmode : $ed7f          60799
          df_rt_play : $f1d9          61913
          df_rt_plot : $ed01          60673
       df_rt_plotstr : $ed34          60724
     df_rt_plotstrch : $ed45          60741
   df_rt_plotstrdone : $ed72          60786
    df_rt_plot_h_int : $ed2b          60715
    df_rt_plot_h_str : $ed60          60768
         df_rt_point : $ed95          60821
          df_rt_poke : $f17c          61820
     df_rt_poke_done : $f18f          61839
      df_rt_pop_stat : $e5e9          58857
   df_rt_pop_stat_go : $e680          59008
         df_rt_print : $edf0          60912
       df_rt_printat : $ede6          60902
       df_rt_println : $ee21          60961
    df_rt_print_done : $ee1e          60958
  df_rt_print_gotstr : $ee18          60952
AS65 Assembler for R6502 [1.42].                                     Page   12
---------------------------------- bank0.s -----------------------------------

     df_rt_print_num : $eb38          60216
     df_rt_print_str : $eb3f          60223
  df_rt_print_str_ch : $eb48          60232
df_rt_print_str_done : $eb52          60242
      df_rt_print_ws : $edf3          60915
          df_rt_proc : $f5cc          62924
     df_rt_proc_addr : $f5f6          62966
    df_rt_proc_local : $f70e          63246
df_rt_proc_local_load : $f715          63253
  df_rt_proc_parmerr : $f5ca          62922
df_rt_proc_parm_done : $f615          62997
df_rt_proc_parm_none : $f616          62998
df_rt_proc_push_parm : $f601          62977
df_rt_proc_unloadvar : $f6ea          63210
df_rt_proc_unload_done : $f70a          63242
     df_rt_push_int1 : $f454          62548
     df_rt_push_stat : $e5dd          58845
     df_rt_putintres : $e775          59253
          df_rt_read : $ebf0          60400
      df_rt_readbyte : $f371          62321
 df_rt_readbyte_skip : $f386          62342
     df_rt_readdatum : $eb9b          60315
     df_rt_read_done : $ec05          60421
 df_rt_read_find_var : $ebf2          60402
         df_rt_redim : $ec70          60528
        df_rt_repeat : $eb12          60178
         df_rt_reset : $f359          62297
        df_rt_return : $f6e1          63201
         df_rt_right : $f522          62754
           df_rt_rnd : $f389          62345
     df_rt_rnd_noeor : $f39d          62365
       df_rt_rnd_set : $f3a4          62372
           df_rt_run : $ee7b          61051
     df_rt_run_token : $e59e          58782
          df_rt_sadd : $eb37          60215
       df_rt_sassign : $ee40          60992
       df_rt_savebin : $f32e          62254
  df_rt_savebin_byte : $f33c          62268
   df_rt_savebin_inc : $f346          62278
          df_rt_scrn : $f413          62483
  df_rt_sd_connected : $f21b          61979
           df_rt_seq : $e928          59688
         df_rt_seval : $e2e0          58080
    df_rt_seval_copy : $e33a          58170
    df_rt_seval_done : $e35d          58205
     df_rt_seval_esc : $e306          58118
df_rt_seval_esc_proc : $e35b          58203
df_rt_seval_esc_strlit : $e355          58197
 df_rt_seval_esc_var : $e336          58166
df_rt_seval_nextbyte : $e350          58192
    df_rt_seval_optk : $e2ee          58094
      df_rt_seval_tk : $e314          58132
   df_rt_seval_tk_fn : $e32d          58157
   df_rt_seval_tk_op : $e329          58153
           df_rt_sgn : $f45a          62554
         df_rt_sgn_n : $f46d          62573
         df_rt_sgn_z : $f472          62578
           df_rt_sgt : $e91f          59679
          df_rt_sgte : $e90a          59658
df_rt_skipinitdataptr : $eb89          60297
 df_rt_skipnestendif : $ea14          59924
    df_rt_skipnestif : $ea07          59911
AS65 Assembler for R6502 [1.42].                                     Page   13
---------------------------------- bank0.s -----------------------------------

  df_rt_skip_dim_chk : $ec9a          60570
       df_rt_skip_ws : $e657          58967
  df_rt_skip_ws_loop : $e65a          58970
           df_rt_slt : $e918          59672
          df_rt_slte : $e8fd          59645
    df_rt_snd_common : $f190          61840
           df_rt_sne : $e911          59665
         df_rt_sound : $f1be          61886
df_rt_sound_env_skip : $f1bb          61883
       df_rt_sprchar : $f590          62864
        df_rt_sprhit : $f5b8          62904
df_rt_sprhit_inactive : $f5c4          62916
       df_rt_sprinit : $f5af          62895
      df_rt_sprmulti : $f5b2          62898
        df_rt_sprpos : $f59a          62874
        df_rt_sprupd : $f5a6          62886
         df_rt_stick : $f3f9          62457
 df_rt_strlen_common : $f47f          62591
  df_rt_strlen_count : $f485          62597
      df_rt_str_comp : $e92f          59695
 df_rt_str_comp_byte : $e934          59700
   df_rt_str_comp_eq : $e949          59721
df_rt_str_comp_false : $e904          59652
   df_rt_str_comp_gt : $e946          59718
   df_rt_str_comp_lt : $e943          59715
 df_rt_str_comp_true : $e907          59655
    df_rt_str_cpy_ch : $f49f          62623
   df_rt_str_extract : $f48c          62604
           df_rt_sub : $e78f          59279
          df_rt_sval : $e2e4          58084
          df_rt_text : $ed79          60793
         df_rt_tload : $f290          62096
      df_rt_tokenjmp : $e689          59017
          df_rt_true : $e87f          59519
      df_rt_try_tape : $f233          62003
         df_rt_tsave : $f276          62070
         df_rt_until : $eb1a          60186
df_rt_untilnext_done : $eb2d          60205
     df_rt_until_err : $eb35          60213
           df_rt_val : $f578          62840
       df_rt_val_err : $f58c          62860
          df_rt_wait : $edd0          60880
  df_rt_wait_counter : $edd4          60884
     df_rt_wait_done : $ede5          60901
   df_rt_wait_skiphi : $edde          60894
     df_rt_wait_tick : $edd6          60886
          df_rt_wend : $e9b5          59829
      df_rt_wend_end : $e9b3          59827
      df_rt_wend_err : $e9c9          59849
         df_rt_while : $e952          59730
     df_rt_while_cmd : $e988          59784
    df_rt_while_done : $e962          59746
         df_sevalptr : $007b            123
    df_show_err_done : $f93a          63802
     df_show_err_fin : $f919          63769
    df_show_err_find : $f8cd          63693
  df_show_err_linnum : $f900          63744
    df_show_err_skip : $f8d1          63697
               df_sp : $0060             96
          df_starend : $0075            117
         df_starstrt : $0073            115
         df_strbuffz : $0079            121
AS65 Assembler for R6502 [1.42].                                     Page   14
---------------------------------- bank0.s -----------------------------------

          df_stridxz : $007a            122
      df_str_src_end : $f4b4          62644
        df_st_malloc : $f7a7          63399
df_st_typemismatcherr : $f793          63379
          df_syminiz : $0085            133
           df_symoff : $0084            132
           df_symtab : $0082            130
         df_tk_abort : $e022          57378
           df_tk_add : $e022          57378
          df_tk_addr : $dfff          57343
           df_tk_and : $e022          57378
        df_tk_arrvar : $d9e2          55778
           df_tk_asc : $dff5          57333
           df_tk_asl : $e022          57378
 df_tk_asm_addr_mode : $fa30          64048
df_tk_asm_addr_mode_ok : $fa1f          64031
df_tk_asm_addr_mode_1 : $fa45          64069
df_tk_asm_addr_mode_2 : $fa4f          64079
df_tk_asm_checknexttok : $f9d8          63960
df_tk_asm_checktokch : $f9da          63962
        df_tk_asm_db : $df89          57225
        df_tk_asm_ds : $e027          57383
        df_tk_asm_dw : $df89          57225
df_tk_asm_exec_parser : $fa21          64033
df_tk_asm_foundsymend : $fa00          64000
df_tk_asm_found_command : $f99a          63898
     df_tk_asm_label : $f9b7          63927
  df_tk_asm_matchtok : $f9ca          63946
  df_tk_asm_mnemonic : $f9b4          63924
       df_tk_asm_opt : $e027          57383
       df_tk_asm_org : $e027          57383
df_tk_asm_parse_command : $f995          63893
df_tk_asm_parse_command_err : $f9b3          63923
  df_tk_asm_symfound : $fa13          64019
df_tk_asm_symnextentry : $f9f1          63985
df_tk_asm_symnomatch : $f9ef          63983
  df_tk_asm_tokenjmp : $ffdd          65501
        df_tk_assign : $df32          57138
         df_tk_bload : $e02d          57389
          df_tk_body : $db4e          56142
         df_tk_bsave : $e037          57399
          df_tk_call : $e014          57364
      df_tk_callproc : $dfe9          57321
          df_tk_char : $d93a          55610
      df_tk_char_err : $d8e2          55522
         df_tk_chdir : $e027          57383
  df_tk_checknexttok : $dbe1          56289
    df_tk_checktokch : $dbfe          56318
           df_tk_chr : $dff5          57333
        df_tk_circle : $e037          57399
     df_tk_closebrkt : $dffa          57338
           df_tk_cls : $e022          57378
        df_tk_colour : $e037          57399
       df_tk_comment : $df3b          57147
  df_tk_comment_done : $df46          57158
         df_tk_const : $d978          55672
     df_tk_const_err : $d998          55704
df_tk_const_try_char : $d991          55697
 df_tk_const_try_num : $d987          55687
 df_tk_const_try_str : $d98a          55690
        df_tk_cursor : $e027          57383
          df_tk_data : $df89          57225
AS65 Assembler for R6502 [1.42].                                     Page   15
---------------------------------- bank0.s -----------------------------------

     df_tk_data_done : $df87          57223
           df_tk_dec : $dff5          57333
          df_tk_deek : $dff5          57333
           df_tk_def : $dfcd          57293
           df_tk_del : $e027          57383
        df_tk_delete : $e027          57383
           df_tk_dim : $dfaf          57263
           df_tk_dir : $e022          57378
           df_tk_div : $e022          57378
          df_tk_doke : $e02d          57389
          df_tk_done : $db84          56196
       df_tk_elapsed : $dfff          57343
          df_tk_else : $e022          57378
        df_tk_elseif : $e027          57383
        df_tk_enddef : $e022          57378
         df_tk_endif : $e022          57378
           df_tk_eor : $e022          57378
            df_tk_eq : $e022          57378
         df_tk_error : $df30          57136
      df_tk_errortab : $f802          63490
        df_tk_error2 : $dff3          57331
   df_tk_error_atpos : $f8a6          63654
   df_tk_error_error : $f8ac          63660
  df_tk_error_inline : $f89c          63644
   df_tk_exec_parser : $dba6          56230
        df_tk_expect : $d8d6          55510
      df_tk_expectok : $d8d4          55508
    df_tk_expect_tok : $d8e4          55524
df_tk_expect_tok_err : $d8ef          55535
df_tk_expect_tok_fatal : $d8f4          55540
    df_tk_expression : $dae1          56033
     df_tk_expre_err : $daec          56044
     df_tk_expr_more : $df8e          57230
           df_tk_for : $dfd2          57298
   df_tk_foundsymend : $dc2d          56365
           df_tk_get : $dff5          57333
       df_tk_get_buf : $d864          55396
  df_tk_get_buf_null : $d86e          55406
            df_tk_gt : $e022          57378
           df_tk_gte : $e022          57378
         df_tk_hchar : $e037          57399
           df_tk_hex : $dff5          57333
         df_tk_hires : $e022          57378
            df_tk_if : $e027          57383
           df_tk_imm : $fa65          64101
      df_tk_indirect : $fa68          64104
 df_tk_indirect_done : $fa8d          64141
    df_tk_indirect_y : $fa7c          64124
           df_tk_ink : $e027          57383
         df_tk_input : $df97          57239
       df_tk_isalpha : $d8a7          55463
    df_tk_isalphanum : $d8b4          55476
 df_tk_isalpha_false : $d8a4          55460
         df_tk_isbin : $d888          55432
    df_tk_isbin_true : $d891          55441
       df_tk_isdigit : $d87d          55421
 df_tk_isdigit_false : $d886          55430
         df_tk_isEOS : $daf3          56051
         df_tk_ishex : $d892          55442
   df_tk_ishex_false : $d8a4          55460
   df_tk_ishex_truep : $d8a2          55458
        df_tk_isproc : $d8ba          55482
AS65 Assembler for R6502 [1.42].                                     Page   16
---------------------------------- bank0.s -----------------------------------

   df_tk_isproc_true : $d8bf          55487
          df_tk_isws : $d8cf          55503
    df_tk_isws_false : $d8d4          55508
          df_tk_left : $e008          57352
           df_tk_len : $dff5          57333
          df_tk_line : $e03f          57407
       df_tk_linenum : $dbb5          56245
        df_tk_lineto : $e02d          57389
    df_tk_line_empty : $dba2          56226
          df_tk_list : $df6b          57195
df_tk_listp_procname : $df48          57160
df_tk_listp_procname_ch : $df57          57175
df_tk_listp_procname_err : $df69          57193
df_tk_listp_procname_ok : $df68          57192
     df_tk_list_done : $df7b          57211
     df_tk_list_line : $df77          57207
    df_tk_list_procs : $df70          57200
         df_tk_local : $dfbe          57278
      df_tk_localvar : $d9cc          55756
 df_tk_localvar_cont : $d9d2          55762
           df_tk_lsr : $e022          57378
            df_tk_lt : $e022          57378
           df_tk_lte : $e022          57378
      df_tk_matchtok : $dbd4          56276
df_tk_matchtok_skip_op : $dbfa          56314
           df_tk_mem : $dff5          57333
           df_tk_mid : $e00e          57358
           df_tk_mod : $e022          57378
       df_tk_monitor : $e022          57378
          df_tk_mult : $e022          57378
         df_tk_music : $e03f          57407
         df_tk_narry : $da61          55905
     df_tk_narry_end : $da6e          55918
         df_tk_nbrkt : $da73          55923
            df_tk_ne : $e022          57378
           df_tk_new : $e022          57378
          df_tk_next : $e022          57378
     df_tk_next_expr : $df89          57225
           df_tk_nop : $dacc          56012
     df_tk_nop_false : $da8b          55947
       df_tk_not_eos : $daeb          56043
         df_tk_nterm : $da80          55936
    df_tk_nterm_cont : $da8d          55949
    df_tk_nterm_done : $da8b          55947
     df_tk_nterm_err : $daca          56010
    df_tk_nterm_proc : $da7b          55931
   df_tk_nterm_tryfn : $da9a          55962
df_tk_nterm_try_const : $dac4          56004
df_tk_nterm_try_proc : $dab0          55984
 df_tk_nterm_try_var : $dabc          55996
           df_tk_num : $d8f6          55542
       df_tk_num_bin : $d925          55589
       df_tk_num_err : $d8e2          55522
    df_tk_num_hexbin : $d917          55575
       df_tk_num_put : $d92d          55597
            df_tk_or : $e022          57378
         df_tk_paper : $e027          57383
          df_tk_parm : $d9ba          55738
 df_tk_parm_skip_var : $d9c7          55751
    df_tk_parseerror : $dba4          56228
 df_tk_parse_command : $db0d          56077
df_tk_parse_command_done : $db23          56099
AS65 Assembler for R6502 [1.42].                                     Page   17
---------------------------------- bank0.s -----------------------------------

df_tk_parse_command_err : $db24          56100
df_tk_parse_user_proc : $db03          56067
          df_tk_peek : $dff5          57333
      df_tk_peek_buf : $d85e          55390
         df_tk_pixel : $e008          57352
       df_tk_pixmode : $e027          57383
          df_tk_play : $e03f          57407
          df_tk_plot : $e037          57399
         df_tk_point : $e02d          57389
          df_tk_poke : $e02d          57389
     df_tk_preassign : $df20          57120
         df_tk_print : $df82          57218
       df_tk_printat : $df7c          57212
       df_tk_println : $df82          57218
    df_tk_print_done : $df87          57223
          df_tk_proc : $d9ed          55789
     df_tk_proc_call : $da29          55849
    df_tk_proc_comma : $da43          55875
      df_tk_proc_err : $da5f          55903
     df_tk_proc_errp : $da5e          55902
   df_tk_proc_noparm : $da4c          55884
    df_tk_proc_parms : $da1c          55836
df_tk_proc_skip_args : $da5c          55900
df_tk_proc_skip_call : $da32          55858
  df_tk_put_overflow : $d87b          55419
       df_tk_put_tok : $d86f          55407
          df_tk_read : $dfa0          57248
         df_tk_redim : $dfaf          57263
        df_tk_repeat : $e022          57378
         df_tk_reset : $dfeb          57323
        df_tk_return : $e024          57380
         df_tk_right : $e008          57352
           df_tk_rnd : $dff5          57333
          df_tk_rts1 : $d8b9          55481
           df_tk_run : $e022          57378
          df_tk_scrn : $e008          57352
           df_tk_sgn : $dff5          57333
       df_tk_skip_ws : $d8c0          55488
    df_tk_skip_1_spc : $db61          56161
         df_tk_sound : $e037          57399
       df_tk_sprchar : $e02d          57389
        df_tk_sprhit : $dff5          57333
       df_tk_sprinit : $e022          57378
     df_tk_spritepos : $e037          57399
      df_tk_sprmulti : $e02d          57389
        df_tk_sprpos : $e037          57399
        df_tk_sprupd : $e022          57378
         df_tk_stick : $dffa          57338
           df_tk_str : $d956          55638
        df_tk_str_ch : $d95e          55646
       df_tk_str_don : $d96f          55663
       df_tk_str_err : $d976          55670
           df_tk_sub : $e022          57378
      df_tk_symfound : $dc3e          56382
df_tk_symfound_final : $dc4e          56398
  df_tk_symnextentry : $dc1e          56350
    df_tk_symnomatch : $dc1c          56348
   df_tk_symnomatchp : $dc1b          56347
          df_tk_text : $e022          57378
         df_tk_tload : $e027          57383
      df_tk_tokenjmp : $dde9          56809
     df_tk_tokentype : $deaf          57007
AS65 Assembler for R6502 [1.42].                                     Page   18
---------------------------------- bank0.s -----------------------------------

df_tk_tok_expression : $daed          56045
       df_tk_try_asm : $db7a          56186
    df_tk_try_assign : $db7f          56191
   df_tk_try_command : $db73          56179
         df_tk_tsave : $e027          57383
         df_tk_until : $e027          57383
           df_tk_val : $dff5          57333
           df_tk_var : $d99a          55706
      df_tk_variable : $df12          57106
        df_tk_var_ck : $d9b0          55728
      df_tk_var_cont : $d9a0          55712
    df_tk_var_noarry : $d974          55668
         df_tk_vpeek : $dff5          57333
          df_tk_wait : $e027          57383
          df_tk_wend : $e022          57378
         df_tk_while : $e027          57383
      df_tk_ws_loop1 : $d8c0          55488
        df_tk_2parms : $e02d          57389
        df_tk_3parms : $e037          57399
        df_tk_4parms : $e03f          57407
          df_tmpptra : $00a2            162
          df_tmpptrb : $00a4            164
          df_tmpptrc : $00a6            166
          df_tmpptrd : $00a8            168
          df_tmpptre : $00aa            170
              df_tok : $0480           1152
          df_tokbuff : $0480           1152
        df_tokensyms : $dc56          56406
           df_tokoff : $007e            126
       df_trap_error : $f8b3          63667
  df_trap_go_monitor : $f8c8          63688
     df_trap_monitor : $f941          63809
      df_trap_normal : $f8cb          63691
           df_varcnt : $0072            114
      df_var_analyse : $d7b0          55216
df_var_analyse_chk_arry : $d7e3          55267
df_var_analyse_chk_dollar : $d7da          55258
df_var_analyse_chk_post : $d7da          55258
df_var_analyse_fatal_err : $d7ce          55246
   df_var_analyse_ok : $d825          55333
   df_var_check_type : $d710          55056
     df_var_countlen : $d79b          55195
df_var_countlen_alphanum : $d7aa          55210
df_var_countlen_loop : $d7ad          55213
 df_var_finalise_len : $d7f0          55280
         df_var_find : $d6d6          54998
   df_var_findcreate : $d7f9          55289
df_var_findcreate_copy : $d847          55367
df_var_findcreate_create : $d812          55314
df_var_findcreate_err : $d823          55331
df_var_findcreate_errp : $d822          55330
df_var_findcreate_found : $d80b          55307
  df_var_find_no_vnt : $d734          55092
    df_var_find_true : $d739          55097
df_var_initialise_var : $d832          55346
 df_var_insert_space : $d741          55105
    df_var_match_vnt : $d6e6          55014
 df_var_match_vnt_do : $d6f2          55026
df_var_match_vnt_sym : $d6f6          55030
    df_var_move_byte : $d763          55139
 df_var_move_byte_do : $d76f          55151
df_var_move_byte_fin : $d780          55168
AS65 Assembler for R6502 [1.42].                                     Page   19
---------------------------------- bank0.s -----------------------------------

     df_var_not_proc : $d7d0          55248
df_var_vnt_entry_end : $d721          55073
df_var_vnt_sym_nomatch : $d714          55060
     df_var_zero_vnt : $d83e          55358
           df_vntend : $006c            108
          df_vntstrt : $006a            106
           df_vvtend : $0070            112
          df_vvtstrt : $006e            110
               errno : $005e             94
 fd_cload_getname_pc : $c5cb          50635
 fd_csave_getname_pc : $c629          50729
     fd_getname_addr : $0400           1024
        file_vectors : $c552          50514
             f_back4 : $c58d          50573
         f_block_gap : $c576          50550
     f_block_gap_vec : $0008              8
             f_close : $c604          50692
    f_close_no_flush : $c60d          50701
         f_get_block : $c6f4          50932
   f_get_block_bytes : $c705          50949
          f_get_byte : $c6d7          50903
      f_get_byte_buf : $c6e4          50916
         f_get_fname : $c5ea          50666
   f_get_fname_start : $c5db          50651
        f_get_header : $c5e4          50660
              f_init : $c56a          50538
      f_init_default : $c5a1          50593
  f_init_default_rts : $c5ab          50603
          f_init_vec : $0000              0
      f_init_vectors : $c5b3          50611
          f_no_print : $c5a0          50592
        f_open_bread : $c5cb          50635
       f_open_bwrite : $c61f          50719
       f_open_common : $c5ac          50604
          f_open_msg : $c57c          50556
         f_open_read : $c5cb          50635
        f_open_write : $c625          50725
  f_open_write_start : $c629          50729
       f_print_block : $c6c6          50886
   f_print_block_num : $c6bc          50876
        f_print_byte : $c599          50585
         f_print_msg : $c592          50578
         f_put_block : $c699          50841
   f_put_block_bytes : $c6af          50863
          f_put_byte : $c66f          50799
     f_put_byte_done : $c692          50834
         f_put_delay : $c573          50547
     f_put_delay_vec : $0006              6
         f_read_byte : $c56d          50541
     f_read_byte_vec : $0002              2
           f_release : $c579          50553
       f_release_vec : $000a             10
          f_save_msg : $c585          50565
          f_skip_dir : $c601          50689
           f_skip_sd : $c5b1          50609
     f_storage_table : $000c             12
       f_storage_vec : $0611           1553
        f_write_byte : $c570          50544
    f_write_byte_vec : $0004              4
       f_write_fname : $c661          50785
      f_write_header : $c658          50776
               grc_d : $0043             67   *
AS65 Assembler for R6502 [1.42].                                     Page   20
---------------------------------- bank0.s -----------------------------------

               grc_r : $003f             63   *
               grc_x : $0040             64   *
              grc_x0 : $003d             61   *
               grc_y : $0042             66   *
              grc_y0 : $003e             62   *
              grl_dx : $0041             65   *
              grl_dy : $0042             66   *
               grl_p : $004b             75   *
            grl_sinx : $004a             74   *
            grl_siny : $004d             77   *
            grl_xyyx : $0043             67   *
              grl_x0 : $003d             61   *
              grl_x1 : $003f             63   *
              grl_y0 : $003e             62   *
              grl_y1 : $0040             64   *
             grl_2dx : $0044             68   *
            grl_2dxy : $0048             72   *
             grl_2dy : $0046             70   *
             gr_char : $0003              3
  gr_check_font_copy : $ce65          52837
gr_check_font_copy_done : $ce7c          52860
           gr_circle : $d256          53846
      gr_circle_done : $d293          53907
    gr_circle_d_lte0 : $d286          53894
      gr_circle_plot : $d263          53859
    gr_circle_points : $d294          53908
              gr_cls : $cf50          53072
          gr_cls_col : $cf70          53104
          gr_cls_row : $cf5c          53084
    gr_cls_skip_marg : $cf6c          53100
        gr_copy_byte : $ce3c          52796
         gr_copy_mem : $ce32          52786
         gr_cur_down : $d09b          53403
         gr_cur_left : $d07d          53373
          gr_cur_ptr : $000c             12
        gr_cur_right : $d06b          53355
  gr_cur_skip_at_bot : $d0a7          53415
 gr_cur_skip_at_left : $d08c          53388
   gr_cur_skip_at_tl : $d090          53392
           gr_cur_up : $d091          53393
            gr_cur_x : $000a             10
            gr_cur_y : $000b             11
              gr_del : $d0a8          53416
       gr_geom_fill1 : $0007              7
         gr_geom_tmp : $0015             21
        gr_geom_tmp2 : $0017             23
              gr_get : $cfb7          53175
       gr_getXY_base : $cf94          53140
          gr_get_key : $d0b0          53424
        gr_get_key_2 : $d0b4          53428
            gr_hchar : $d165          53605
   gr_hchar_copyline : $d1bd          53693
gr_hchar_copyline_eor : $d1d3          53715
gr_hchar_copyline_erase : $d1e3          53731
gr_hchar_copyline_nx : $d1f8          53752
    gr_hchar_getfont : $d198          53656
       gr_hchar_mask : $d190          53648
    gr_hchar_rot1bit : $d1a2          53666
gr_hchar_rot1bit_bcc : $d1ad          53677
 gr_hchar_rot1bit_nx : $d1b2          53682
            gr_hcode : $d14b          53579
       gr_hcode_loop : $d151          53585
AS65 Assembler for R6502 [1.42].                                     Page   21
---------------------------------- bank0.s -----------------------------------

          gr_hires_x : $0010             16
          gr_hires_y : $0011             17
         gr_hi_start : $0001              1
             gr_init : $ce4c          52812
        gr_init_font : $ce1c          52764
        gr_init_geom : $ce7d          52861
   gr_init_geom_done : $ce7c          52860
       gr_init_hires : $ced3          52947
gr_init_hires_tables : $cf0c          53004
  gr_init_screen_txt : $ceba          52922
     gr_init_tab_col : $cf38          53048
gr_init_tab_col_skip : $cf4a          53066
     gr_init_tab_row : $cf16          53014
              gr_ink : $0012             18
    gr_key_check_key : $d0c0          53440
      gr_key_got_key : $d0d7          53463
       gr_key_no_key : $d0e2          53474
    gr_key_skip_copy : $d0c8          53448
      gr_key_tidy_up : $d0d9          53465
             gr_line : $d30c          54028
        gr_line_done : $d3e6          54246
       gr_line_neg_p : $d3d6          54230
       gr_line_pixel : $d39f          54175
 gr_line_skip_dx_neg : $d32a          54058
 gr_line_skip_dy_neg : $d337          54071
   gr_line_skip_left : $d367          54119
gr_line_skip_xy_swap : $d357          54103
   gr_line_skip_y_up : $d36f          54127
     gr_line_yx_skip : $d3ab          54187
           gr_margin : $0014             20
             gr_mode : $0000              0
           gr_new_ln : $d053          53331
       gr_nl_skip_nl : $d068          53352
       gr_no_special : $d0f7          53495
      gr_offset_40hi : $d403          54275
      gr_offset_40lo : $d3e7          54247
            gr_paper : $0013             19
            gr_pitch : $000f             15
            gr_pixel : $d21f          53791
          gr_pixmode : $000e             14
             gr_plot : $cfa4          53156
            gr_point : $d225          53797
       gr_point_done : $d255          53845
        gr_point_eor : $d251          53841
      gr_point_setup : $d207          53767
  gr_point_skip_attr : $d247          53831
      gr_point_write : $d253          53843
        gr_printable : $d11b          53531
       gr_print_line : $d13a          53562
   gr_print_msg_done : $d14a          53578
   gr_print_msg_loop : $d140          53568
  gr_process_special : $d100          53504
              gr_put : $cfac          53164
         gr_put_byte : $d0e6          53478
     gr_put_byte_low : $d0f8          53496
           gr_screen : $0018             24
         gr_scrngeom : $0011             17
    gr_scrngeom_base : $ce8c          52876
   gr_scrngeom_hires : $cea1          52897
    gr_scrngeom_text : $ce92          52882
      gr_scroll_char : $d015          53269
    gr_scroll_cpy_ln : $d012          53266
AS65 Assembler for R6502 [1.42].                                     Page   22
---------------------------------- bank0.s -----------------------------------

  gr_scroll_erase_ln : $d049          53321
      gr_scroll_marg : $d045          53317
   gr_scroll_routine : $d05c          53340
        gr_scroll_up : $cff6          53238
          gr_set_cur : $cfbd          53181
     gr_set_cur_init : $cfbe          53182
     gr_set_cur_skip : $cfd6          53206
    gr_set_hires_cur : $d21a          53786
       gr_special_ch : $d121          53537
    gr_special_fn_hi : $d132          53554
    gr_special_fn_lo : $d12a          53546
     gr_special_loop : $d104          53508
         gr_spr_char : $d492          54418
         gr_spr_draw : $d471          54385
    gr_spr_draw_loop : $d473          54387
    gr_spr_draw_next : $d47f          54399
        gr_spr_erase : $d42d          54317
     gr_spr_erase_do : $d435          54325
   gr_spr_erase_loop : $d42f          54319
   gr_spr_erase_next : $d43b          54331
          gr_spr_hit : $d498          54424
         gr_spr_init : $d41f          54303
    gr_spr_init_loop : $d421          54305
   gr_spr_multi_loop : $d4b3          54451
    gr_spr_multi_pos : $d4af          54447
          gr_spr_new : $d43f          54335
     gr_spr_new_loop : $d441          54337
     gr_spr_new_next : $d46d          54381
          gr_spr_pos : $d4a2          54434
          gr_spr_put : $d483          54403
           gr_text_h : $0009              9
       gr_text_start : $0005              5
           gr_text_w : $0008              8
              HICHAR : $9800          38912   *
              HISCRN : $a000          40960   *
              HITEXT : $bf68          49000   *
          hex_to_bcd : $c354          50004
           hires_col : $9d90          40336   *
          hires_mask : $9e80          40576   *
        hires_row_hi : $9cc8          40136   *
       hires_row_low : $9c00          39936   *
                 IER : $000e             14   *
                 IFR : $000d             13   *
             IFR_CA1 : $0002              2   *
             IFR_CA2 : $0001              1   *
             IFR_CB1 : $0010             16   *
                IO_0 : $0300            768   *
       inc_kb_timers : $c156          49494
            infinity : $c07e          49278
                init : $c4b5          50357
            init_irq : $c0bd          49341
       init_keyboard : $c8ac          51372
            init_ram : $c4de          50398
       init_ram_fill : $c4eb          50411
       init_ram_skip : $c4f0          50416
          init_ram_1 : $c4e7          50407
            init_snd : $d5e9          54761
       init_snd_regs : $d5eb          54763
       init_tape_tab : $c527          50471
           init_via0 : $c4fd          50429
      init_via0_done : $c50f          50447
      init_via0_loop : $c4ff          50431
AS65 Assembler for R6502 [1.42].                                     Page   23
---------------------------------- bank0.s -----------------------------------

       init_via0_tab : $c510          50448
      init_via0_tape : $c4fa          50426
              init_2 : $c4ba          50362
             int_div : $d673          54899
       int_div_cycle : $d6a5          54949
      int_div_noflip : $d6d5          54997
        int_div_skip : $d6bf          54975
   int_div_skip_negA : $d68a          54922
   int_div_skip_negB : $d69d          54941
       int_fast_mult : $d61f          54815
 int_fast_mult_cycle : $d62f          54831
  int_fast_mult_next : $d640          54848
            int_mult : $d648          54856
      int_mult_cycle : $d658          54872
       int_mult_next : $d66b          54891
             int_str : $c3bd          50109
          int_to_str : $c39e          50078
       int_to_str_ch : $c389          50057
   int_to_str_ch_fin : $c39d          50077
      int_to_str_fin : $c3dc          50140
       int_to_str_nz : $c396          50070
 int_to_str_skip_neg : $c3b8          50104
         int_vdp_fin : $c14b          49483
     int_vdp_handler : $c130          49456
    io_active_device : $c407          50183
          io_address : $0300            768
            io_block : $0601           1537
           io_buf_sz : $c493          50323
            io_close : $c439          50233
          io_close_f : $0008              8
        io_copy_data : $c414          50196
          io_default : $0600           1536
           io_delete : $c43c          50236
            io_del_f : $000a             10
          io_devices : $c495          50325
          io_device0 : $c495          50325
          io_device1 : $c4a5          50341
          io_do_echo : $c45c          50268
             io_ext1 : $000c             12
             io_ext2 : $000e             14
         io_get_byte : $0000              0
           io_get_ch : $c42d          50221
    io_get_line_byte : $c449          50249
    io_get_line_done : $c476          50294
             io_init : $c3f9          50169
          io_null_op : $c491          50321
        io_open_ext1 : $c43f          50239
        io_open_ext2 : $c442          50242
           io_open_r : $0004              4
        io_open_read : $c433          50227
           io_open_w : $0006              6
       io_open_write : $c436          50230
       io_print_done : $c48f          50319
       io_print_line : $c47e          50302
  io_print_line_byte : $c485          50309
         io_put_byte : $0002              2
           io_put_ch : $c430          50224
        io_read_line : $c445          50245
      io_set_default : $c404          50180
        io_skip_echo : $c45f          50271
     io_skip_special : $c46a          50282
           io_struct : $0010             16
AS65 Assembler for R6502 [1.42].                                     Page   24
---------------------------------- bank0.s -----------------------------------

                 irq : $c0e1          49377
             irq_brk : $c103          49411
             irq_fin : $c0fd          49405
           KB_CAPSLK : $0001              1   *
         KB_DEBOUNCE : $0001              1   *
              KB_IJK : $0020             32   *
              KB_PRB : $00b0            176   *
          KB_REP_DEL : $0014             20   *
          KB_REP_TIM : $0003              3   *
            KB_SENSE : $0008              8   *
          kb_any_key : $c93e          51518
     kb_any_key_none : $c95e          51550
  kb_any_key_pressed : $c960          51552
      kb_any_key_row : $c945          51525
              kb_brk : $ca4f          51791
 kb_check_matrix_col : $c97a          51578
 kb_check_matrix_row : $c97a          51578
      kb_check_skip4 : $c99b          51611
             kb_code : $002b             43
         kb_col_mask : $caef          51951
              kb_deb : $002d             45
          kb_deb_tim : $002e             46
        kb_do_repeat : $ca3f          51775
          kb_get_key : $ca51          51793
          kb_get_try : $ca55          51797
          kb_ijk_map : $cafc          51964
        kb_in_repeat : $ca4b          51787
             kb_last : $002a             42
          kb_no_scan : $c9d0          51664
      kb_process_new : $c9de          51678
              kb_raw : $0029             41
         kb_rdel_tim : $0031             49
         kb_read_got : $c960          51552
     kb_read_noshift : $ca0b          51723
     kb_read_nothing : $c9a6          51622
         kb_read_raw : $c962          51554
     kb_read_raw_got : $c9aa          51626
              kb_rep : $002f             47
          kb_rep_tim : $0030             48
      kb_scan_decode : $c9d4          51668
     kb_scan_got_key : $ca66          51814
         kb_scan_key : $c9b9          51641
        kb_skip_ctrl : $ca27          51751
             kb_stat : $002c             44
            kb_stick : $c8e2          51426
        kb_stick_ijk : $c910          51472
       kb_stick_mask : $caf7          51959
        kb_stick_pos : $c8f7          51447
       kb_store_last : $ca47          51783
      kb_table_shift : $caaf          51887
        kb_table_std : $ca6f          51823
         kernel_init : $c4c3          50371
         kernel_test : $c4dd          50397
           lc_fildes : $0059             89   *
                main : $c077          49271
           mem_start : $071f           1823
        mod_sz_asm_e : $fffa          65530
        mod_sz_asm_s : $f995          63893
       mod_sz_bios_e : $d61f          54815
       mod_sz_bios_s : $c000          49152
        mod_sz_cia_e : $c552          50514
        mod_sz_cia_s : $c4fa          50426
AS65 Assembler for R6502 [1.42].                                     Page   25
---------------------------------- bank0.s -----------------------------------

      mod_sz_dflat_e : $f802          63490
      mod_sz_dflat_s : $d6d6          54998
       mod_sz_file_e : $c713          50963
       mod_sz_file_s : $c552          50514
      mod_sz_graph_e : $d4c3          54467
      mod_sz_graph_s : $cb1c          51996
         mod_sz_io_e : $c4b5          50357
         mod_sz_io_s : $c3f9          50169
     mod_sz_kernel_e : $c4fa          50426
     mod_sz_kernel_s : $c000          49152
   mod_sz_language_e : $fffa          65530
   mod_sz_language_s : $d61f          54815
       mod_sz_proc_e : $f722          63266
       mod_sz_proc_s : $f5ca          62922
   mod_sz_progedit_e : $e1b9          57785
   mod_sz_progedit_s : $e04a          57418
      mod_sz_rtasm_e : $fd8a          64906
      mod_sz_rtasm_s : $fa8f          64143
     mod_sz_rtsubs_e : $f5ca          62922
     mod_sz_rtsubs_s : $e775          59253
    mod_sz_runtime_e : $f722          63266
    mod_sz_runtime_s : $e1b9          57785
         mod_sz_sd_e : $c8ac          51372
         mod_sz_sd_s : $c7b1          51121
      mod_sz_sound_e : $d61f          54815
      mod_sz_sound_s : $d5d2          54738
     mod_sz_sprite_e : $d4c3          54467
     mod_sz_sprite_s : $d41f          54303
       mod_sz_tape_e : $c7b1          51121
       mod_sz_tape_s : $c713          50963
      mod_sz_tkasm_e : $fa8f          64143
      mod_sz_tkasm_s : $f995          63893
   mod_sz_tokenise_e : $e04a          57418
   mod_sz_tokenise_s : $d85e          55390
    mod_sz_toksubs_e : $e04a          57418
    mod_sz_toksubs_s : $df12          57106
        mod_sz_var_e : $d85e          55390
        mod_sz_var_s : $d6d6          54998
          msg_errmsg : $d5cf          54735
     msg_hello_world : $c081          49281
           msg_ready : $d5cd          54733
             NUM_ANY : $0000              0   *
             NUM_BIN : $0003              3   *
             NUM_DEC : $0001              1   *
             NUM_HEX : $0002              2   *
                 nmi : $c4f9          50425
        null_handler : $c0e0          49376
            null_irq : $c0df          49375
               num_a : $003d             61
               num_b : $0041             65
             num_buf : $004d             77
             num_tmp : $0049             73
               num_x : $0045             69
                 PCR : $000c             12   *
                 PRA : $0001              1   *
                PRAH : $000f             15   *
                 PRB : $0000              0   *
        print_a_to_d : $c3e8          50152
     print_a_to_d_ch : $c3ed          50157
    print_a_to_d_fin : $c3f8          50168
        SD_BIT_DELAY : $0002              2   *
           SND_ADBUS : $030f            783   *
AS65 Assembler for R6502 [1.42].                                     Page   26
---------------------------------- bank0.s -----------------------------------

        SND_DESELECT : $00dd            221   *
            SND_MODE : $030c            780   *
       SND_REG_CHAPH : $0001              1   *
       SND_REG_CHAPL : $0000              0   *
      SND_REG_CHAVOL : $0008              8   *
       SND_REG_CHBPH : $0003              3   *
       SND_REG_CHBPL : $0002              2   *
      SND_REG_CHBVOL : $000a             10   *
       SND_REG_CHCPH : $0005              5   *
       SND_REG_CHCPL : $0004              4   *
        SND_REG_CHNP : $0006              6   *
         SND_REG_CTL : $0007              7   *
      SND_REG_ENVCYC : $000d             13   *
       SND_REG_ENVPH : $000c             12   *
       SND_REG_ENVPL : $000b             11   *
         SND_REG_IOA : $000e             14   *
         SND_REG_IOB : $000f             15   *
         SND_SELREAD : $00df            223   *
      SND_SELSETADDR : $00ff            255   *
        SND_SELWRITE : $00fd            253   *
                  SR : $000a             10   *
               SWBRK : <macro>
             scratch : $061f           1567
        sd_block_gap : $c886          51334
     sd_commandfname : $c876          51318
  sd_commandfname_ch : $c87b          51323
            sd_delay : $c7e9          51177
       sd_delay_loop : $c7ed          51181
           sd_delete : $c887          51335
              sd_dir : $c892          51346
         sd_dir_char : $c89d          51357
             sd_init : $c86f          51311
           sd_init_a : $c873          51315
         sd_notready : $c7da          51162
        sd_put_delay : $c886          51334
            sd_ready : $c7d5          51157
        sd_ready_sec : $c7d4          51156
      sd_ready_skipx : $c7e0          51168
        sd_read_byte : $c842          51266
      sd_read_nibble : $c82d          51245
          sd_release : $c7b1          51121
           sd_select : $c7bd          51133
          sd_timeout : $c7cd          51149
      sd_timeout_brk : $c7d2          51154
       sd_write_byte : $c806          51206
     sd_write_nibble : $c7f3          51187
          skip_a_f_1 : $c194          49556
          skip_a_f_2 : $c1a3          49571
         skip_kb_deb : $c15c          49500
         skip_kb_rep : $c162          49506
          skip_x_f_1 : $c1af          49583
          skip_x_f_2 : $c1c4          49604
        snd_get_note : $d5d2          54738
    snd_get_note_oct : $d5dd          54749
        snd_init_tab : $d5f5          54773
       snd_music_tab : $d605          54789
       snd_note_done : $d5e6          54758
         snd_sel_reg : $c04e          49230
             snd_set : $c06e          49262
         snd_set_reg : $c05e          49246
        spr_baseadrh : $b4e0          46304   *
        spr_baseadrl : $b4c0          46272   *
AS65 Assembler for R6502 [1.42].                                     Page   27
---------------------------------- bank0.s -----------------------------------

            spr_bgnd : $b4a0          46240   *
             spr_chr : $b480          46208   *
            spr_curX : $b400          46080   *
            spr_curY : $b440          46144   *
            spr_newX : $b420          46112   *
            spr_newY : $b460          46176   *
          str_a_to_x : $c188          49544
   str_d_digits_done : $c2c4          49860
         str_d_error : $c270          49776
      str_d_find_end : $c27f          49791
     str_d_found_end : $c28c          49804
        str_d_powers : $c2e1          49889
 str_d_process_digit : $c29a          49818
      str_d_skip_neg : $c2db          49883
          str_x_to_a : $c1a4          49572
      str_x_to_a_err : $c1cf          49615
     str_x_to_a_errl : $c1ce          49614
           TAPE_RATE : $00d0            208   *
            TEXTCHAR : $b400          46080   *
            TEXTSCRN : $bb80          48000   *
         TIMER1_RATE : $4e20          20000   *
                T1CH : $0005              5   *
                T1CL : $0004              4   *
                T1LH : $0007              7   *
                T1LL : $0006              6   *
                T2CH : $0009              9   *
                T2CL : $0008              8   *
             tmp_ahi : $0033             51
             tmp_alo : $0032             50
           tmp_bank1 : $0000              0
           tmp_bank2 : $0001              1
             tmp_bhi : $0035             53
             tmp_blo : $0034             52
             tmp_chi : $0037             55
             tmp_clo : $0036             54
               tmp_d : $0038             56
            tp_block : $0055             85
        tp_block_gap : $c71f          50975
      tp_block_gap_1 : $c723          50979
              tp_buf : $0200            512
            tp_delay : $0059             89
             tp_flag : $0058             88
              tp_idx : $0057             87
             tp_init : $c713          50963
         tp_io_error : $c7af          51119
            tp_print : $005b             91
        tp_put_delay : $c717          50967
         tp_read_bit : $c796          51094
     tp_read_bit_cb1 : $c79a          51098
        tp_read_byte : $c782          51074
   tp_read_byte_bits : $c78e          51086
     tp_read_byte_st : $c782          51074
          tp_release : $c716          50966
        tp_write_bit : $c74d          51021
   tp_write_bit_chk1 : $c75e          51038
   tp_write_bit_chk2 : $c776          51062
     tp_write_bit_t1 : $c76d          51053
       tp_write_byte : $c72a          50986
   tp_write_byte_bit : $c736          50998
tp_write_byte_nodelay : $c74b          51019
     tt_csave_end_pc : $c61d          50717
   tt_getsync_end_pc : $c603          50691
AS65 Assembler for R6502 [1.42].                                     Page   28
---------------------------------- bank0.s -----------------------------------

  tt_getsync_loop_pc : $c79a          51098
       tt_getsync_pc : $c603          50691
   tt_putbyte_end_pc : $c74c          51020
       tt_putbyte_pc : $c72a          50986
  tt_readbyte_end_pc : $c795          51093
      tt_readbyte_pc : $c782          51074
tt_writeleader_end_pc : $c649          50761
   tt_writeleader_pc : $c649          50761
     twos_complement : $c345          49989
twos_complement_skip_X : $c353          50003
             UTF_ACK : $0001              1   *
             UTF_BEL : $0007              7   *
             UTF_BRK : $001a             26   *
              UTF_CR : $000d             13   *
             UTF_DEL : $007f            127   *
             UTF_ETX : $0003              3   *
              UTF_FF : $000c             12   *
         UTF_SPECIAL : $0020             32   *
       update_timers : $c14c          49484
          utilPrintA : $c173          49523
       utilPrintCRLF : $c16b          49515
        utilPrintSPC : $c163          49507
           VDP_FLASH : $0010             16   *
           vdp_blank : $0010             16
             vdp_cnt : $0008              8
          vdp_cnt_hi : $0009              9
         vdp_cnt_hi2 : $000a             10
          vdp_curcnt : $000c             12
          vdp_curoff : $000d             13
         vdp_curstat : $000e             14
          vdp_curtim : $000b             11
          vdp_curval : $000f             15
  vdp_fill_vram_loop : $cef4          52980
 vdp_fill_vram_noinc : $cefc          52988
            vdp_font : $cb1c          51996
          vdp_font_a : $cc24          52260
             vec_brk : $0004              4
             vec_irq : $0002              2
        vec_usercia0 : $0006              6
     via_strobe_init : $c536          50486
      via_strobe_off : $c542          50498
             zp_tmp1 : $00ac            172
             zp_tmp2 : $00ad            173
             zp_tmp3 : $00ae            174
             zp_tmp4 : $00af            175
             ztmp_24 : $003d             61
          _adcZPByte : <macro>
          _addZPWord : <macro>
                _bcc : <macro>
                _bcs : <macro>
           _code_end : $fffa          65530
         _code_start : $c000          49152
          _cpu_stack : $0100            256
          _cpyZPWord : <macro>
              _debug : <macro>
          _decZPWord : <macro>
         _decZPWordA : <macro>
      _end_zero_page : $00b0            176
          _incZPWord : <macro>
       _mod_sz_cmd_e : $d5d2          54738
       _mod_sz_cmd_s : $d4c3          54467
       _PushFalseJmp : <macro>
AS65 Assembler for R6502 [1.42].                                     Page   29
---------------------------------- bank0.s -----------------------------------

        _PushTrueJmp : <macro>
             _printA : <macro>
             _printC : <macro>
            _printCA : <macro>
          _printCRLF : <macro>
            _println : <macro>
        _println_low : <macro>
          _printmsgA : <macro>
            _pullAXY : <macro>
            _pushAXY : <macro>
         _rom_vec_0a : $c01e          49182
         _rom_vec_0b : $c021          49185
         _rom_vec_0c : $c024          49188
         _rom_vec_0d : $c027          49191
         _rom_vec_0e : $c02a          49194
         _rom_vec_0f : $c02d          49197
         _rom_vec_00 : $c000          49152
         _rom_vec_01 : $c003          49155
         _rom_vec_02 : $c006          49158
         _rom_vec_03 : $c009          49161
         _rom_vec_04 : $c00c          49164
         _rom_vec_05 : $c00f          49167
         _rom_vec_06 : $c012          49170
         _rom_vec_07 : $c015          49173
         _rom_vec_08 : $c018          49176
         _rom_vec_09 : $c01b          49179
         _rom_vec_10 : $c030          49200
         _rom_vec_11 : $c033          49203
         _rom_vec_12 : $c036          49206
         _rom_vec_13 : $c039          49209
         _rom_vec_14 : $c03c          49212
         _rom_vec_15 : $c03f          49215
         _rom_vec_16 : $c042          49218
         _rom_vec_17 : $c045          49221
         _rom_vec_18 : $c048          49224
         _rom_vec_19 : $c04b          49227
          _sbcZPByte : <macro>
            _sendcmd : <macro>
          _subZPWord : <macro>
            __6502__ : $0001              1

1748 labels used

16714 lines read, no errors in pass 1.
AS65 Assembler for R6502 [1.42].                                     Page   30
---------------------------------- bank0.s -----------------------------------

c000 =                       	org 0xc000
c000 :                       mod_sz_bios_s
                             	include "kernel/kernel.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  KERNEL.S
                             ;*	Lol, I thought this would become more sophisti
                             ;*	hence the name 'kernel'. But no, it just initi
                             ;*	memory, VIA, sound and screen, before passing 
                             ;*	to main.
                             ;*	References to banks etc. are from ported code 
                             ;*	did do more stuff, namely helping with ROM ban
                             ;*
                             ;************************************************
                             
                             ;* Include all definition and code files in the r
                             	include "inc/includes.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  INCLUDES.S
                             ;*  Main include file for key definitions and mac
                             ;*  Many of the settings here are exremely machin
                             ;*  Defines : IO block addresses, VIA port usage,
                             ;*  settings, useful macros, sound chip registers
                             ;*  and ACIA registers.
                             ;*	Of course the Oric doesn't have a VDP or an AC
                             ;*	so this file could be optimised.
                             ;*
                             ;************************************************
                             
                             ;* The IO block is at 0x0300
0300 =                       IO_0		= 0x0300
                             
0010 =                       VDP_FLASH	= 16				;* 32/50 second flash
                             
4e20 =                       TIMER1_RATE	= 1000000 / 50		;* 50 times per secon
00d0 =                       TAPE_RATE	= 0xd0				;* Assumed required FM freque
                             
                             ;* Standard definitions of 6522 registers
                             ;* As found in the datasheets
0000 =                       PRB			= 0x00
0001 =                       PRA			= 0x01
0002 =                       DDRB		= 0x02
0003 =                       DDRA		= 0x03
0004 =                       T1CL		= 0x04
0005 =                       T1CH		= 0x05
0006 =                       T1LL		= 0x06
0007 =                       T1LH		= 0x07
0008 =                       T2CL		= 0x08
0009 =                       T2CH		= 0x09
AS65 Assembler for R6502 [1.42].                                     Page   31
---------------------------------- bank0.s -----------------------------------

000a =                       SR			= 0x0a
000b =                       ACR			= 0x0b
000c =                       PCR			= 0x0c
000d =                       IFR			= 0x0d
000e =                       IER			= 0x0e
000f =                       PRAH		= 0x0f
                             
0001 =                       IFR_CA2		= 0x01
0002 =                       IFR_CA1		= 0x02
0010 =                       IFR_CB1		= 0x10
                             
                             ;* AY-3-8912 definitions
                             ;* The sound chip is accessed through VIA Port A
030f =                       SND_ADBUS	= IO_0+PRAH
030c =                       SND_MODE	= IO_0+PCR
                             
                             ; Values for the PCR register - always enable CB1
00df =                       SND_SELREAD			= 0b11011111		; CB2=low, CA2=high
00fd =                       SND_SELWRITE		= 0b11111101		; CB2=high, CA2=low
00ff =                       SND_SELSETADDR		= 0b11111111		; CB2=high, CA2=hig
00dd =                       SND_DESELECT		= 0b11011101		; CB2=low,CA2=low
                             
0000 =                       SND_REG_CHAPL	= 0x00
0001 =                       SND_REG_CHAPH	= 0x01
0002 =                       SND_REG_CHBPL	= 0x02
0003 =                       SND_REG_CHBPH	= 0x03
0004 =                       SND_REG_CHCPL	= 0x04
0005 =                       SND_REG_CHCPH	= 0x05
0006 =                       SND_REG_CHNP	= 0x06
0007 =                       SND_REG_CTL		= 0x07
0008 =                       SND_REG_CHAVOL	= 0x08
0009 =                       SND_REG_CHBVOL	= 0x09
000a =                       SND_REG_CHBVOL	= 0x0a
000b =                       SND_REG_ENVPL	= 0x0b
000c =                       SND_REG_ENVPH	= 0x0c
000d =                       SND_REG_ENVCYC	= 0x0d
                             
000e =                       SND_REG_IOA	= 0x0e
000f =                       SND_REG_IOB	= 0x0f
                             
                             
                             ;* Port B
00b0 =                       KB_PRB		= 0xb0			; Upper nibble of PRB default st
0008 =                       KB_SENSE	= 0x08			; Input - Bit 3 port A
0001 =                       KB_CAPSLK	= 0x01			; Id of Caps Lock
0020 =                       KB_IJK		= 0b00100000	; IJK joystick detect bit
                             
0003 =                       KB_REP_TIM	= 3 			; Number of VB periods for the 
0014 =                       KB_REP_DEL	= 20			; Number of VB periods before r
0001 =                       KB_DEBOUNCE	= 1				; Number of VB periods before 
                             
0003 =                       UTF_ETX		= 0x03			; Break character
0007 =                       UTF_BEL		= 0x07
0008 =                       CRSR_LEFT	= 0x08
0009 =                       CRSR_RIGHT	= 0x09
000a =                       CRSR_DOWN	= 0x0a
000b =                       CRSR_UP		= 0x0b
0014 =                       CTRL_CAPS	= 0x14			; CTRL-T to toggle caps
0001 =                       UTF_ACK		= 0x01			; Used for the CTRL-A copy in t
000c =                       UTF_FF		= 0x0c
000d =                       UTF_CR		= 0x0d
001a =                       UTF_BRK		= 0x1a			; Debug - drop in to monitor
AS65 Assembler for R6502 [1.42].                                     Page   32
---------------------------------- bank0.s -----------------------------------

007f =                       UTF_DEL		= 0x7f
0020 =                       UTF_SPECIAL = 0x20
                             
0000 =                       CMD_ERR_NOERROR			= 0x00
0001 =                       CMD_ERR_NOTFOUND		= 0x01
0002 =                       CMD_ERR_PARM			= 0x02
0003 =                       CMD_ERR_VAL				= 0x03
                             
                             ;* Number formats for conversion routines
0000 =                       NUM_ANY		= 0x00
0001 =                       NUM_DEC		= 0x01
0002 =                       NUM_HEX		= 0x02
0003 =                       NUM_BIN		= 0x03
                             
                             	
                             
                             ;* USEFUL MACROS HERE
                             
                             ;* Software break to throw errors
                             ;* use like this : SWBRK XX
                             ;* Where XX is the error code
                             SWBRK macro sig
                             	brk
                             	db sig
                             	endm
                             
                             _pushAXY macro
                             	pha
                             	sta tmp_d
                             	txa
                             	pha
                             	tya
                             	pha
                             	lda tmp_d
                             	endm
                             
                             _pullAXY macro
                             	pla
                             	tay
                             	pla
                             	tax
                             	pla
                             	endm
                             
                             _println macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	_pullAXY
                             	endm
                             
                             _println_low macro msg
                             	ldx #lo(msg)
                             	lda #hi(msg)
                             	jsr io_print_line
                             	endm
                             
                             _printmsgA macro msg
                             	_pushAXY
                             	ldx #lo(msg)
                             	lda #hi(msg)
AS65 Assembler for R6502 [1.42].                                     Page   33
---------------------------------- bank0.s -----------------------------------

                             	jsr io_print_line
                             	pla
                             	pha
                             	jsr str_a_to_x
                             	jsr _put_byte
                             	txa
                             	jsr _put_byte
                             	lda #UTF_CR
                             	jsr _put_byte
                             	_pullAXY
                             	endm
                             
                             _printA macro
                             	_pushAXY
                             	jsr str_a_to_x
                             	jsr io_put_ch
                             	txa
                             	jsr io_put_ch
                             	_pullAXY
                             	endm
                             
                             _printCRLF macro
                             	pha
                             	lda #UTF_CR
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _printC macro ch
                             	pha
                             	lda #ch
                             	jsr io_put_ch
                             	pla
                             	endm
                             
                             _printCA macro
                             	pha
                             	jsr _put_byte
                             	pla
                             	endm
                             
                             _sendcmd macro cmd
                             	_pushAXY
                             	ldx #lo(cmd)
                             	lda #hi(cmd)
                             	jsr sd_sendcmd
                             	_pullAXY
                             	endm
                             
                             _incZPWord macro wordp
                             	inc wordp
                             	db	0xd0, 0x02
                             	inc wordp+1
                             	endm
                             
                             _decZPWordA macro wordp
                             	lda wordp
                             	db	0xd0, 0x02
                             	dec wordp+1
                             	dec wordp
                             	endm
                             	
AS65 Assembler for R6502 [1.42].                                     Page   34
---------------------------------- bank0.s -----------------------------------

                             _decZPWord macro wordp
                             	pha
                             	sec
                             	lda wordp
                             	sbc #1
                             	sta wordp
                             	lda wordp+1
                             	sbc #0
                             	sta wordp+1
                             	pla
                             	endm
                             
                             _cpyZPWord macro worda,wordb
                             	lda worda
                             	sta wordb
                             	lda worda+1
                             	sta wordb+1
                             	endm
                             	
                             _addZPWord macro worda, wordb
                             	clc
                             	lda worda
                             	adc wordb
                             	sta worda
                             	lda worda+1
                             	adc wordb+1
                             	sta worda+1
                             	endm
                             
                             _subZPWord macro worda, wordb
                             	sec
                             	lda worda
                             	sbc wordb
                             	sta worda
                             	lda worda+1
                             	sbc wordb+1
                             	sta worda+1
                             	endm
                             	
                             _adcZPByte macro worda, byte
                             	clc
                             	lda worda
                             	adc byte
                             	sta worda
                             	db 0x90, 0x02		; bcc 2
                             	inc worda+1
                             	endm
                             
                             _sbcZPByte macro worda, byte
                             	sec
                             	lda worda
                             	sbc byte
                             	sta worda
                             	db 0xb0, 0x02		; bcs 2
                             	inc worda+1
                             	endm
                             
                             _bcc macro skip
                             	db 0x90, skip
                             	endm
                             
                             _bcs macro skip
AS65 Assembler for R6502 [1.42].                                     Page   35
---------------------------------- bank0.s -----------------------------------

                             	db 0xb0, skip
                             	endm
                             
                             _debug macro ch
                             	pha
                             	lda #ch
                             	sta 48000
                             	pla
                             	endm
                             	
                             
                             
                             	include "inc/graph.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  GRAPH.I
                             ;*  This is the definition file for graphics, spe
                             ;*  The graphics screen handling module.  It is j
                             ;*  structure definition - but this structure is 
                             ;*  record the important attributes of a text scr
                             ;*	This was needed in the previous code due to 32
                             ;*	byte width screens, but Oric only  has 40, so 
                             ;*	could be optimised a little.
                             ;*
                             ;************************************************
                             
                             ; Important screen addresses for the Oric ULA
bb80 =                       TEXTSCRN	=	0xbb80
b400 =                       TEXTCHAR	=	0xb400
a000 =                       HISCRN		=	0xa000
9800 =                       HICHAR		=	0x9800
bf68 =                       HITEXT		=	0xbf68
                             
0000 =                       	struct gr_screen
0000 =                       	db gr_mode					; Text or Hires mode
0001 =                       	dw gr_hi_start				; Address fo hires screen
0003 =                       	dw gr_char					; Start address of charset
0005 =                       	dw gr_text_start			; Start of text memory
0007 =                       	db gr_geom_fill1			; (Not used, maintained for a
0008 =                       	db gr_text_w				; Number of columns
0009 =                       	db gr_text_h				; Number of rows
000a =                       	db gr_cur_x					; Current X position of cursor
000b =                       	db gr_cur_y					; Current Y position of cursor
000c =                       	dw gr_cur_ptr				; VDP address of cursor
000e =                       	db gr_pixmode				; Pixel plot mode (0=Erase, 1=P
000f =                       	db gr_pitch					; Pixel pitch for char plotting
0010 =                       	db gr_hires_x				; X pos of hires cursor
0011 =                       	db gr_hires_y				; Y pos of hires cursor
0012 =                       	db gr_ink					; Ink colour
0013 =                       	db gr_paper					; Paper colour
0014 =                       	db gr_margin				; Left margin
0015 =                       	dw gr_geom_tmp				; One word of temp storage for
0017 =                       	db gr_geom_tmp2				; One byte of temp storage fo
                             	end struct
                             	
                             ; Sprite data stored in free 256 in font space
AS65 Assembler for R6502 [1.42].                                     Page   36
---------------------------------- bank0.s -----------------------------------

b400 =                       spr_curX	= TEXTCHAR			; Sprite current X pos
b420 =                       spr_newX	= TEXTCHAR+32		; Sprite new X pos
b440 =                       spr_curY	= TEXTCHAR+64		; Sprite current Y pos
b460 =                       spr_newY	= TEXTCHAR+96		; Sprite new Y pos
b480 =                       spr_chr		= TEXTCHAR+128		; Sprite character
b4a0 =                       spr_bgnd	= TEXTCHAR+160		; Background character u
b4c0 =                       spr_baseadrl= TEXTCHAR+192		; Y low address of sp
b4e0 =                       spr_baseadrh= TEXTCHAR+224		; Y high address of s
                             
                             ; Tables stored in alternate character set area
                             ; only used for high-resolution screen handling
9c00 =                       hires_row_low	=	HICHAR+0x400		; Low byte of row p
9cc8 =                       hires_row_hi	=	hires_row_low+200	; High byte of r
9d90 =                       hires_col		=	hires_row_hi+200	; Pixel to byte col
9e80 =                       hires_mask		=	hires_col+240		; Pixel column to pi
                             
                             
                             	include "io/io.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  IO.I
                             ;*  Definitions file for the IO module.  The key 
                             ;*  used by the IO system is defined here.
                             ;*	Some over-engineering here for future possibil
                             ;*
                             ;************************************************
                             
                             ;* General IO structure allows the system to swap
                             ;* different IO devices by using indirect calls t
                             ;* the appropriate routines.
0000 =                       	struct io_struct
0000 =                       	ds	io_get_byte,	2			;* Address of get byte
0002 =                       	ds	io_put_byte,	2			;* Address of put byte
0004 =                       	ds	io_open_r,		2			;* Address of open file for r
0006 =                       	ds	io_open_w,		2			;* Address of open file for w
0008 =                       	ds	io_close_f,		2			;* Address of close file
000a =                       	ds	io_del_f,		2			;* Address of delete file
000c =                       	ds	io_ext1,		2			;* Address of extended function
000e =                       	ds	io_ext2,		2			;* Address of extended function
                             	end struct
                             
                             ;* Structure storage device specific vectors
0000 =                       	struct f_storage_table
0000 =                       	ds	f_init_vec,			2
0002 =                       	ds	f_read_byte_vec,	2
0004 =                       	ds	f_write_byte_vec,	2
0006 =                       	ds	f_put_delay_vec,	2
0008 =                       	ds	f_block_gap_vec,	2
000a =                       	ds	f_release_vec,		2
                             	end struct
                             
                             	include "dflat/dflat.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
AS65 Assembler for R6502 [1.42].                                     Page   37
---------------------------------- bank0.s -----------------------------------

                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
071f =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
9800 =                       DF_MEMTOP	=	0x9800
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
AS65 Assembler for R6502 [1.42].                                     Page   38
---------------------------------- bank0.s -----------------------------------

                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_PTR	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0003 =                       DFST_INT	=	DFVVT_INT|DFVVT_BYT
0004 =                       DFST_STR	=	DFVVT_STR
00ff =                       DFST_PTR	=	0xff
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
AS65 Assembler for R6502 [1.42].                                     Page   39
---------------------------------- bank0.s -----------------------------------

0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             	include "kernel/zeropage.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ZEROPAGE.I
                             ;*  This module name is misleading it is not only
                             ;*  allocations, but also page 2, 3, 4, 5, 6, 7 a
                             ;*  memstart is a handy label that indicates the 
                             ;*  location that we can store dflat programs fro
                             ;*  Zero page is a valuable asset as the 6502 can
                             ;*  this page one cycle quicker than the rest of 
                             ;*  and infact some addressing modes can only use
                             ;*  Due to the value of zero page, a lot of syste
                             ;*  dflat variables are put here.  But we don't h
                             ;*  luxury for single use variables - so you will
                             ;*  see a lot of temporary sounding names which a
                             ;*  have multiple uses across the code base.
                             ;*
                             ;************************************************
                             
                             	; Zero page declarations
                             	bss
0000 =                       	org 0x0000
                             
0000 =                       tmp_bank1	ds	1		; Temp storage ONLY FOR USE BY BA
0001 =                       tmp_bank2	ds	1		; Temp storage ONLY FOR USE BY BA
                             
                             ; Interrupt routine addresses
0002 =                       vec_irq		 ds	2		; Master IRQ handler
0004 =                       vec_brk		 ds	2		; Master BRK handler
0006 =                       vec_usercia0 ds	2		; Where to jump for CIA0 inter
                             
                             ; VDP parameters
0008 =                       vdp_cnt		ds	1		; VDP interrupt counter
0009 =                       vdp_cnt_hi 	ds	1		; VDP counter high
000a =                       vdp_cnt_hi2	ds	1		; VDP counter high 2
000b =                       vdp_curtim	ds	1		; Cursor blink speed
000c =                       vdp_curcnt	ds	1		; Cursor blink countdown
000d =                       vdp_curoff	ds	1		; Cursor off (0 = On)
000e =                       vdp_curstat	ds	1		; Cursor status
000f =                       vdp_curval	ds	1		; Cursor value on screen
0010 =                       vdp_blank	ds	1		; Screen blank value normally 32
AS65 Assembler for R6502 [1.42].                                     Page   40
---------------------------------- bank0.s -----------------------------------

                             
                             ; Screen geometry
0011 =                       gr_scrngeom	ds	gr_screen
                             
                             ;Keyboard parameters
0029 =                       kb_raw  	ds	1		; Raw keyboard code
002a =                       kb_last		ds	1		; Code of last key
002b =                       kb_code 	ds	1		; Converted keyboard code
002c =                       kb_stat		ds	1		; Keyboard status for caps and shi
002d =                       kb_deb		ds	1		; Debounce timer
002e =                       kb_deb_tim  ds	1		; Default debounce delay
002f =                       kb_rep		ds	1		; Keyboard repeat speed timer
0030 =                       kb_rep_tim 	ds	1		; Default repeat speed
0031 =                       kb_rdel_tim	ds	1		; Default repeat delay (until s
                             
0032 =                       tmp_alo 	ds	1		; VDP addresses lo
0033 =                       tmp_ahi 	ds	1		; VDP addresses hi
0034 =                       tmp_blo 	ds	1		; Temp address lo
0035 =                       tmp_bhi		ds	1		; Temp address hi
0036 =                       tmp_clo		ds	1		; Temp address lo
0037 =                       tmp_chi		ds	1		; Temp address hi
0038 =                       tmp_d		ds	1		; Temp storage d
                             
                             ; Raw input/output parameters
0039 =                       buf_lo		ds	1		; Line buffer address low
003a =                       buf_hi		ds	1		; Line buffer address high
003b =                       buf_sz		ds	1		; Buffer size
003c =                       buf_ef		ds	1		; End file / line marker
                             
                             
                             ; ** Integer function storage **
003d =                       ztmp_24					; Start of 24 byte scratch area (all 
003d =                       num_a		ds	4		; 4 byte primary accumulator
0041 =                       num_b		ds	4		; 4 byte secondary accumulator
0045 =                       num_x		ds	4		; 4 byte x register
0049 =                       num_tmp		ds	4		; 4 byte temp space
004d =                       num_buf		ds	8		; 8 byte string buffer
                             
                             ; ** Tape function storage **
0055 =                       tp_block	ds	2		; Block number (int)
0057 =                       tp_idx		ds	1		; Current buffer index
0058 =                       tp_flag		ds	1		; zero = closed, 1=read, 2=write
0059 =                       tp_delay	ds	2		; Interblock delay
005b =                       tp_print	ds  1		; Interactive mode i.e. print? (M
                             ; For LOCI, tp_delay is used for storing FD
0059 =                       lc_fildes	=	tp_delay
                             
                             ;
                             ; **** INTERPRETER ZERO PAGE ****
                             ;
005c =                       dflat_zp_s
005c =                       dflat_zp_save_s			; ZP save dflat from here
005c =                       df_checkkey	ds	1		; Key check interval counter
005d =                       df_checkmsk	ds	1		; Mask for check key
005e =                       errno		ds	1		; General error condition status
005f =                       df_immed	ds	1		; Immediate mode (0 = not immediat
0060 =                       df_sp		ds	1		; Stack pointer after error to resto
0061 =                       df_pc		ds	2		; PC after error to return to
0063 =                       df_brkpc	ds	2		; PC pushed on the stack for BRK
0065 =                       df_brkval	ds	1		; Byte after BRK instruction
0066 =                       df_prgstrt	ds	2		; Start of program code
0068 =                       df_prgend	ds	2		; End of program code
AS65 Assembler for R6502 [1.42].                                     Page   41
---------------------------------- bank0.s -----------------------------------

006a =                       df_vntstrt	ds	2		; Variable name table start
006c =                       df_vntend	ds	2		; Variable name table end
006e =                       df_vvtstrt	ds	2		; Variable value table start
0070 =                       df_vvtend	ds	2		; Variable value table end
0072 =                       df_varcnt	ds	1		; Variable counter
0073 =                       df_starstrt	ds	2		; String and array table start
0075 =                       df_starend	ds	2		; String and array table end
0077 =                       df_rtstop	ds	1		; Runtime stack pointer
0078 =                       df_parmtop	ds	1		; Top of parameter stack (grows 
0079 =                       df_strbuffz	ds	1		; String expression buffer (*un
007a =                       df_stridxz	ds	1		; Top of string buffer (grows do
007b =                       df_sevalptr	ds	2		; Pointer to next free char in 
                             
007d =                       df_linoff	ds	1		; Offset in to line buffer
007e =                       df_tokoff	ds	1		; Offset in to tokenised buffer
007f =                       df_eolidx	ds	1		; End of line index (i.e length)
0080 =                       df_nxtstidx	ds	1		; Offset to the next statement 
0081 =                       df_curstidx	ds	1		; Offset to the start of curren
0082 =                       df_symtab	ds	2		; Pointer to next free symtab ent
0084 =                       df_symoff	ds	1		; Offset in to token table
0085 =                       df_syminiz	ds	2		; Start of symtab (*unused*)
0087 =                       df_currlin	ds	2		; Execution current line pointer
0089 =                       df_exeoff	ds	1		; Execution line buffer offset
008a =                       df_nextlin	ds	2		; Next line to execute
008c =                       df_procmode	ds	1		; Only used during tokenisation
008d =                       df_procargs	ds	1		; Only used during tokenisation
008e =                       df_procloc	ds	1		; Counts the number of local par
008f =                       df_procptr	ds	2		; Pointer to proc vvt slot
0091 =                       df_lineptr	ds	2		; Pointer to line during searche
0093 =                       df_lineidx	ds	1		; Pointer to line index during s
0094 =                       df_ifnest	ds	1		; Global nested if counter
0095 =                       df_currdat	ds	2		; Data current line pointer
0097 =                       df_datoff	ds	1		; Data line buffer offset
0098 =                       df_rnd		ds	2		; Random number seed
                             
009a =                       df_asmpc	ds	2		; Assembler program counter
009c =                       df_asmopt	ds	1		; Assembler current option
009d =                       df_asmadmd	ds	1		; Addressing mode
009e =                       df_asmopcde	ds	1		; Current opcode
009f =                       df_asmoprnd	ds	2		; Current operand
00a1 =                       df_asmlen	ds	1		; Instruction length
                             
00a2 =                       dflat_zp_save_e			; Save up to this place
                             
                             ; Temp space for dflat
00a2 =                       df_tmpptra	ds	2		; Temp pointer a
00a4 =                       df_tmpptrb	ds	2		; Temp pointer b
00a6 =                       df_tmpptrc	ds	2		; Temp pointer c
00a8 =                       df_tmpptrd	ds	2		; Temp pointer d
00aa =                       df_tmpptre	ds	2		; Temp pointer e
                             
00ac =                       dflat_zp_e
                             
00ac =                       zp_tmp1		ds	1		; General zero page temporary
00ad =                       zp_tmp2		ds	1		; General zero page temporary
00ae =                       zp_tmp3		ds	1		; General zero page temporary
00af =                       zp_tmp4		ds	1		; General zero page temporary
                             
                             ;***** END OF ZERO PAGE *****
00b0 =                       _end_zero_page
                             
                             ;***** Page 1 is CPU stack ****
AS65 Assembler for R6502 [1.42].                                     Page   42
---------------------------------- bank0.s -----------------------------------

0100 =                       	org 0x0100
0100 =                       _cpu_stack
0100 =                       			ds	256		; All of page 1
                             
                             ;***** Page 2 is tape buffer *****
0200 =                       	org 0x0200
0200 =                       tp_buf		ds	256		; Serial input / output line buff
                             
                             ;***** 3 is IO *****
0300 =                       	org 0x0300			; IO mapped to Page 3 on Oric
0300 =                       io_address	ds	256
                             
0400 =                       	org 0x0400			; Page 4 = dflat space
0400 =                       fd_getname_addr			; ** FOR ORICUTRON EMULATOR **
0400 =                       df_linbuff
0400 =                       df_raw		ds	128		; untokenised input line
0480 =                       df_tokbuff
0480 =                       df_tok		ds 	128		; tokenised output line
                             
0500 =                       	org 0x0500			; Page 5 = fixed space for interpre
0500 =                       df_rtstck				; operator stack grow up, runtime gr
0500 =                       df_rtspace	ds	256
                             
                             
                             ;***** NON-ZERO PAGE VARIABLES *****
                             
                             ; Active IO device settings
0600 =                       io_default	ds	1		; The default device number
0601 =                       io_block	ds	io_struct
                             
                             ; Jump tables for file devices
0611 =                       f_storage_vec		ds	f_storage_table
                             
                             ; Dflat top of memory+1 - initialised at boot tim
061d =                       df_memtop	ds	2
                             
                             ; Scratch area e.g. string and numeric expression
061f =                       scratch		ds	256
                             
                             ;***** THIS IS THE START OF FREE SPACE for DFLAT 
071f =                       mem_start
                             
                             
                             	include "dflat/dflat.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  DFLAT.I
                             ;*  This is the main definitions file for dflat. 
                             ;*  definitions are in here to access the data st
                             ;*  used by dflat.
                             ;*
                             ;************************************************
                             
                             ;* Start dflat program memory
071f =                       DF_PROGSTART=	mem_start
                             ;* This is the top of usable dflat memory plus 1
AS65 Assembler for R6502 [1.42].                                     Page   43
---------------------------------- bank0.s -----------------------------------

9800 =                       DF_MEMTOP	=	0x9800
                             
                             ;* Offset in to tokenised line of length and line
0000 =                       DFTK_LINLEN	=	0x00
0001 =                       DFTK_LINNUM	=	0x01
                             
                             ;* Flags for token, escape value for data types a
0080 =                       DFTK_TOKEN	=	0x80
0020 =                       DFTK_ESCVAL	=	0x20
0000 =                       DFTK_EOL	=	0x00
                             
                             ;* Numeric constants are encoded based on size an
                             ;* user representation.
                             ;* For example the decimal value 16 will be encod
                             ;* DFTK_INTDEC followed by the bytes 0 and 16 to 
                             ;* The same value in binary will be encoded as DF
                             ;* followed by the same 0 and 16 bytes.  This is 
                             ;* tokenised value to be displayed in original re
                             ;* So in the two examples, they will be shown as 
                             ;* '0x0010' respectively.
0000 =                       DFTK_CHR	=	0x00
0001 =                       DFTK_RESV1	=	0x01
0002 =                       DFTK_RESV2	=	0x02
0003 =                       DFTK_RESV3	=	0x03
0004 =                       DFTK_RESV4	=	0x04
0005 =                       DFTK_BYTDEC	=	0x05
0006 =                       DFTK_BYTHEX = 	0x06
0007 =                       DFTK_BYTBIN =	0x07
0008 =                       DFTK_RESV8	=	0x08
0009 =                       DFTK_INTDEC	=	0x09
000a =                       DFTK_INTHEX =	0x0a
000b =                       DFTK_INTBIN	=	0x0b
000c =                       DFTK_RESVC	=	0x0c
000d =                       DFTK_RESVD	=	0x0d
000e =                       DFTK_RESVE	=	0x0e
000f =                       DFTK_RESVF	=	0x0f
                             
                             ;* String constant, variable and procedure tokens
0010 =                       DFTK_STRLIT	=	0x10
0011 =                       DFTK_VAR	=	0x11
0012 =                       DFTK_PROC	=	0x12
001f =                       DFTK_STEND	=	0x1f
                             
                             ;* Qualifier for non-local parameters passed to a
0026 =                       DFTK_VARPARM=	'&'
                             
                             ;* Variable Value Table (VVT) definitions
                             ;* The VVT records the values of variables define
                             ;* the Variable Name Table (VNT).  When a variabl
                             ;* used, it is added to the VNT, and the position
                             ;* VNT is used as an index in to the VVT.
                             ;* Every VVT entry is 8 bytes - so the VNT index 
                             ;* shifted left 3 bits to get the VVT offset.
                             ;* The VNT grows from top of memory down, the VVT
                             ;* grows from start of VNT down.
                             
                             ;* Index in to each entry of the VVT
0000 =                       DFVVT_TYPE	=	0x00
0001 =                       DFVVT_LO	=	0x01
0002 =                       DFVVT_HI	=	0x02
0003 =                       DFVVT_DIM1	=	0x03
0004 =                       DFVVT_DIM2	=	0x04
AS65 Assembler for R6502 [1.42].                                     Page   44
---------------------------------- bank0.s -----------------------------------

0008 =                       DFVVT_SZ	=	0x08	;VVT is aligned to 8 byte blocks
                             
                             ;* The meaning of the DFVVT_TYPE entry
0001 =                       DFVVT_INT	=	0x01
0002 =                       DFVVT_BYT	=	0x02
0004 =                       DFVVT_STR	=	0x04
0008 =                       DFVVT_FLT	=	0x08
0040 =                       DFVVT_PROC	=	0x40
0080 =                       DFVVT_PTR	=	0x80
                             
                             ;* Flags indicating the meaning of a token
                             ;* A token has the top bit set (0x80), then the
                             ;* remaining bits indicate what it represents.
0001 =                       DFTK_KW		=	0x01
0002 =                       DFTK_FN		=	0x02
0004 =                       DFTK_STROP	=	0x04
0008 =                       DFTK_OP		=	0x08
0010 =                       DFTK_INT	=	0x10
0020 =                       DFTK_BYT	=	0x20
0040 =                       DFTK_STR	=	0x40
0080 =                       DFTK_FLT	=	0x80
0007 =                       DFTK_OPMSK	=	0x07
00f8 =                       DFTK_RTMSK	= 	0xf8
                             
                             ;* Defines what type of value is on the parameter
                             ;* All numerics are stored as INT, all STR
                             ;* are pointers to the actual string, thus
                             ;* all entries in the parmeter stack are 3 bytes
0003 =                       DFST_INT	=	DFVVT_INT|DFVVT_BYT
0004 =                       DFST_STR	=	DFVVT_STR
00ff =                       DFST_PTR	=	0xff
                             
                             ;* Token values of specific commands, used during
                             ;* command processing.
                             ;* ANY CHANGE TO THE ORDER OF KEYWORDS NEEDS TO R
0086 =                       DFRT_DEF	=	0x86
0087 =                       DFRT_ENDDEF	=	0x87
0088 =                       DFRT_RETURN	=	0x88
0089 =                       DFRT_ABORT	=	0x89
008c =                       DFRT_REPEAT	=	0x8c
008e =                       DFRT_FOR	=	0x8e
008f =                       DFRT_NEXT	=	0x8f
0090 =                       DFRT_WHILE	=	0x90
0091 =                       DFRT_WEND	=	0x91
0092 =                       DFRT_IF		=	0x92
0093 =                       DFRT_ELSE	=	0x93
0094 =                       DFRT_ENDIF	=	0x94
0095 =                       DFRT_ELSEIF	=	0x95
0096 =                       DFRT_DATA	=	0x96
0097 =                       DFRT_ASM	=	0x97
                             
                             _PushTrueJmp macro
                             	ldx #0xff
                             	txa
                             	jmp df_st_pushInt
                             	endm
                             
                             _PushFalseJmp macro
                             	ldx #0x00
                             	txa
                             	jmp df_st_pushInt
                             	endm
AS65 Assembler for R6502 [1.42].                                     Page   45
---------------------------------- bank0.s -----------------------------------

                             
                             	include "dflat/error.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  It issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_SYNTAX	=	1
0002 =                       DFERR_TYPEMISM	=	2
0003 =                       DFERR_DIM		=	3
0004 =                       DFERR_UNTIL		=	4
0005 =                       DFERR_NOPROC	=	5
0006 =                       DFERR_PROCPARM	=	6
0007 =                       DFERR_IMMEDIATE	=	7
0008 =                       DFERR_UNCLOSEDIF=	8
0009 =                       DFERR_NOIF		=	9
000a =                       DFERR_NEXTFOR	=	10
000b =                       DFERR_FNAME		=	11
000c =                       DFERR_STRLONG	=	12
000d =                       DFERR_BREAK		=	13
000e =                       DFERR_NODATA	=	14
000f =                       DFERR_WEND		=	15
0010 =                       DFERR_NOLINE	=	16
0011 =                       DFERR_RETURN	=	17
0012 =                       DFERR_ABORT		=	18
0013 =                       DFERR_QUANTITY	=	19
0014 =                       DFERR_NOORG		=	20
                             
                             
                             
                             
                             
                             ;****************************************
                             ;*	Set 6502 default vectors	*
                             ;****************************************
                             	data				; Set vectors
fffa =                       	org 0xfffa			; Vectors are at these addresses
fffa : f9c4                  	fcw nmi				; 0xfffa : NMI Vector
fffc : b5c4                  	fcw init			; 0xfffc : Reset Vector
fffe : d6c0                  	fcw call_irq_master	; 0xfffe : IRQ Vector
                             
                             	; ROM code
                             	code				;
c000 =                       	org 0xc000			; Start of ROM
AS65 Assembler for R6502 [1.42].                                     Page   46
---------------------------------- bank0.s -----------------------------------

                             
c000 :                       _code_start
                             	; Restore current bank always at address c001 * 
c000 :                       mod_sz_kernel_s
                             	; include OS ROM calls - must be from 0xc000
                             	include "kernel/osromvec.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2021
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  OSROMVEC.I
                             ;*	This include file sets up the OS ROM vectors w
                             ;*	be invoked by user programs to access ROM func
                             ;*	will be maintained across versions of dflat to
                             ;*	backward and forward compatibility.
                             ;*	Make sure these vectors are set up from 0xc000
                             ;*	what user programs will rely on!
                             ;*
                             ;************************************************
                             	
                             	; Common OS ROM calls - user programs should JMP
                             	; through these routines where possible to maint
                             	; compatibility with ROM changes as these calls 
                             	; always be in the same position
c000 : 4cbace           [ 3] _rom_vec_00	jmp	gr_init_screen_txt			; Go in to t
c003 : 4c50cf           [ 3] _rom_vec_01	jmp gr_cls						; Clear text screen
c006 : 4cbdcf           [ 3] _rom_vec_02	jmp	gr_set_cur					; Set text cursor 
c009 : 4cd3ce           [ 3] _rom_vec_03	jmp	gr_init_hires				; Go in to hires
c00c : 6c0106           [ 6] _rom_vec_04	jmp (io_block+io_get_byte)		; Get byt
c00f : 6c0306           [ 6] _rom_vec_05	jmp (io_block+io_put_byte)		; Put byt
c012 : 4c45c4           [ 3] _rom_vec_06 jmp io_read_line				; Read a line
c015 : 4c7ec4           [ 3] _rom_vec_07	jmp io_print_line				; Print a line
c018 : 4c6ec0           [ 3] _rom_vec_08	jmp snd_set						; Set sound register
c01b : 4ce2c8           [ 3] _rom_vec_09	jmp kb_stick					; Get joystick statu
c01e : 4ca4cf           [ 3] _rom_vec_0a	jmp gr_plot						; Plot a lores chara
c021 : 4c65d1           [ 3] _rom_vec_0b	jmp	gr_hchar					; Plot a hires chara
c024 : 4c07d2           [ 3] _rom_vec_0c	jmp gr_point_setup				; Get address, 
c027 : 4c25d2           [ 3] _rom_vec_0d	jmp gr_point					; Plot a hires pixel
c02a : 4ca6f5           [ 3] _rom_vec_0e	jmp df_rt_sprupd				; Refresh sprites
c02d : 4c94cf           [ 3] _rom_vec_0f	jmp	gr_getXY_base				; Get row addres
c030 : 4c1fd2           [ 3] _rom_vec_10	jmp gr_pixel					; Get a pixel value 
c033 : 4cb7cf           [ 3] _rom_vec_11 jmp gr_get						; Get screen at coord
c036 : 4c07c4           [ 3] _rom_vec_12 jmp io_active_device			; Set the acti
c039 : 6c0506           [ 6] _rom_vec_13	jmp (io_block+io_open_r)		; Open file
c03c : 6c0706           [ 6] _rom_vec_14	jmp (io_block+io_open_w)		; Open file
c03f : 6c0906           [ 6] _rom_vec_15	jmp (io_block+io_close_f)		; Close fi
c042 : 6c0b06           [ 6] _rom_vec_16	jmp (io_block+io_del_f)			; Delete fi
c045 : 6c0d06           [ 6] _rom_vec_17	jmp (io_block+io_ext1)			; Extended o
c048 : 6c0f06           [ 6] _rom_vec_18	jmp (io_block+io_ext2)			; Extended o
c04b : 4cd2d5           [ 3] _rom_vec_19 jmp snd_get_note				; Get for an octa
                             
                             
                             ;* Include all core code in the right order
                             	include "kernel/snd-low.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
AS65 Assembler for R6502 [1.42].                                     Page   47
---------------------------------- bank0.s -----------------------------------

                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  SND-LOW.S
                             ;*	Routines to access the AY-3-8912, which is don
                             ;*	lines of the VIA - CB2 and CA2 for chip select
                             ;*	Port A for data interface. This makes accessin
                             ;*	8912 a bit slow..
                             ;*
                             ;* 	CB2		CA2		Function		CB2=BDIR, CA2=BC1
                             ;*	0		0		Not selected
                             ;*	0		1		Read register in to Port A
                             ;*	1		0		Write register from Port A
                             ;*	1		1		Select register # from Port A
                             ;************************************************
                             
                             ;****************************************
                             ;* snd_sel_reg
                             ;* Select AY register from A
                             ;* Input : A = Value
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c04e :                       snd_sel_reg
c04e : 48               [ 3] 	pha
c04f : 8d0f03           [ 4] 	sta SND_ADBUS			; Put reg # on Port A (sound bus
                             
c052 : a9ff             [ 2] 	lda #SND_SELSETADDR		; Get ready to select the r
c054 : 8d0c03           [ 4] 	sta SND_MODE			; Latch the reg # on Port A
                             
c057 : a9dd             [ 2] 	lda #SND_DESELECT		; Deselect AY
c059 : 8d0c03           [ 4] 	sta SND_MODE
                             
c05c : 68               [ 4] 	pla
c05d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* snd_set_reg
                             ;* Set previosuly selected AY register
                             ;* Input : A = Value to set
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
c05e :                       snd_set_reg
c05e : 48               [ 3] 	pha
                             
c05f : 8d0f03           [ 4] 	sta SND_ADBUS			; Put reg value on Port A (sound
c062 : a9fd             [ 2] 	lda #SND_SELWRITE		; Select mode for writing dat
c064 : 8d0c03           [ 4] 	sta SND_MODE			; Latch reg value on Port A	
c067 : a9dd             [ 2] 	lda #SND_DESELECT		; Deselect AY
c069 : 8d0c03           [ 4] 	sta SND_MODE
                             
c06c : 68               [ 4] 	pla
c06d : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* snd_set
                             ;* Set reg X to value A
                             ;* Input : X=Reg, A = Value to set
                             ;* Output : None
                             ;* Regs affected : None
AS65 Assembler for R6502 [1.42].                                     Page   48
---------------------------------- bank0.s -----------------------------------

                             ;****************************************
c06e :                       snd_set
c06e : 48               [ 3] 	pha
c06f : 8a               [ 2] 	txa
c070 : 204ec0           [ 6] 	jsr snd_sel_reg
c073 : 68               [ 4] 	pla
c074 : 4c5ec0           [ 3] 	jmp snd_set_reg
                             
                             
                             ;****************************************
                             ;* snd_get
                             ;* Get AY register X value
                             ;* Input : X = Reg no
                             ;* Output : A = Value
                             ;* Regs affected : None
                             ;****************************************
                             ;snd_get
                             ;
                             ;	lda #0xff				; Set Port A to output
                             ;	sta IO_0+DDRA
                             ;
                             ;	stx SND_ADBUS			; Put X on the sound bus (X = r
                             ;
                             ;	lda #SND_SELSETADDR		; Get ready to select the 
                             ;	sta SND_MODE			; Latch the reg # on Port A
                             ;
                             ;	lda #SND_DESELECT		; Deselect AY
                             ;	sta SND_MODE
                             ;
                             ;	lda #0x00				; Set Port A to input
                             ;	sta IO_0+DDRA
                             ;
                             ;	lda #SND_SELREAD		; Select mode for reading dat
                             ;	sta SND_MODE			; Set read mode on AY
                             ;
                             ;	lda SND_ADBUS			; Get value in to Y from Port A
                             ;	pha						; Save it to stack
                             ;	
                             ;	lda #SND_DESELECT		; Deselect AY
                             ;	sta SND_MODE
                             ;
                             ;	lda #0xff				; Set Port A back to output
                             ;	sta IO_0+DDRA
                             ;
                             ;	pla						; Get the value off stack
                             ;	
                             ;	rts
                             
                             
                             	include "kernel/main.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  MAIN.S
                             ;*  This is where the main user program is execut
                             ;*  the 'kernel' once the system is initialised a
                             ;*  Today, main does very little - first shows th
AS65 Assembler for R6502 [1.42].                                     Page   49
---------------------------------- bank0.s -----------------------------------

                             ;*  boot up message, and then passes control to d
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c077 :                       main
c077 : a281             [ 2] 	ldx #lo(msg_hello_world)
c079 : a9c0             [ 2] 	lda #hi(msg_hello_world)
c07b : 207ec4           [ 6] 	jsr io_print_line
                             
c07e :                       infinity
                             
c07e : 4c12e1           [ 3] 	jmp df_pg_dflat
                             
c081 :                       msg_hello_world
                             	;* build.s is generate by the assemble.bat file
                             	;* all it does is echo an assembler line to
                             	;* including the build date in the message.
                             	include "kernel/build.s"
c081 : 4f726963206466..       db "Oric dflat\r" 
c08c : 42792040363530..       db "By @6502Nerd\r" 
                              if DFLATLOCI
                              db "Build 0.40 [IJK-LOCI]\r" 
                              else
c099 : 4275696c642030..       db "Build 0.40 [IJK-TPSD]\r" 
                              endif
c0af : 28632920323032..       db "(c) 2024-25\r\r",0 
                             
                             
                             	include "kernel/irq.s"
                             	
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  IRQ.S
                             ;*	This is the IRQ handler
                             ;*	There is only one regular interrupt source whi
                             ;*	T1 timeout on a 50Hz cycle, whose main job is 
                             ;*	flash the cursor and decrement some timers.
                             ;*	But there are handlers for BRK, user and VIA s
                             ;*	By default the user and VIA do nothing, but ca
                             ;*	redirected to user routines.
                             ;*
                             ;************************************************
                             
                             ;* Obviously this can only be done with
                             ;* interrupts disabled!
c0bd :                       init_irq
                             	; Core IRQ handler
c0bd : a9e1             [ 2] 	lda #lo(irq)
c0bf : 8502             [ 3] 	sta vec_irq
c0c1 : a9c0             [ 2] 	lda #hi(irq)
c0c3 : 8503             [ 3] 	sta vec_irq+1
                             	
                             	; Core BRK handler
AS65 Assembler for R6502 [1.42].                                     Page   50
---------------------------------- bank0.s -----------------------------------

c0c5 : a903             [ 2] 	lda #lo(irq_brk)
c0c7 : 8504             [ 3] 	sta vec_brk
c0c9 : a9c1             [ 2] 	lda #hi(irq_brk)
c0cb : 8505             [ 3] 	sta vec_brk+1
                             
                             	; User handlers VIA0 interrupts
c0cd : a9e0             [ 2] 	lda #lo(null_handler)
c0cf : 8506             [ 3] 	sta vec_usercia0
c0d1 : a9c0             [ 2] 	lda #hi(null_handler)
c0d3 : 8507             [ 3] 	sta vec_usercia0+1
                             
c0d5 : 60               [ 6] 	rts
                             
                             
                             ;* Calls the master IRQ handler - from the ROM
c0d6 :                       call_irq_master
c0d6 : 6c0200           [ 6] 	jmp (vec_irq)
                             	
                             ;* Calls the BRK handler
c0d9 :                       call_irq_brk
c0d9 : 6c0400           [ 6] 	jmp (vec_brk)
                             
                             ;* Call the user CIA0 handler
c0dc :                       call_irq_usercia0
c0dc : 6c0600           [ 6] 	jmp (vec_usercia0)
                             
                             ;* null interrupt
c0df :                       null_irq
c0df : 40               [ 6] 	rti
                             
                             ;* null handler
c0e0 :                       null_handler
c0e0 : 60               [ 6] 	rts
                             	
                             
                             ;* Master IRQ handler
c0e1 :                       irq
                             	; Don't use _pushAXY as it uses a temp location!
c0e1 : 48               [ 3] 	pha
c0e2 : 8a               [ 2] 	txa
c0e3 : 48               [ 3] 	pha
c0e4 : 98               [ 2] 	tya
c0e5 : 48               [ 3] 	pha
                             
c0e6 : d8               [ 2] 	cld						; Just in case!
c0e7 : 18               [ 2] 	clc						; Standard behaviour
                             
                             	; Check if IRQ or BRK
                             	; load P from stack in to A
c0e8 : ba               [ 2] 	tsx
c0e9 : bd0401           [ 4] 	lda 0x104,x
                             	; BRK bit set?
c0ec : 2910             [ 2] 	and #0x10
c0ee : d0e9             [ 3] 	bne call_irq_brk
                             	
                             	;* Primary interrupt is timer 1
c0f0 : ad0d03           [ 4] 	lda IO_0 + IFR
c0f3 : 2940             [ 2] 	and #0x40				; Bit 6 = Timer 1 interrupt
c0f5 : f006             [ 3] 	beq irq_fin				; If nothing then end
                             
                             	; Service the timer 1 interrupt
c0f7 : 8d0d03           [ 4] 	sta IO_0 + IFR			; Clear the interrupt
AS65 Assembler for R6502 [1.42].                                     Page   51
---------------------------------- bank0.s -----------------------------------

c0fa : 2030c1           [ 6] 	jsr int_vdp_handler
                             
c0fd :                       irq_fin
                             	_pullAXY
                             
c102 : 40               [ 6] 	rti
                             	
                             ;* Handle BRK
c103 :                       irq_brk
                             	; Handle BRK
                             	; Get PCL,H minus 2 gives the BRK instruction ad
c103 : 38               [ 2] 	sec
c104 : bd0501           [ 4] 	lda 0x0105,x
c107 : e902             [ 2] 	sbc #2
c109 : 8563             [ 3] 	sta df_brkpc
c10b : bd0601           [ 4] 	lda 0x0106,x
c10e : e900             [ 2] 	sbc #0
c110 : 8564             [ 3] 	sta df_brkpc+1
                             	; Get the byte pointed to by old PC
                             	; which is 1 on from the BRK
c112 : a001             [ 2] 	ldy #1
c114 : b163             [ 5] 	lda (df_brkpc),y
c116 : 8565             [ 3] 	sta df_brkval
c118 : 855e             [ 3] 	sta errno
                             	; now update the return address
c11a : a561             [ 3] 	lda df_pc
c11c : 9d0501           [ 5] 	sta 0x105,x
c11f : a562             [ 3] 	lda df_pc+1
c121 : 9d0601           [ 5] 	sta 0x106,x
                             	
                             	_pullAXY
                             
                             	; Save the registers in temp area
c129 : 853d             [ 3] 	sta num_a
c12b : 863e             [ 3] 	stx num_a+1
c12d : 843f             [ 3] 	sty num_a+2
                             	; when RTI occurs:
                             	;  will return to error handler
                             	;  df_brkval will contain signature
c12f : 40               [ 6] 	rti
                             	
                             	
                             ;****************************************
                             ;* int_vdp_handler
                             ;* VDP interrupt handler
                             ;****************************************
c130 :                       int_vdp_handler
c130 : 204cc1           [ 6] 	jsr update_timers	; If it is then update system 
c133 : a50d             [ 3] 	lda vdp_curoff		; Is cursor enabled?
c135 : d014             [ 3] 	bne int_vdp_fin		; Skip if disabled
                             
c137 : c60c             [ 5] 	dec vdp_curcnt		; Decrement countdown
c139 : d010             [ 3] 	bne int_vdp_fin		; If not expired, do nothing
c13b : a50b             [ 3] 	lda vdp_curtim		; Reset cursor countdown
c13d : 850c             [ 3] 	sta vdp_curcnt
c13f : a50e             [ 3] 	lda vdp_curstat		; Get the flash status
c141 : 4980             [ 2] 	eor #0x80			; Invert top bit
c143 : 850e             [ 3] 	sta vdp_curstat
c145 : 450f             [ 3] 	eor vdp_curval		; EOR with whats under cursor
                             	; Use cursor address, write to screen
                             	; ptr is base, offset with X coord in Y register
c147 : a41b             [ 3] 	ldy gr_scrngeom+gr_cur_x
AS65 Assembler for R6502 [1.42].                                     Page   52
---------------------------------- bank0.s -----------------------------------

c149 : 911d             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
                             
c14b :                       int_vdp_fin	
c14b : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* update_timers
                             ;* Update 24 bit timer and debounce counters
                             ;****************************************
c14c :                       update_timers
c14c : e608             [ 5] 	inc vdp_cnt
c14e : d006             [ 3] 	bne inc_kb_timers
c150 : e609             [ 5] 	inc vdp_cnt_hi
c152 : d002             [ 3] 	bne inc_kb_timers
c154 : e60a             [ 5] 	inc vdp_cnt_hi2
c156 :                       inc_kb_timers
c156 : a62d             [ 3] 	ldx kb_deb			; Is debounce 0?
c158 : f002             [ 3] 	beq skip_kb_deb
c15a : c62d             [ 5] 	dec kb_deb
c15c :                       skip_kb_deb
c15c : a62f             [ 3] 	ldx kb_rep			; Is repeat timer 0?
c15e : f002             [ 3] 	beq skip_kb_rep
c160 : c62f             [ 5] 	dec kb_rep
c162 :                       skip_kb_rep
c162 : 60               [ 6] 	rts
                             	
                             
                             	include "utils/utils.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  UTILS.S
                             ;*  This module implements various utility functi
                             ;*  converting from ASCII to binary form for numb
                             ;*  vice-versa to allow humans to actually be abl
                             ;*  and read numbers in their prefered form!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c163 :                       utilPrintSPC
c163 : 48               [ 3] 	pha
c164 : a920             [ 2] 	lda #' '
c166 : 2030c4           [ 6] 	jsr io_put_ch
c169 : 68               [ 4] 	pla
c16a : 60               [ 6] 	rts
                             
c16b :                       utilPrintCRLF
c16b : 48               [ 3] 	pha
c16c : a90d             [ 2] 	lda #UTF_CR
c16e : 2030c4           [ 6] 	jsr io_put_ch
c171 : 68               [ 4] 	pla
c172 : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page   53
---------------------------------- bank0.s -----------------------------------

c173 :                       utilPrintA
c173 : 8538             [ 3] 	sta tmp_d
c175 : 48               [ 3] 	pha
c176 : 8a               [ 2] 	txa
c177 : 48               [ 3] 	pha
c178 : a538             [ 3] 	lda tmp_d
c17a : 2088c1           [ 6] 	jsr str_a_to_x
c17d : 2030c4           [ 6] 	jsr io_put_ch
c180 : 8a               [ 2] 	txa
c181 : 2030c4           [ 6] 	jsr io_put_ch
c184 : 68               [ 4] 	pla
c185 : aa               [ 2] 	tax
c186 : 68               [ 4] 	pla
c187 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* str_a_to_x
                             ;* Convert accumulator to hex string
                             ;* Input : A = Byte to convert
                             ;* Output : A = High Char, X = Low Char
                             ;* Regs affected : P
                             ;****************************************
c188 :                       str_a_to_x
c188 : 48               [ 3] 	pha					; Save the byte using later on
c189 : 290f             [ 2] 	and #0x0f			; Mask low nibble
c18b : 18               [ 2] 	clc
c18c : 6930             [ 2] 	adc #'0'			; Convert to UTF
c18e : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c190 : 9002             [ 3] 	bcc skip_a_f_1		; skip a-f adjustment
c192 : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c194 :                       skip_a_f_1
c194 : aa               [ 2] 	tax					; Low char is in X
c195 : 68               [ 4] 	pla					; Get byte back
c196 : 4a               [ 2] 	lsr a				; Make high nibble low
c197 : 4a               [ 2] 	lsr a
c198 : 4a               [ 2] 	lsr a
c199 : 4a               [ 2] 	lsr a
c19a : 18               [ 2] 	clc
c19b : 6930             [ 2] 	adc #'0'			; Convert to UTF
c19d : c93a             [ 2] 	cmp #('9'+1)		; If A greater than '9' then
c19f : 9002             [ 3] 	bcc skip_a_f_2		; skip a-f adjustment
c1a1 : 6926             [ 2] 	adc #0x26			; Add 27 (6+C) to get in to A-F rang
c1a3 :                       skip_a_f_2
c1a3 : 60               [ 6] 	rts					; A high nibble, C=0
                             
                             ;****************************************
                             ;* str_x_to_a
                             ;* Convert hex string to accumulator
                             ;* Input : A = High Char, X = Low Char
                             ;* Output : A = Value
                             ;* Regs affected : P
                             ;****************************************
c1a4 :                       str_x_to_a
c1a4 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c1a6 : 38               [ 2] 	sec					; Process high char in A
c1a7 : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c1a9 : c90a             [ 2] 	cmp #10				; If A < 10 then
c1ab : 9002             [ 3] 	bcc skip_x_f_1		; skip a-f adjustment
c1ad : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c1af :                       skip_x_f_1
c1af : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
AS65 Assembler for R6502 [1.42].                                     Page   54
---------------------------------- bank0.s -----------------------------------

c1b1 : b01c             [ 3] 	bcs	str_x_to_a_err	; Error if not
                             
c1b3 : 0a               [ 2] 	asl a				; This is the high nibble
c1b4 : 0a               [ 2] 	asl a
c1b5 : 0a               [ 2] 	asl a
c1b6 : 0a               [ 2] 	asl a
c1b7 : 48               [ 3] 	pha					; Save the high nibble
c1b8 : 8a               [ 2] 	txa					; Now process the low char in X
c1b9 : 0920             [ 2] 	ora #0x20			; Make alpha in to lower case
c1bb : 38               [ 2] 	sec
c1bc : e930             [ 2] 	sbc #'0'			; Convert to hex nibble
c1be : c90a             [ 2] 	cmp #10				; If A < 10 then
c1c0 : 9002             [ 3] 	bcc skip_x_f_2		; skip a-f adjustment
c1c2 : e927             [ 2] 	sbc #0x27			; Sub 7 to get in to A-F range
c1c4 :                       skip_x_f_2
c1c4 : c910             [ 2] 	cmp #0x10			; Nibble should be <= 0x0f
c1c6 : b006             [ 3] 	bcs	str_x_to_a_errl	; Error if not
                             
c1c8 : 853d             [ 3] 	sta num_a			; Store low nibble in temp
c1ca : 68               [ 4] 	pla					; Get high nibble
c1cb : 053d             [ 3] 	ora num_a			; OR with low nibble
                             
c1cd : 60               [ 6] 	rts					; A contains value, C=0
                             
c1ce :                       str_x_to_a_errl
c1ce : 68               [ 4] 	pla
c1cf :                       str_x_to_a_err
                             	SWBRK CMD_ERR_VAL
                             
                             
                             ;****************************************
                             ;* con_n_to_a
                             ;* Convert numeric string to accumulator (unsigne
                             ;* Input : Pointer to string (X=L, A=H), Y = Sour
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* A = Source type detected
                             ;* Regs affected : CS = Error
                             ;****************************************
c1d1 :                       con_n_to_a
c1d1 : 8649             [ 3] 	stx num_tmp
c1d3 : 854a             [ 3] 	sta num_tmp+1
c1d5 : a900             [ 2] 	lda #0
c1d7 : 853d             [ 3] 	sta num_a
c1d9 : 853e             [ 3] 	sta num_a+1
c1db : c000             [ 2] 	cpy #NUM_ANY
c1dd : f014             [ 3] 	beq con_n_to_a_detect
c1df : 88               [ 2] 	dey
c1e0 : d003             [ 3] 	bne con_n_not_dec
c1e2 :                       con_dec_jmp
c1e2 : 4c76c2           [ 3] 	jmp con_dec_to_a_int
c1e5 :                       con_n_not_dec
c1e5 : 88               [ 2] 	dey
c1e6 : d003             [ 3] 	bne con_n_not_hex
c1e8 :                       con_hex_jmp
c1e8 : 4c0dc2           [ 3] 	jmp con_hex_to_a_int
c1eb :                       con_n_not_hex
c1eb : 88               [ 2] 	dey
c1ec : d003             [ 3] 	bne con_n_err
c1ee :                       con_bin_jmp
c1ee : 4c4cc2           [ 3] 	jmp con_bin_to_a_int
c1f1 :                       con_n_err
c1f1 : 38               [ 2] 	sec
AS65 Assembler for R6502 [1.42].                                     Page   55
---------------------------------- bank0.s -----------------------------------

c1f2 : 60               [ 6] 	rts
c1f3 :                       con_n_to_a_detect		; Y is zero on entry
c1f3 : b149             [ 5] 	lda (num_tmp),y
c1f5 : c930             [ 2] 	cmp #'0'
c1f7 : d0e9             [ 3] 	bne con_dec_jmp
c1f9 : a001             [ 2] 	ldy #1
c1fb : b149             [ 5] 	lda (num_tmp),y
c1fd : 0920             [ 2] 	ora #0x20
c1ff : c978             [ 2] 	cmp #'x'
c201 : f0e5             [ 4] 	beq con_hex_jmp
c203 : c962             [ 2] 	cmp #'b'
c205 : f0e7             [ 4] 	beq con_bin_jmp
c207 : d0d9             [ 4] 	bne con_dec_jmp		; Always branches
                             
                             ;****************************************
                             ;* con_hex_to_a
                             ;* Convert hex string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c209 :                       con_hex_to_a
c209 : 8649             [ 3] 	stx num_tmp
c20b : 854a             [ 3] 	sta num_tmp+1
c20d :                       con_hex_to_a_int
c20d : a205             [ 2] 	ldx #5			; > 4 digits will cause error
c20f : a002             [ 2] 	ldy #2			; start at first digit
c211 :                       con_hex_digit
c211 : b149             [ 5] 	lda (num_tmp),y
c213 : 0920             [ 2] 	ora #0x20					; Make alpha in to lower case
c215 : 38               [ 2] 	sec							; Process high char in A
c216 : e930             [ 2] 	sbc #'0'					; Convert to hex nibble
c218 : c90a             [ 2] 	cmp #10						; If A < 10 then
c21a : 9002             [ 3] 	bcc con_hex_skip_x_f_1		; skip a-f adjustment
c21c : e927             [ 2] 	sbc #0x27					; Sub 7 to get in to A-F range
c21e :                       con_hex_skip_x_f_1
c21e : c910             [ 2] 	cmp #0x10					; Nibble should be <= 0x0f
c220 : b01c             [ 3] 	bcs	con_hex_done			; Potentially done if not
c222 : 48               [ 3] 	pha
c223 : a53d             [ 3] 	lda num_a
                             	; make room for lo nibble
c225 : 0a               [ 2] 	asl a
c226 : 263e             [ 5] 	rol num_a+1
c228 : 0a               [ 2] 	asl a
c229 : 263e             [ 5] 	rol num_a+1
c22b : 0a               [ 2] 	asl a
c22c : 263e             [ 5] 	rol num_a+1
c22e : 0a               [ 2] 	asl a
c22f : 263e             [ 5] 	rol num_a+1
c231 : 853d             [ 3] 	sta num_a
                             	; save in low nibble
c233 : 68               [ 4] 	pla
c234 : 053d             [ 3] 	ora num_a
c236 : 853d             [ 3] 	sta num_a
c238 : c8               [ 2] 	iny
c239 : ca               [ 2] 	dex
c23a : d0d5             [ 3] 	bne con_hex_digit
                             	; if got to a 5th digit then error
c23c :                       con_hex_err
c23c : 38               [ 2] 	sec
c23d : 60               [ 6] 	rts
                             	; found a non-hex digit
AS65 Assembler for R6502 [1.42].                                     Page   56
---------------------------------- bank0.s -----------------------------------

c23e :                       con_hex_done
                             	; if no digits processed then error
c23e : c002             [ 2] 	cpy #2
c240 : f0fa             [ 3] 	beq con_hex_err
                             	; move y to x for digits processed
c242 : 98               [ 2] 	tya
c243 : aa               [ 2] 	tax
c244 : a902             [ 2] 	lda #NUM_HEX
c246 : 18               [ 2] 	clc
c247 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_bin_to_a
                             ;* Convert bin string to accumulator (unsigned)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
c248 :                       con_bin_to_a
c248 : 8649             [ 3] 	stx num_tmp
c24a : 854a             [ 3] 	sta num_tmp+1
c24c :                       con_bin_to_a_int
c24c : a002             [ 2] 	ldy #2
c24e : a211             [ 2] 	ldx #17						; Max 16 binary digits allowed
c250 :                       con_bin_digit
c250 : b149             [ 5] 	lda (num_tmp),y
c252 : c930             [ 2] 	cmp #'0'
c254 : 9010             [ 3] 	bcc con_bin_done
c256 : c932             [ 2] 	cmp #'1'+1
c258 : b00c             [ 3] 	bcs con_bin_done
                             	; sets C if '1' else resets C
c25a : 69cf             [ 2] 	adc #0xff-'0'
                             	; shift in digit
c25c : 263d             [ 5] 	rol num_a
c25e : 263e             [ 5] 	rol num_a+1
c260 : c8               [ 2] 	iny
c261 : ca               [ 2] 	dex
c262 : d0ec             [ 3] 	bne con_bin_digit
                             	; on the 17th digit is too much, error
c264 : f00a             [ 3] 	beq con_bin_err
c266 :                       con_bin_done
                             	; didn't process any digit = error
c266 : c002             [ 2] 	cpy #2
c268 : f006             [ 3] 	beq con_bin_err
                             	; put digits processed in to X
c26a : 98               [ 2] 	tya
c26b : aa               [ 2] 	tax
c26c : a903             [ 2] 	lda #NUM_BIN
c26e : 18               [ 2] 	clc
c26f : 60               [ 6] 	rts
c270 :                       con_bin_err
c270 :                       str_d_error
c270 : 38               [ 2] 	sec
c271 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* con_d_to_a
                             ;* Convert decimal string to accumulator (SIGNED)
                             ;* Input : Pointer to string (X=L, A=H)
                             ;* Output : num_a, num_a+1 contains word, X=numbe
                             ;* Regs affected : CS = Error
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page   57
---------------------------------- bank0.s -----------------------------------

c272 :                       con_dec_to_a
c272 : 8649             [ 3] 	stx num_tmp
c274 : 854a             [ 3] 	sta num_tmp+1
c276 :                       con_dec_to_a_int
c276 : a000             [ 2] 	ldy #0
                             	; Detect if leading minus sign
c278 : b149             [ 5] 	lda (num_tmp),y
c27a : c92d             [ 2] 	cmp #'-'
c27c : d001             [ 3] 	bne str_d_find_end
                             	; skip over minus if found
c27e : c8               [ 2] 	iny
c27f :                       str_d_find_end
c27f : b149             [ 5] 	lda (num_tmp),y
c281 : c930             [ 2] 	cmp #'0'
c283 : 9007             [ 3] 	bcc str_d_found_end
c285 : c93a             [ 2] 	cmp #'9'+1
c287 : b003             [ 3] 	bcs str_d_found_end
c289 : c8               [ 2] 	iny
c28a : d0f3             [ 3] 	bne str_d_find_end	; Possble wraparound but shou
c28c :                       str_d_found_end
c28c : c007             [ 2] 	cpy #7				; Biggest int is 6 chars
c28e : b0e0             [ 3] 	bcs str_d_error		; e.g. -32767
c290 : 844c             [ 3] 	sty num_tmp+3
c292 : a900             [ 2] 	lda #0
c294 : 854b             [ 3] 	sta num_tmp+2
c296 : 853d             [ 3] 	sta num_a
c298 : 853e             [ 3] 	sta num_a+1
c29a :                       str_d_process_digit
c29a : 88               [ 2] 	dey
c29b : 3027             [ 3] 	bmi str_d_digits_done
                             
c29d : b149             [ 5] 	lda (num_tmp),y
                             
c29f : c92d             [ 2] 	cmp #'-'			; Got to minus sign?
c2a1 : f021             [ 3] 	beq str_d_digits_done ; also done
                             
c2a3 : 38               [ 2] 	sec
c2a4 : e930             [ 2] 	sbc #'0'
                             	; Convert digit to number
                             	; and then offset in to
                             	; look up table of powers
c2a6 : 18               [ 2] 	clc
c2a7 : 0a               [ 2] 	asl a
c2a8 : 654b             [ 3] 	adc num_tmp+2
                             	; X contains index to powers
c2aa : aa               [ 2] 	tax
c2ab : a53d             [ 3] 	lda num_a
c2ad : 7de1c2           [ 4] 	adc str_d_powers,x
c2b0 : 853d             [ 3] 	sta num_a
c2b2 : a53e             [ 3] 	lda num_a+1
c2b4 : 7de2c2           [ 4] 	adc str_d_powers+1,x
c2b7 : 853e             [ 3] 	sta num_a+1
c2b9 : b0b5             [ 3] 	bcs str_d_error
                             	; Move to next power of 10 index
c2bb : a54b             [ 3] 	lda num_tmp+2
c2bd : 6914             [ 2] 	adc #20
c2bf : 854b             [ 3] 	sta num_tmp+2
c2c1 : 4c9ac2           [ 3] 	jmp str_d_process_digit
c2c4 :                       str_d_digits_done
                             	; check if minus
c2c4 : b149             [ 5] 	lda (num_tmp),y
c2c6 : c92d             [ 2] 	cmp #'-'
AS65 Assembler for R6502 [1.42].                                     Page   58
---------------------------------- bank0.s -----------------------------------

c2c8 : d011             [ 3] 	bne str_d_skip_neg
c2ca : a64c             [ 3] 	ldx num_tmp+3		; Must have >= 2 chars
c2cc : e002             [ 2] 	cpx #2				; else it's an error
c2ce : 90a0             [ 3] 	bcc str_d_error
c2d0 : a63d             [ 3] 	ldx num_a
c2d2 : a53e             [ 3] 	lda num_a+1
c2d4 : 2045c3           [ 6] 	jsr twos_complement
c2d7 : 863d             [ 3] 	stx num_a
c2d9 : 853e             [ 3] 	sta num_a+1
c2db :                       str_d_skip_neg
c2db : a64c             [ 3] 	ldx num_tmp+3
c2dd : a901             [ 2] 	lda #NUM_DEC
c2df : 18               [ 2] 	clc
c2e0 : 60               [ 6] 	rts
                             
c2e1 :                       str_d_powers
c2e1 : 00000100020003..      	dw	0, 1, 2, 3, 4, 5, 6, 7, 8, 9
c2f5 : 00000a0014001e..      	dw	0, 10, 20, 30, 40, 50, 60, 70, 80, 90
c309 : 00006400c8002c..      	dw	0, 100, 200, 300, 400, 500, 600, 700, 800, 90
c31d : 0000e803d007b8..      	dw	0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 
c331 : 00001027204e30..      	dw	0, 10000, 20000, 30000, 40000, 50000, 60000, 
                             	
                             
                             ;****************************************
                             ;* twos_complement
                             ;* Twos complement of X,A (X=low)
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : X,A in 2's complement
                             ;* Regs affected : P
                             ;****************************************
c345 :                       twos_complement
c345 : 49ff             [ 2] 	eor #0xff
c347 : 48               [ 3] 	pha
c348 : 8a               [ 2] 	txa
c349 : 49ff             [ 2] 	eor #0xff
c34b : aa               [ 2] 	tax
c34c : 68               [ 4] 	pla
c34d : e8               [ 2] 	inx
c34e : d003             [ 3] 	bne twos_complement_skip_X
c350 : 38               [ 2] 	sec			; Add 1 to A
c351 : 6900             [ 2] 	adc #0
c353 :                       twos_complement_skip_X
c353 : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* hex_to_bcd
                             ;* Convert accumulator,X to BCD
                             ;* Input : X = Low byte, A = High Byte to convert
                             ;* Output : 3 bytes of num_a is updated
                             ;* Regs affected : P
                             ;****************************************
c354 :                       hex_to_bcd
c354 : 08               [ 3] 	php
c355 : 48               [ 3] 	pha
c356 : 8538             [ 3] 	sta tmp_d
c358 : 8a               [ 2] 	txa
c359 : 48               [ 3] 	pha
c35a : a538             [ 3] 	lda tmp_d
                             
c35c : 8649             [ 3] 	stx num_tmp
c35e : 854a             [ 3] 	sta num_tmp+1
AS65 Assembler for R6502 [1.42].                                     Page   59
---------------------------------- bank0.s -----------------------------------

                             	
                             ;	bmi hex_to_bcd_skip_neg	; A is negative?
                             ;	jsr twos_complement
                             ;hex_to_bcd_skip_neg
c360 : a200             [ 2] 	ldx #0
c362 : 863d             [ 3] 	stx num_a
c364 : 863e             [ 3] 	stx num_a+1
c366 : 863f             [ 3] 	stx num_a+2
                             ;	stx num_a+3
c368 : a210             [ 2] 	ldx #16
c36a : f8               [ 2] 	sed
c36b :                       bin_to_bcd_bit
c36b : 0649             [ 5] 	asl num_tmp
c36d : 264a             [ 5] 	rol num_tmp+1
c36f : a53d             [ 3] 	lda num_a
c371 : 653d             [ 3] 	adc num_a
c373 : 853d             [ 3] 	sta num_a
c375 : a53e             [ 3] 	lda num_a+1
c377 : 653e             [ 3] 	adc num_a+1
c379 : 853e             [ 3] 	sta num_a+1
c37b : a53f             [ 3] 	lda num_a+2
c37d : 653f             [ 3] 	adc num_a+2
c37f : 853f             [ 3] 	sta num_a+2
c381 : ca               [ 2] 	dex
c382 : d0e7             [ 3] 	bne bin_to_bcd_bit
                             	
c384 : 68               [ 4] 	pla
c385 : aa               [ 2] 	tax
c386 : 68               [ 4] 	pla
c387 : 28               [ 4] 	plp
c388 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* int_to_str_ch
                             ;* Helper routine to stuff decimal char in to num
                             ;* Input : A=BCD digit, Y=num_buf index, C=insert
                             ;* Output : num_buf in ASCII, A=ASCII digit
                             ;* Regs affected : C cleared if non-zero
                             ;****************************************
c389 :                       int_to_str_ch
c389 : 290f             [ 2] 	and #0xf
c38b : 0930             [ 2] 	ora #0x30					; Convert to ascii
c38d : 4930             [ 2] 	eor #0x30					; Check if zero digit
c38f : d005             [ 3] 	bne int_to_str_nz			; If not zero definitely sto
c391 : b003             [ 3] 	bcs int_to_str_nz			; Also if C=1
c393 : 4930             [ 2] 	eor #0x30					; Restore A
c395 : 60               [ 6] 	rts							; Return without storing anything
c396 :                       int_to_str_nz
c396 : 4930             [ 2] 	eor #0x30					; Restore A
c398 : 994d00           [ 5] 	sta num_buf,y
c39b : c8               [ 2] 	iny
c39c : 38               [ 2] 	sec							; Set C as a non-zero encountered
c39d :                       int_to_str_ch_fin
c39d : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* int_to_str
                             ;* Convert int to string
                             ;* Input : in X,A (low,high), C=leading zeros wan
                             ;* Output : num_buf in ASCII 6 digits + zero term
AS65 Assembler for R6502 [1.42].                                     Page   60
---------------------------------- bank0.s -----------------------------------

                             ;* Regs affected : P
                             ;****************************************
c39e :                       int_to_str
                             	_pushAXY
                             
c3a7 : a000             [ 2] 	ldy #0						; first pos of num_buf
c3a9 : 0900             [ 2] 	ora #0						; Test A for sign bit
c3ab : 08               [ 3] 	php							; Remember C bit of P
c3ac : 100a             [ 3] 	bpl int_to_str_skip_neg		; Skip if not (postive 
c3ae : 2045c3           [ 6] 	jsr twos_complement			; Flip X,A from 2s complem
c3b1 : 48               [ 3] 	pha							; Remember A
c3b2 : a92d             [ 2] 	lda #'-'					; Put in negative sign
c3b4 : 854d             [ 3] 	sta num_buf
c3b6 : c8               [ 2] 	iny							; Start at second buffer pos
c3b7 : 68               [ 4] 	pla							; Restore A
c3b8 :                       int_to_str_skip_neg
c3b8 : 2054c3           [ 6]  	jsr hex_to_bcd				; Convert X,A to BCD
c3bb : a202             [ 2] 	ldx #2						; Start at BCD high byte
c3bd :                       int_str
c3bd : 28               [ 4] 	plp							; Get C but immediately
c3be : 08               [ 3] 	php							; Save C (due to loop check later)
c3bf : b53d             [ 4] 	lda num_a,x					; Get BCD digit
c3c1 : 8554             [ 3] 	sta num_buf+7				; Save A it for the units later
c3c3 : 4a               [ 2] 	lsr a						; Tens - shift to lower nibble
c3c4 : 4a               [ 2] 	lsr a
c3c5 : 4a               [ 2] 	lsr a
c3c6 : 4a               [ 2] 	lsr a
c3c7 : 28               [ 4] 	plp							; Get C
c3c8 : 2089c3           [ 6] 	jsr int_to_str_ch			; Put ASCII code in num_buf
c3cb : a554             [ 3] 	lda num_buf+7				; Get A for the units
c3cd : 2089c3           [ 6] 	jsr int_to_str_ch			; Put ASCII code in num_buf
c3d0 : 08               [ 3] 	php							; Save C
c3d1 : ca               [ 2] 	dex
c3d2 : 10e9             [ 3] 	bpl int_str
c3d4 : 28               [ 4] 	plp							; Check C
c3d5 : b005             [ 3] 	bcs	int_to_str_fin			; If set then something pri
c3d7 : a930             [ 2] 	lda #'0'					; Stuff a zero
c3d9 : 854d             [ 3] 	sta num_buf					; Must be in first position..
c3db : c8               [ 2] 	iny
c3dc :                       int_to_str_fin
c3dc : a900             [ 2] 	lda #0						; Terminator
c3de : 994d00           [ 5] 	sta num_buf,y
c3e1 : c8               [ 2] 	iny
                             	_pullAXY
                             
c3e7 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* bcd_to_str
                             ;* Convert num_buf to chars
                             ;* Input : num_a in BCD format
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
                             ;bcd_to_str
                             ;	_pushAXY
                             ;
                             ;	ldx #5						; Index in to string
                             ;	ldy #0						; Current BCD digit
                             ;bcd_str
                             ;	lda num_a,y
AS65 Assembler for R6502 [1.42].                                     Page   61
---------------------------------- bank0.s -----------------------------------

                             ;	; Convert 1s digit of byte
                             ;	pha
                             ;	and #0xf
                             ;	clc
                             ;	adc #0x30
                             ;	sta num_buf,x
                             ;	; Convert 10s digit of byte
                             ;	pla
                             ;	lsr a
                             ;	lsr a
                             ;	lsr a
                             ;	lsr a
                             ;	clc
                             ;	adc #0x30					; Convert to ASCII
                             ;	sta num_buf-1,x
                             ;	dex
                             ;	dex
                             ;	iny
                             ;	cpy #3						; 3 BCD digits max
                             ;	bne bcd_str
                             ;
                             ;	_pullAXY
                             ;	rts
                             	
                             ;****************************************
                             ;* out_bcd
                             ;* Output a bcd string in num_buf
                             ;* Input : num_buf has the ASCII
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII 6 digits
                             ;* Output is big endian, input is not, Y=digits p
                             ;* Regs affected : P
                             ;****************************************
                             ;out_bcd
                             ;	pha
                             ;	txa
                             ;	pha
                             ;	php
                             ;	ldy #0						; How many digits printed
                             ;	ldx #0						; Index in to string
                             ;out_bcd_digit
                             ;	lda num_buf,x
                             ;	cpy #0						; If not in leading zero mode
                             ;	bne out_bcd_print			; No then go print
                             ;
                             ;	cmp #'0'					; else check if zero
                             ;	bne out_bcd_print			; No then go print
                             ;
                             ;	plp
                             ;	php
                             ;	bcc out_bcd_next			; If C=0 go to next digit, e
                             ;out_bcd_print
                             ;	iny
                             ;	jsr io_put_ch
                             ;out_bcd_next
                             ;	inx
                             ;	cpx #6
                             ;	bne out_bcd_digit
                             ;	tya							; If nothing printed
                             ;	bne out_bcd_fin
                             ;	lda #'0'					; Need to put out 1 zero
                             ;	jsr io_put_ch
AS65 Assembler for R6502 [1.42].                                     Page   62
---------------------------------- bank0.s -----------------------------------

                             ;	iny
                             ;out_bcd_fin
                             ;	plp
                             ;	pla
                             ;	tax
                             ;	pla
                             ;	clc
                             ;	rts
                             	
                             	
                             ;****************************************
                             ;* print_a_to_d
                             ;* Convert X,A to decimal string
                             ;* Input : X,A = number Low,High
                             ;* Input : C=1 print leading zeros else not
                             ;* Output : num_buf in ASCII max 6 digits
                             ;*          Y=digits printed including sign
                             ;* Output is big endian, input is not
                             ;* Regs affected : P
                             ;****************************************
c3e8 :                       print_a_to_d
c3e8 : 209ec3           [ 6] 	jsr int_to_str
c3eb : a000             [ 2] 	ldy #0
c3ed :                       print_a_to_d_ch
c3ed : b94d00           [ 4] 	lda num_buf,y
c3f0 : f006             [ 3] 	beq print_a_to_d_fin
c3f2 : 2030c4           [ 6] 	jsr io_put_ch
c3f5 : c8               [ 2] 	iny
c3f6 : d0f5             [ 3] 	bne print_a_to_d_ch
c3f8 :                       print_a_to_d_fin
c3f8 : 60               [ 6] 	rts
                             
                             ;	php
                             ;	cmp #0x80					; Check if sign bit is set
                             ;	bcc print_a_to_d_skip_neg	; Skip if not (postiv
                             ;	jsr twos_complement			; Flip from 2s complement
                             ;	jsr hex_to_bcd				; Convert to BCD
                             ;	jsr bcd_to_str				; Convert BCD to string
                             ;	lda #'-'
                             ;	jsr io_put_ch
                             ;	plp							; Leading zeros preference
                             ;	jsr out_bcd
                             ;	iny							; Account for sign
                             ;	rts
                             ;print_a_to_d_skip_neg
                             ;	jsr hex_to_bcd				; Convert to BCD
                             ;	jsr bcd_to_str				; Convert BCD to string
                             ;	plp							; Leading zeros preference
                             ;	jmp out_bcd					; Print +ve string
                             	
                             	include "io/io.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  IO.S
                             ;*  General IO module.  Allows different IO devic
                             ;*  utilised transparently by the rest of the cod
AS65 Assembler for R6502 [1.42].                                     Page   63
---------------------------------- bank0.s -----------------------------------

                             ;*  Other code should use "io_" commands so that 
                             ;*  do not need to know what specific device is p
                             ;*  input and output capabilities.
                             ;*	On startup, the kernel defaults to keyboard an
                             ;*  examines the BBC DIP switch to decide whether
                             ;*	but when saving and loading points to tape rou
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c3f9 :                       mod_sz_io_s
                             
                             ;****************************************
                             ;* io_init
                             ;* Initialise the default device and make active
                             ;* No keys pressed = serial (default)
                             ;* F0 pressed = KB/VDP
                             ;* F1 pressed = Serial
                             ;* Keyboard and screen or serial port
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c3f9 :                       io_init
                             	if DFLATLOCI
                             	jsr lc_init_path	; Initialise the LOCI sd card p
                             	lda #1				; Default = KB/VDP, no Arduino sd card
                             	else
c3f9 : 20a1c5           [ 6] 	jsr f_init_default	; Determine if Arduino sd car
c3fc : 0901             [ 2] 	ora #1				; Default = KB/VDP, MSB=Arduino card c
                             	endif
c3fe : 8d0006           [ 4] 	sta io_default
c401 : 4c07c4           [ 3] 	jmp io_active_device; Activate the device
                             
                             
                             ;****************************************
                             ;* io_set_default, io_active_device
                             ;* Activate device based on default or A
                             ;* Input : A = Device number
                             ;* Output : None
                             ;* Regs affected : P, A
                             ;****************************************
c404 :                       io_set_default			; Entry point for default
c404 : ad0006           [ 4] 	lda io_default
c407 :                       io_active_device		; Entry point for A set
c407 : aa               [ 2] 	tax					; X=buf size index
c408 : 0a               [ 2] 	asl	a				; x16 the Block number
c409 : 0a               [ 2] 	asl a
c40a : 0a               [ 2] 	asl a
c40b : 0a               [ 2] 	asl a
c40c : a8               [ 2] 	tay					; Y=index in to device table
c40d : bd93c4           [ 4] 	lda io_buf_sz,x
c410 : 853b             [ 3] 	sta buf_sz
c412 : a200             [ 2] 	ldx #0
                             	; Copy device settings to io block
c414 :                       io_copy_data
c414 : b995c4           [ 4] 	lda io_devices,y
c417 : 9d0106           [ 5] 	sta io_block,x
c41a : c8               [ 2] 	iny
c41b : e8               [ 2] 	inx
c41c : e010             [ 2] 	cpx #16
AS65 Assembler for R6502 [1.42].                                     Page   64
---------------------------------- bank0.s -----------------------------------

c41e : d0f4             [ 3] 	bne io_copy_data
                             	
c420 : a91f             [ 2] 	lda #lo(scratch)	; Initialise IO buffer and size
c422 : 8539             [ 3] 	sta buf_lo
c424 : a906             [ 2] 	lda #hi(scratch)
c426 : 853a             [ 3] 	sta buf_hi
c428 : a90d             [ 2] 	lda #UTF_CR			; Line terminator is CR
c42a : 853c             [ 3] 	sta buf_ef
c42c : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* io_get_ch
                             ;* Get a char (wait forever or just check)
                             ;* Input : C = 1 for synchronous, 0 for async
                             ;* Output : A = Byte code, C = 1 means A is inval
                             ;* Regs affected : P, A
                             ;****************************************
c42d :                       io_get_ch
c42d : 6c0106           [ 6] 	jmp (io_block+io_get_byte)
                             	
                             
                             ;****************************************
                             ;* io_put_ch
                             ;* Put a char
                             ;* Input : A = char
                             ;* Regs affected : P, A
                             ;****************************************
c430 :                       io_put_ch
c430 : 6c0306           [ 6] 	jmp (io_block+io_put_byte)
                             	
                             ;****************************************
                             ;* io_open_read
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c433 :                       io_open_read
c433 : 6c0506           [ 6] 	jmp (io_block+io_open_r)
                             	
                             ;****************************************
                             ;* io_open_write
                             ;* Open for reading
                             ;* Input : X,A = pointer to filename (zero termin
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c436 :                       io_open_write
c436 : 6c0706           [ 6] 	jmp (io_block+io_open_w)
                             
                             ;****************************************
                             ;* io_close
                             ;* Close a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c439 :                       io_close
c439 : 6c0906           [ 6] 	jmp (io_block+io_close_f)
                             	
                             ;****************************************
                             ;* io_delete
AS65 Assembler for R6502 [1.42].                                     Page   65
---------------------------------- bank0.s -----------------------------------

                             ;* Delete a file
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c43c :                       io_delete
c43c : 6c0b06           [ 6] 	jmp (io_block+io_del_f)
                             
                             ;****************************************
                             ;* io_open_ext1
                             ;* Extended function 1
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c43f :                       io_open_ext1
c43f : 6c0d06           [ 6] 	jmp (io_block+io_ext1)
                             	
                             ;****************************************
                             ;* io_open_ext2
                             ;* Extended function 2
                             ;* Input : 
                             ;* Output : C=0 success
                             ;* Regs affected : All
                             ;****************************************
c442 :                       io_open_ext2
c442 : 6c0f06           [ 6] 	jmp (io_block+io_ext2)
                             	
                             ;****************************************
                             ;* io_read_line
                             ;* Read a line, terminated by terminating char or
                             ;* Input : buf_(lo/hi/sz/ef) : Address, Max size,
                             ;* Output : Y = Line length C = Buffer limit reac
                             ;* Regs affected : None
                             ;****************************************
c445 :                       io_read_line
c445 : 48               [ 3] 	pha
                             
c446 : 08               [ 3] 	php					; Save echo state
                             	
c447 : a000             [ 2] 	ldy #0x00			; Starting at first byte
c449 :                       io_get_line_byte
c449 : 38               [ 2] 	sec					; Getting bytes synchronously
c44a : 202dc4           [ 6] 	jsr io_get_ch		; Get a byte
c44d : b027             [ 3] 	bcs io_get_line_done; Got nothing then finish
c44f : 28               [ 4] 	plp					; Get echo state
c450 : 08               [ 3] 	php					; Instantly save it back
c451 : 900c             [ 3] 	bcc io_skip_echo	; Carry not set = don't echo
c453 : c97f             [ 2] 	cmp #UTF_DEL		; Delete?
c455 : d005             [ 3] 	bne io_do_echo
c457 : c000             [ 2] 	cpy #0				; Already at beginning?
c459 : f004             [ 3] 	beq io_skip_echo	; Don't echo delete
c45b : 88               [ 2] 	dey					; Else decrement length
c45c :                       io_do_echo
c45c : 2030c4           [ 6] 	jsr io_put_ch		; Echo it
c45f :                       io_skip_echo
c45f : c920             [ 2] 	cmp #UTF_SPECIAL	; Special character?
c461 : 9007             [ 3] 	bcc io_skip_special	; Skip if so (don't add to b
c463 : c97f             [ 2] 	cmp #UTF_DEL		; Don't proces DEL either
c465 : f003             [ 3] 	beq io_skip_special
c467 : 9139             [ 5] 	sta (buf_lo),y		; Save it
c469 : c8               [ 2] 	iny					; Increase length
AS65 Assembler for R6502 [1.42].                                     Page   66
---------------------------------- bank0.s -----------------------------------

c46a :                       io_skip_special
c46a : c53c             [ 3] 	cmp buf_ef			; Is it the terminating char?
c46c : f008             [ 3] 	beq io_get_line_done	; If yes then done
c46e : c43b             [ 3] 	cpy buf_sz			; Reached the buffer max size?
c470 : d0d7             [ 3] 	bne io_get_line_byte	; No, get another byte
c472 : 28               [ 4] 	plp					; Remember to pull echo state off stack
c473 : 38               [ 2] 	sec					; Yes, set carry flag
c474 : 68               [ 4] 	pla
c475 : 60               [ 6] 	rts					; And done
c476 :                       io_get_line_done
c476 : a900             [ 2] 	lda #0
c478 : 9139             [ 5] 	sta (buf_lo),y		; Terminate with 0
c47a : 28               [ 4] 	plp					; Remember to pull echo state off stack
c47b : 18               [ 2] 	clc					; Clear carry flag
c47c : 68               [ 4] 	pla
c47d : 60               [ 6] 	rts					; Fin
                             
                             ;****************************************
                             ;* io_print_line
                             ;* Print a line (when data is not already in seri
                             ;* Input : X = Address Lo, A = Address Hi
                             ;* Output : Y=number chars output
                             ;* Regs affected : All
                             ;****************************************
c47e :                       io_print_line
c47e : 48               [ 3] 	pha
                             
c47f : 8636             [ 3] 	stx tmp_clo					; Store the string pointer
c481 : 8537             [ 3] 	sta tmp_chi					; lo and hi
c483 : a000             [ 2] 	ldy #0						; Start at the beginning!
c485 :                       io_print_line_byte
c485 : b136             [ 5] 	lda (tmp_clo),y				; Copy byte to
c487 : f006             [ 3] 	beq io_print_done			; If zero then done - print
c489 : 2030c4           [ 6] 	jsr io_put_ch				; Transmit
c48c : c8               [ 2] 	iny
c48d : d0f6             [ 3] 	bne io_print_line_byte		; Carry on until zero fo
c48f :                       io_print_done
c48f : 68               [ 4] 	pla
c490 : 60               [ 6] 	rts
                             
                             
                             ;*** Null operation just clc and return ***
c491 :                       io_null_op
c491 : 18               [ 2] 	clc
c492 : 60               [ 6] 	rts
                             	
                             ;* IO buffer sizes
c493 :                       io_buf_sz
c493 : ff                    	db 255					; Device 0 = Tapeoe SDCard
c494 : 7f                    	db 127					; Device 1 = keyboard/screen
                             
                             ;* IO devices defined here
c495 :                       io_devices
                             ;* Device zero is the tape/sdcard system
                             ;* t: is for tape, s: is for sdcard in the filena
                             ;* the file routines parse the filename to fine t
                             ;* at the file protocol level both t: and s: appe
                             ;* hence device0 can handle both
                             ;* This is a block based device
c495 :                       io_device0					; Tape device, input = Tape, outpu
c495 : d7c6                  	dw	f_get_byte			; io_get_ch
c497 : 6fc6                  	dw	f_put_byte			; io_put_ch
AS65 Assembler for R6502 [1.42].                                     Page   67
---------------------------------- bank0.s -----------------------------------

c499 : cbc5                  	dw	f_open_read			; io_open_r
c49b : 25c6                  	dw	f_open_write		; io_open_w
c49d : 04c6                  	dw	f_close				; io_close_f
c49f : 91c4                  	dw	io_null_op			; io_del_f
c4a1 : cbc5                  	dw	f_open_bread		; io_ext1 - open for binary rea
c4a3 : 1fc6                  	dw	f_open_bwrite		; io_ext2 - open for binary wr
                             ;* Device one is keyboard / screen
                             ;* only offers get and put
                             ;* This is a char based device
c4a5 :                       io_device1					; Default device, input = screen e
c4a5 : b0d0                  	dw	gr_get_key			; io_get_ch
c4a7 : e6d0                  	dw	gr_put_byte			; io_put_ch
c4a9 : 91c4                  	dw	io_null_op			; io_open_r
c4ab : 91c4                  	dw	io_null_op			; io_open_w
c4ad : 91c4                  	dw	io_null_op			; io_close_f
c4af : 91c4                  	dw	io_null_op			; io_del_f
c4b1 : 91c4                  	dw	io_null_op			; io_ext1
c4b3 : 91c4                  	dw	io_null_op			; io_ext2
c4b5 :                       mod_sz_io_e
                             
                             
                             
                             ;* Reset vector points here - 6502 starts here
c4b5 :                       init
                             ;	jmp init_test
                             	; First clear ram
c4b5 : 78               [ 2] 	sei					; Need this for MOS 6502
c4b6 : d8               [ 2] 	cld					; Need this for MOS 6502
c4b7 : 4cdec4           [ 3] 	jmp init_ram		; jmp not jsr to ram initialiser
c4ba :                       init_2					; init_ram will jump back to here
c4ba : a2ff             [ 2] 	ldx #0xff			; Initialise stack pointer
c4bc : 9a               [ 2] 	txs
                             
c4bd : 20c3c4           [ 6] 	jsr kernel_init
                             
c4c0 : 4c77c0           [ 3] 	jmp main
                             
c4c3 :                       kernel_init
c4c3 : 20bdc0           [ 6] 	jsr init_irq		; Initialise IRQ handling
                             
c4c6 : 20fdc4           [ 6] 	jsr init_via0		; initialise cia 0 - tape inactiv
                             ;	jsr tp_init			; Initialise tape handling
                             
c4c9 : 20e9d5           [ 6] 	jsr init_snd		; initialise the sound chip
                             
c4cc : 204cce           [ 6] 	jsr gr_init			; Initialise graphics, default is 
                             
c4cf : 20acc8           [ 6] 	jsr init_keyboard	; initialise keyboard timer se
c4d2 : 20f9c3           [ 6] 	jsr io_init			; Set default input/output device
                             
c4d5 : a900             [ 2] 	lda #0
c4d7 : 8508             [ 3] 	sta vdp_cnt
                             
c4d9 : 20bff7           [ 6] 	jsr df_init			; Initialise interpreter
                             
c4dc : 58               [ 2] 	cli					; irq interrupts enable
                             
c4dd :                       kernel_test
                             ;	jsr kb_read_raw
                             ;	jsr utilPrintA
                             ;	jsr utilPrintCRLF
                             ;	jmp kernel_test
AS65 Assembler for R6502 [1.42].                                     Page   68
---------------------------------- bank0.s -----------------------------------

                             	
c4dd : 60               [ 6] 	rts
                             
                             
                             ;* Initialises RAM, skipping page 3 which is for 
                             ;* Zeroes all addressable RAM in the default bank
c4de :                       init_ram
c4de : a900             [ 2] 	lda #0				; Normal RAM filled with zero
c4e0 : a002             [ 2] 	ldy #0x02			; But Y initially at 2 to not overwr
c4e2 : aa               [ 2] 	tax 				; Page counter starts at zero
c4e3 : 8600             [ 3] 	stx 0x00			; Start at page 0
c4e5 : 8601             [ 3] 	stx 0x01
c4e7 :                       init_ram_1
c4e7 : e003             [ 2] 	cpx	#3				; Ignore page 3 (IO page)
c4e9 : f005             [ 3] 	beq init_ram_skip
c4eb :                       init_ram_fill
c4eb : 9100             [ 5] 	sta (0x00),y		; Write byte to RAM (zero or copy 
c4ed : c8               [ 2] 	iny
c4ee : d0f7             [ 3] 	bne init_ram_1		; Do a whole page
c4f0 :                       init_ram_skip
c4f0 : e601             [ 5] 	inc 0x01			; Increase page pointer
c4f2 : e8               [ 2] 	inx					; Reduce page count
c4f3 : e0c0             [ 2] 	cpx #0xc0			; Do all pages until page until we g
c4f5 : d0f0             [ 3] 	bne init_ram_1
                             
c4f7 : f0c1             [ 3] 	beq init_2			; Carry on initialisation
                             
                             ; 6502 Non-maskable interrupt come here
c4f9 :                       nmi
c4f9 : 40               [ 6] 	rti
                             
c4fa :                       mod_sz_kernel_e
                             
                             
                             
                             ; Bank specific code goes here
                             	include "cia/cia.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  CIA.S
                             ;*  Code to initialise and utilise the 6522, whic
                             ;*	for various functions on the Oric including;
                             ;*		Port A:
                             ;*			[7..0] 	Printer data bits
                             ;*			[7..0] 	Interface to AY-3-8912
                             ;*		Port B:
                             ;*			[2..0] 	Keyboard matrix row selector
                             ;*			[7]	   	Tape output
                             ;*			[6]    	Tape player motor signal
                             ;*			[4]		Printer strobe
                             ;*		CA1:		Printer ACK
                             ;*		CB1: 		Tape input
                             ;*		CA2,CB2: 	Selecting the AY-3-8912
                             ;*
                             ;*  This file is called cia.s because code was or
                             ;*  for a MOS 6526 from a CMB64, but didn't get a
AS65 Assembler for R6502 [1.42].                                     Page   69
---------------------------------- bank0.s -----------------------------------

                             ;*	renaming this file ;-)
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code
                             
c4fa :                       mod_sz_cia_s
                             
                             
                             ;****************************************
                             ;* init_via0
                             ;* Initialise cia 0
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : A
                             ;****************************************
c4fa :                       init_via0_tape					; initialisation bytes for tap
c4fa : a017             [ 2] 	ldy #init_tape_tab-init_via0_tab
c4fc : 2c                    	db 0x2c						; Ignore next two bytes
c4fd :                       init_via0
c4fd : a000             [ 2] 	ldy #0						; Standard initialisation of VIA
c4ff :                       init_via0_loop
c4ff : b910c5           [ 4] 	lda init_via0_tab,y
c502 : 300b             [ 3] 	bmi init_via0_done
c504 : aa               [ 2] 	tax
c505 : c8               [ 2] 	iny
c506 : b910c5           [ 4] 	lda init_via0_tab,y
c509 : 9d0003           [ 5] 	sta IO_0,x
c50c : c8               [ 2] 	iny
c50d : d0f0             [ 4] 	bne init_via0_loop
                             
c50f :                       init_via0_done
c50f : 60               [ 6] 	rts							; return from sub
                             
c510 :                       init_via0_tab
c510 : 0e7f                  	db IER, 	0x7f
c512 : 03ff                  	db DDRA,	0xff			; Port A output by default
c514 : 02f7                  	db DDRB,	0xf7			; Tape motor + KB select
c516 : 00b7                  	db PRB,		KB_PRB+7		; Port B default (cassette mo
c518 : 0cdd                  	db PCR,		SND_DESELECT	; Ensure AY is not selecte
c51a : 0420                  	db T1CL,	lo(TIMER1_RATE)	; 50Hz
c51c : 0620                  	db T1LL,	lo(TIMER1_RATE)	; 50Hz
c51e : 054e                  	db T1CH,	hi(TIMER1_RATE)	; 50Hz
c520 : 074e                  	db T1LH,	hi(TIMER1_RATE)	; 50Hz
c522 : 0b40                  	db ACR,		0x40			; Timer 1 continuous
c524 : 0ec0                  	db IER,		0xc0			; Timer 1 interrupt enabled
c526 : ff                    	db -1
c527 :                       init_tape_tab
c527 : 0e7f                  	db IER,		0x7f			; Disable all interrupts
c529 : 08f4                  	db T2CL,	0xf4			; Timer 2 used for measuring CB1
c52b : 0c10                  	db PCR,		0x10			; Interrupt on CB1 positive edge
c52d : 0bc0                  	db ACR,		0xc0			; T1 continuous and toggle PB7
c52f : 04a0                  	db T1CL,	lo(TAPE_RATE*2)	; Tape rate /2 = 0
c531 : 0501                  	db T1CH,	hi(TAPE_RATE*2)	; Tape rate /2 = 0
c533 : 00f0                  	db PRB,		KB_PRB+0x40		; Tape motor ON
c535 : ff                    	db -1
                             
                             ;****************************************
                             ;* via_strobe_init
                             ;* set strobe low & port A pin directions
AS65 Assembler for R6502 [1.42].                                     Page   70
---------------------------------- bank0.s -----------------------------------

                             ;****************************************
c536 :                       via_strobe_init
c536 : 8d0303           [ 4] 	sta   IO_0+DDRA
                             
                             	;set strobe low
c539 : ad0003           [ 4] 	lda   IO_0+PRB
c53c : 29ef             [ 2] 	and   #0b11101111
c53e : 8d0003           [ 4] 	sta   IO_0+PRB
                             
c541 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* via_strobe_off
                             ;* deselect printer port devices
                             ;****************************************
c542 :                       via_strobe_off
c542 : 48               [ 3] 	pha
                             
                             	;set strobe high
c543 : ad0003           [ 4] 	lda   IO_0+PRB
c546 : 0910             [ 2] 	ora   #0b00010000
c548 : 8d0003           [ 4] 	sta   IO_0+PRB
                             
                             	;set all bits of porta except kb sense to output
c54b : a9f7             [ 2] 	lda   #0xf7
c54d : 8d0303           [ 4] 	sta   IO_0+DDRA
                             
c550 : 68               [ 4] 	pla
c551 : 60               [ 6] 	rts
                             
                             
c552 :                       mod_sz_cia_e
                             
                             	include "file/file.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  FILE.S
                             ;*	These routines allow for input/output and are 
                             ;*	by both the tape and parallel devices.
                             ;*	The format is based on a tape format.
                             ;*	The tape format is not compatible with a regul
                             ;*	but is a block format as follows;
                             ;*	Some zero bits (64) start a block.
                             ;*	Then two bytes of data representing the block 
                             ;*	Then 256 bytes of block data.
                             ;*	Each byte above consists of two '1' start bits
                             ;*	one '0' stop bit.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
c552 :                       mod_sz_file_s
                             
                             ;* Vector table for tape or sd card device
AS65 Assembler for R6502 [1.42].                                     Page   71
---------------------------------- bank0.s -----------------------------------

c552 :                       file_vectors
                             	if DFLATLOCI
                             
                             ;* LOCI sd vectors
                             	dw	lc_init
                             	dw	lc_read_byte
                             	dw	lc_write_byte
                             	dw	lc_put_delay
                             	dw	lc_block_gap
                             	dw	lc_release
                             
                             	else
                             
                             ;* Tape vectors
c552 : 13c7                  	dw	tp_init
c554 : 82c7                  	dw	tp_read_byte
c556 : 2ac7                  	dw	tp_write_byte
c558 : 17c7                  	dw	tp_put_delay
c55a : 1fc7                  	dw	tp_block_gap
c55c : 16c7                  	dw	tp_release
                             ;* SD Card vectors
c55e : 6fc8                  	dw	sd_init
c560 : 42c8                  	dw	sd_read_byte
c562 : 06c8                  	dw	sd_write_byte
c564 : 86c8                  	dw	sd_put_delay
c566 : 86c8                  	dw	sd_block_gap
c568 : b1c7                  	dw	sd_release
                             
                             	endif
                             
                             ;* Jump through vectors for device specific calls
c56a :                       f_init
c56a : 6c1106           [ 6] 	jmp (f_storage_vec+f_init_vec)
c56d :                       f_read_byte
c56d : 6c1306           [ 6] 	jmp (f_storage_vec+f_read_byte_vec)
c570 :                       f_write_byte
c570 : 6c1506           [ 6] 	jmp (f_storage_vec+f_write_byte_vec)
c573 :                       f_put_delay
c573 : 6c1706           [ 6] 	jmp (f_storage_vec+f_put_delay_vec)
c576 :                       f_block_gap
c576 : 6c1906           [ 6] 	jmp (f_storage_vec+f_block_gap_vec)
c579 :                       f_release
c579 : 6c1b06           [ 6] 	jmp (f_storage_vec+f_release_vec)
                             	
c57c :                       f_open_msg
c57c : 4c6f6164696e67..      	db	"Loading:",0
c585 :                       f_save_msg
c585 : 536176696e673a00      	db	"Saving:",0
c58d :                       f_back4
c58d : 0808080800            	db	8,8,8,8,0
                             
c592 :                       f_print_msg
c592 : 245b             [ 3] 	bit tp_print
c594 : 300a             [ 3] 	bmi f_no_print
c596 : 4c3ad1           [ 3] 	jmp gr_print_line
                             
c599 :                       f_print_byte
c599 : 245b             [ 3] 	bit tp_print
c59b : 3003             [ 3] 	bmi f_no_print
c59d : 4ce6d0           [ 3] 	jmp gr_put_byte
                             
c5a0 :                       f_no_print
AS65 Assembler for R6502 [1.42].                                     Page   72
---------------------------------- bank0.s -----------------------------------

c5a0 : 60               [ 6] 	rts
                             
                             ; C=1 means error (A=0)
                             ; C=0 means sd card found (A=0x80)
c5a1 :                       f_init_default
c5a1 : 18               [ 2] 	clc
                             	if !DFLATLOCI
c5a2 : 20d5c7           [ 6] 	jsr sd_ready
c5a5 : a980             [ 2] 	lda #0x80
c5a7 : 9002             [ 3] 	bcc f_init_default_rts
c5a9 : a900             [ 2] 	lda #0x00
                             	endif
c5ab :                       f_init_default_rts
c5ab : 60               [ 6] 	rts
                             
                             
                             ;* Common function to open tape
                             ;* df_linbuff contains the filename without devic
                             ;* A contains device (0=tape, 1=sdcard)
c5ac :                       f_open_common				; Used by open write also
                             	if !DFLATLOCI
c5ac : a8               [ 2] 	tay						; Move A to Y
c5ad : f002             [ 3] 	beq f_skip_sd			; Skip SD card if 0
c5af : a00c             [ 2] 	ldy #f_storage_table	; Else Y index into sd card
c5b1 :                       f_skip_sd	
                             	else
                             	ldy #0					; Ignore device # in LOCI
                             	endif
c5b1 : a200             [ 2] 	ldx #0					; Start at beginning of table
c5b3 :                       f_init_vectors
c5b3 : b952c5           [ 4] 	lda file_vectors,y		; Get vector byte
c5b6 : 9d1106           [ 5] 	sta f_storage_vec,x		; Save to ram table
c5b9 : c8               [ 2] 	iny
c5ba : e8               [ 2] 	inx
c5bb : e00c             [ 2] 	cpx #f_storage_table	; Keep going until whole ta
c5bd : d0f4             [ 3] 	bne f_init_vectors
                             
c5bf : 78               [ 2] 	sei						; Interrupts disabled from here..
c5c0 : a200             [ 2] 	ldx #0
c5c2 : 8657             [ 3] 	stx tp_idx				; Initialise block
c5c4 : 8655             [ 3] 	stx tp_block
c5c6 : 8656             [ 3] 	stx tp_block+1
                             	
c5c8 : 4c6ac5           [ 3] 	jmp  f_init				; Initialise VIA etc.
                             
                             ;* tp_open_read
                             
c5cb :                       fd_cload_getname_pc			; ** FOR ORICUTRON EMULATOR
                             
c5cb :                       f_open_bread
c5cb :                       f_open_read
c5cb : 48               [ 3] 	pha						; Don't lose device number
c5cc : a901             [ 2] 	lda #1					; Read mode
c5ce : 8558             [ 3] 	sta tp_flag
c5d0 : a07c             [ 2] 	ldy #lo(f_open_msg)
c5d2 : a9c5             [ 2] 	lda #hi(f_open_msg)
c5d4 : 2092c5           [ 6] 	jsr f_print_msg
c5d7 : 68               [ 4] 	pla
c5d8 : 20acc5           [ 6] 	jsr f_open_common
                             	if DFLATLOCI
                             	lda tp_flag				; If zero means directory
                             	beq f_skip_dir
AS65 Assembler for R6502 [1.42].                                     Page   73
---------------------------------- bank0.s -----------------------------------

                             	endif
c5db :                       f_get_fname_start
c5db : 206dc5           [ 6] 	jsr f_read_byte
c5de : c924             [ 2] 	cmp #'$'				; Find the $ symbol
c5e0 : d0f9             [ 3] 	bne f_get_fname_start
                             	
c5e2 : a209             [ 2] 	ldx #9					; 9 byte header - skip
c5e4 :                       f_get_header
c5e4 : 206dc5           [ 6] 	jsr f_read_byte
c5e7 : ca               [ 2] 	dex
c5e8 : d0fa             [ 3] 	bne f_get_header
                             	
                             	; X= zero here, now get null terminated filename
c5ea :                       f_get_fname
c5ea : 206dc5           [ 6] 	jsr f_read_byte
c5ed : 9d0004           [ 5] 	sta df_linbuff,x
c5f0 : e8               [ 2] 	inx
c5f1 : c900             [ 2] 	cmp #0
c5f3 : d0f5             [ 3] 	bne f_get_fname
                             
c5f5 : a000             [ 2] 	ldy #lo(df_linbuff)
c5f7 : a904             [ 2] 	lda #hi(df_linbuff)
c5f9 : 2092c5           [ 6] 	jsr f_print_msg
c5fc : a920             [ 2] 	lda #' '
c5fe : 2099c5           [ 6] 	jsr f_print_byte
c601 :                       f_skip_dir
c601 : 18               [ 2] 	clc
c602 : 60               [ 6] 	rts
                             
c603 :                       tt_getsync_pc				; ** FOR ORICUTRON EMULATOR **
c603 :                       tt_getsync_end_pc			; ** FOR ORICUTRON EMULATOR *
                             
c603 : ea               [ 2] 	nop
                             	
                             
                             ;* tp_close
                             ;* Close tape settings
c604 :                       f_close
c604 : a558             [ 3] 	lda tp_flag
c606 : c902             [ 2] 	cmp #2					; Write mode?
c608 : d003             [ 3] 	bne f_close_no_flush	; If not no need to flush
c60a : 2099c6           [ 6] 	jsr f_put_block			; Flush the current block
c60d :                       f_close_no_flush
c60d : a90d             [ 2] 	lda #0x0d				; Line feed
c60f : 2099c5           [ 6] 	jsr f_print_byte
c612 : 2079c5           [ 6] 	jsr f_release			; Device specific resource relea
c615 : 20fdc4           [ 6] 	jsr init_via0			; Back to normal
c618 : 58               [ 2] 	cli
c619 : a900             [ 2] 	lda #0					; Zero tape flag
c61b : 8558             [ 3] 	sta tp_flag
                             
c61d :                       tt_csave_end_pc				; ** FOR ORICUTRON EMULATOR **
                             
c61d : 18               [ 2] 	clc
c61e : 60               [ 6] 	rts
                             
                             ;* tp_open_write
                             ;* Open tape settings
c61f :                       f_open_bwrite
c61f : a001             [ 2] 	ldy #hi(0x101)
c621 : a201             [ 2] 	ldx #lo(0x101)
c623 : d004             [ 3] 	bne f_open_write_start
AS65 Assembler for R6502 [1.42].                                     Page   74
---------------------------------- bank0.s -----------------------------------

c625 :                       f_open_write
c625 : a018             [ 2] 	ldy #hi(6000+0x101)
c627 : a271             [ 2] 	ldx #lo(6000+0x101)
                             
c629 :                       fd_csave_getname_pc			; ** FOR ORICUTRON EMULATOR
                             
c629 :                       f_open_write_start
c629 : 48               [ 3] 	pha						; Don't lose device number
c62a : a902             [ 2] 	lda #2					; Write mode
c62c : 8558             [ 3] 	sta tp_flag
c62e : 845a             [ 3] 	sty tp_delay+1
c630 : 8659             [ 3] 	stx tp_delay
c632 : a085             [ 2] 	ldy #lo(f_save_msg)
c634 : a9c5             [ 2] 	lda #hi(f_save_msg)
c636 : 2092c5           [ 6] 	jsr f_print_msg
c639 : a000             [ 2] 	ldy #lo(df_linbuff)
c63b : a904             [ 2] 	lda #hi(df_linbuff)
c63d : 2092c5           [ 6] 	jsr f_print_msg
c640 : a920             [ 2] 	lda #' '
c642 : 2099c5           [ 6] 	jsr f_print_byte
c645 : 68               [ 4] 	pla	
c646 : 20acc5           [ 6] 	jsr f_open_common		; Same as reading but tp_mode
                             
c649 :                       tt_writeleader_pc			; ** FOR ORICUTRON EMULATOR *
c649 :                       tt_writeleader_end_pc		; ** FOR ORICUTRON EMULATO
c649 : a280             [ 2] 	ldx #128				; 128 low bits
c64b : 2073c5           [ 6] 	jsr f_put_delay
                             
c64e : a924             [ 2] 	lda #'$'				; Start of header symbol
c650 : 38               [ 2] 	sec
c651 : 2070c5           [ 6] 	jsr f_write_byte
                             	
c654 : a209             [ 2] 	ldx #9					; Header, for future expansion
c656 : a9ff             [ 2] 	lda #0xff
c658 :                       f_write_header	
c658 : 38               [ 2] 	sec
c659 : 2070c5           [ 6] 	jsr f_write_byte
c65c : ca               [ 2] 	dex
c65d : d0f9             [ 3] 	bne f_write_header
                             	
c65f : a200             [ 2] 	ldx #0
c661 :                       f_write_fname
c661 : bd0004           [ 4] 	lda df_linbuff,x		; Put the filename
c664 : 38               [ 2] 	sec
c665 : 2070c5           [ 6] 	jsr f_write_byte
c668 : e8               [ 2] 	inx
c669 : c900             [ 2] 	cmp #0
c66b : d0f4             [ 3] 	bne f_write_fname
                             	
c66d : 18               [ 2] 	clc
c66e : 60               [ 6] 	rts
                             
                             
                             ;* f_put_byte
                             ;* Put to byte to tape - if got a block then save
                             
c66f :                       f_put_byte
c66f : 48               [ 3] 	pha
c670 : 8538             [ 3] 	sta tmp_d
c672 : 8a               [ 2] 	txa
c673 : 48               [ 3] 	pha
c674 : 98               [ 2] 	tya
AS65 Assembler for R6502 [1.42].                                     Page   75
---------------------------------- bank0.s -----------------------------------

c675 : 48               [ 3] 	pha
c676 : a538             [ 3] 	lda tmp_d
                             	
c678 : a457             [ 3] 	ldy tp_idx				; Save byte to buffer
c67a : 990002           [ 5] 	sta tp_buf,y
c67d : c8               [ 2] 	iny
c67e : 8457             [ 3] 	sty tp_idx
c680 : d010             [ 3] 	bne f_put_byte_done
c682 : 2099c6           [ 6] 	jsr f_put_block			; Flush block to tape
c685 : 18               [ 2] 	clc						; Increment block #
c686 : a555             [ 3] 	lda tp_block
c688 : 6901             [ 2] 	adc #1
c68a : 8555             [ 3] 	sta tp_block
c68c : a556             [ 3] 	lda tp_block+1
c68e : 6900             [ 2] 	adc #0
c690 : 8556             [ 3] 	sta tp_block+1
c692 :                       f_put_byte_done
c692 : 68               [ 4] 	pla
c693 : a8               [ 2] 	tay
c694 : 68               [ 4] 	pla
c695 : aa               [ 2] 	tax
c696 : 68               [ 4] 	pla
c697 : 18               [ 2] 	clc
c698 : 60               [ 6] 	rts
                             
                             ;* tp_put_block
                             ;* flush a block to tape
c699 :                       f_put_block
c699 : 20c6c6           [ 6] 	jsr f_print_block
                             		
c69c : a280             [ 2] 	ldx #128				; 128 low bits
c69e : 2073c5           [ 6] 	jsr f_put_delay
                             
c6a1 : a555             [ 3] 	lda tp_block			; Save block number low then high
c6a3 : 18               [ 2] 	clc
c6a4 : 2070c5           [ 6] 	jsr f_write_byte
c6a7 : a556             [ 3] 	lda tp_block+1
c6a9 : 38               [ 2] 	sec
c6aa : 2070c5           [ 6] 	jsr f_write_byte
                             
c6ad : a200             [ 2] 	ldx #0
c6af :                       f_put_block_bytes
c6af : bd0002           [ 4] 	lda tp_buf,x			; Then write out all bytes in blo
c6b2 : 18               [ 2] 	clc
c6b3 : 2070c5           [ 6] 	jsr f_write_byte
c6b6 : e8               [ 2] 	inx
c6b7 : d0f6             [ 3] 	bne f_put_block_bytes	; Always 256 bytes
                             	
c6b9 : 4c76c5           [ 3] 	jmp f_block_gap		; Wait a while, still outputtin
                             
                             ;	rts
                             
c6bc :                       f_print_block_num
c6bc : 2088c1           [ 6] 	jsr str_a_to_x
c6bf : 2099c5           [ 6] 	jsr f_print_byte
c6c2 : 8a               [ 2] 	txa
c6c3 : 4c99c5           [ 3] 	jmp f_print_byte
                             
                             ; tp_print_block
c6c6 :                       f_print_block
c6c6 : a556             [ 3] 	lda tp_block+1			; Print block number hi byte
c6c8 : 20bcc6           [ 6] 	jsr f_print_block_num
AS65 Assembler for R6502 [1.42].                                     Page   76
---------------------------------- bank0.s -----------------------------------

c6cb : a555             [ 3] 	lda tp_block			; Print block number lo byte
c6cd : 20bcc6           [ 6] 	jsr f_print_block_num
c6d0 : a9c5             [ 2] 	lda #hi(f_back4)		; Go back 4 characters to prin
c6d2 : a08d             [ 2] 	ldy #lo(f_back4)
c6d4 : 4c92c5           [ 3] 	jmp f_print_msg
                             ;	rts
                             
                             
                             ;* t_get_byte
                             ;* Get a byte from buffer - load blocks as needed
c6d7 :                       f_get_byte
c6d7 : 8a               [ 2] 	txa
c6d8 : 48               [ 3] 	pha
c6d9 : 98               [ 2] 	tya
c6da : 48               [ 3] 	pha
                             	
c6db : a457             [ 3] 	ldy tp_idx				; Index in to buffer
c6dd : d005             [ 3] 	bne f_get_byte_buf		; No need to load from tape
c6df : 20f4c6           [ 6] 	jsr f_get_block			; Else load a block from tape
c6e2 : a000             [ 2] 	ldy #0					; 0 index is now valid
c6e4 :                       f_get_byte_buf
c6e4 : b90002           [ 4] 	lda tp_buf,y			; Get from memory buffer
c6e7 : c8               [ 2] 	iny
c6e8 : 8457             [ 3] 	sty tp_idx				; Never zero on leaving
c6ea : 8538             [ 3] 	sta tmp_d
c6ec : 68               [ 4] 	pla
c6ed : a8               [ 2] 	tay
c6ee : 68               [ 4] 	pla
c6ef : aa               [ 2] 	tax
c6f0 : a538             [ 3] 	lda tmp_d
c6f2 : 18               [ 2] 	clc
c6f3 : 60               [ 6] 	rts						; Except when buffer done
                             
                             ;* f_get_block
                             ;* Load a block in to memory
c6f4 :                       f_get_block
                             
c6f4 : 206dc5           [ 6] 	jsr f_read_byte		; Get block number
c6f7 : 8555             [ 3] 	sta tp_block
c6f9 : 206dc5           [ 6] 	jsr f_read_byte
c6fc : 8556             [ 3] 	sta tp_block+1
                             	
c6fe : 20c6c6           [ 6] 	jsr f_print_block
                             	
c701 : a000             [ 2] 	ldy #0
c703 : 8457             [ 3] 	sty tp_idx
c705 :                       f_get_block_bytes
c705 : 206dc5           [ 6] 	jsr f_read_byte		; Fill buffer
c708 : a457             [ 3] 	ldy tp_idx
c70a : 990002           [ 5] 	sta tp_buf,y
c70d : c8               [ 2] 	iny
c70e : 8457             [ 3] 	sty tp_idx
c710 : d0f3             [ 3] 	bne f_get_block_bytes	; Always 256 bytes
                             
c712 : 60               [ 6] 	rts
                             	
                             
c713 :                       mod_sz_file_e
                             
                             
                             	include "file/tape.s"
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page   77
---------------------------------- bank0.s -----------------------------------

                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TAPE.S
                             ;*	These routines allow for tape input/output
                             ;*	The tape format is not compatible with a regul
                             ;*	but is a block format as follows;
                             ;*	Some zero bits (64) start a block.
                             ;*	Then two bytes of data representing the block 
                             ;*	Then 256 bytes of block data.
                             ;*	Each byte above consists of two '1' start bits
                             ;*	one '0' stop bit.
                             ;*	After each block, 1 second of 4800Hz (seen as 
                             ;*	is transmitted to allow the CPU to deal with t
                             ;*	when subsequently loading.
                             ;*	A bit is 4800Hz half cycle then 4800Hz half cy
                             ;*	'1' or 2400Hz half cycle for a '0', except for
                             ;*	block which is one second of 2400Hz.
                             ;*
                             ;************************************************
                             
                             	if !DFLATLOCI
                             
                             	; ROM code
                             	code
                             
c713 :                       mod_sz_tape_s
                             
c713 :                       tp_init
c713 : 4cfac4           [ 3] 	jmp init_via0_tape
                             
c716 :                       tp_release
c716 : 60               [ 6] 	rts
                             	
                             ; tp_put_delay
                             ;* X = number of zero bits to insert
c717 :                       tp_put_delay
c717 : 18               [ 2] 	clc
c718 : 204dc7           [ 6] 	jsr tp_write_bit
c71b : ca               [ 2] 	dex
c71c : d0f9             [ 3] 	bne tp_put_delay
c71e : 60               [ 6] 	rts
                             
                             ; tp_block_gap
                             ; Send 2400 bits of zero ~ 1.5 seconds
                             ; add 0x101 due to how counters decrement
                             ; For binary mode it is just 1 bit gap
c71f :                       tp_block_gap
c71f : a45a             [ 3] 	ldy tp_delay+1
c721 : a659             [ 3] 	ldx tp_delay
c723 :                       tp_block_gap_1
c723 : 2017c7           [ 6] 	jsr tp_put_delay
c726 : 88               [ 2] 	dey
c727 : d0fa             [ 3] 	bne tp_block_gap_1
c729 : 60               [ 6] 	rts	
                             
                             ;* tp_write_byte
                             ;* Write a byte to tape which looks like this
AS65 Assembler for R6502 [1.42].                                     Page   78
---------------------------------- bank0.s -----------------------------------

                             ;* 11xxxxxxxx0
c72a :                       tt_putbyte_pc				; ** FOR ORICUTRON EMULATOR **
c72a :                       tp_write_byte
c72a : 48               [ 3] 	pha
c72b : 08               [ 3] 	php
c72c : 38               [ 2] 	sec					; 1 for start bit
c72d : 204dc7           [ 6] 	jsr tp_write_bit
c730 : 38               [ 2] 	sec					; 1 for start bit
c731 : 204dc7           [ 6] 	jsr tp_write_bit
c734 : a008             [ 2] 	ldy #8				; 8 bits of data
c736 :                       tp_write_byte_bit
c736 : 6a               [ 2] 	ror a
c737 : 204dc7           [ 6] 	jsr tp_write_bit
c73a : 88               [ 2] 	dey
c73b : d0f9             [ 3] 	bne tp_write_byte_bit
c73d : 18               [ 2] 	clc					; 0 for stop bit
c73e : 204dc7           [ 6] 	jsr tp_write_bit
c741 : 28               [ 4] 	plp
c742 : 9007             [ 3] 	bcc tp_write_byte_nodelay
c744 : 8a               [ 2] 	txa
c745 : a220             [ 2] 	ldx #32					; Delays needed
c747 : 2017c7           [ 6] 	jsr tp_put_delay
c74a : aa               [ 2] 	tax
c74b :                       tp_write_byte_nodelay
c74b : 68               [ 4] 	pla
c74c :                       tt_putbyte_end_pc			; ** FOR ORICUTRON EMULATOR *
c74c : 60               [ 6] 	rts
                             	
                             
                             ;* tp_write_bit
                             ;* Write a bit in C to tape which looks like this
                             ;* Half cycle of 4800Hz, then
                             ;*		half cycle of 4800Hz for a 1
                             ;*		half cycle of 2400Hz for a 0
c74d :                       tp_write_bit
c74d : 48               [ 3] 	pha
c74e : 8a               [ 2] 	txa
c74f : 48               [ 3] 	pha
c750 : 08               [ 3] 	php						; Save the bit to be stored
                             
c751 : a9d0             [ 2] 	lda #TAPE_RATE			; Half cycle first of 4800Hz
c753 : a200             [ 2] 	ldx #0
c755 : 8d0603           [ 4] 	sta IO_0+T1LL
c758 : 8e0703           [ 4] 	stx IO_0+T1LH			; This starts the timer
c75b : ad0403           [ 4] 	lda IO_0+T1CL			; Clear any interrupt flag
c75e :                       tp_write_bit_chk1
c75e : 2c0d03           [ 4] 	bit IO_0+IFR			; Check IRF for bit 6
c761 : 50fb             [ 3] 	bvc tp_write_bit_chk1	; V=0? Keep checking
c763 : ad0403           [ 4] 	lda IO_0+T1CL			; Clear interrupt flag
                             	
c766 : 28               [ 4] 	plp						; Get the bit to be stored
c767 : a9d0             [ 2] 	lda #TAPE_RATE			; Assume putting out a 1 in 2nd
c769 : b002             [ 3] 	bcs tp_write_bit_t1		; A zero is half the rate (
c76b : 0a               [ 2] 	asl	a					; TAPE_RATE * 2 need to inc X
c76c : e8               [ 2] 	inx
c76d :                       tp_write_bit_t1
c76d : 8d0603           [ 4] 	sta IO_0+T1LL
c770 : 8e0703           [ 4] 	stx IO_0+T1LH			; This starts the timer
c773 : ad0403           [ 4] 	lda IO_0+T1CL			; Clear any interrupt flag
c776 :                       tp_write_bit_chk2
c776 : 2c0d03           [ 4] 	bit IO_0+IFR			; Check IRF for bit 6
c779 : 50fb             [ 3] 	bvc tp_write_bit_chk2	; V=0? Keep checking
AS65 Assembler for R6502 [1.42].                                     Page   79
---------------------------------- bank0.s -----------------------------------

c77b : ad0403           [ 4] 	lda IO_0+T1CL			; Clear interrupt flag
c77e : 68               [ 4] 	pla
c77f : aa               [ 2] 	tax
c780 : 68               [ 4] 	pla
c781 : 60               [ 6] 	rts
                             
                             
                             
                             ;* tp_read_byte
                             ;* Read a byte from tape, always expects one '1' 
c782 :                       tt_readbyte_pc				; ** FOR ORICUTRON EMULATOR **
c782 :                       tp_read_byte
c782 :                       tp_read_byte_st
c782 : 2096c7           [ 6] 	jsr tp_read_bit			; Expecting a 1
c785 : 90fb             [ 3] 	bcc tp_read_byte_st
c787 : 2096c7           [ 6] 	jsr tp_read_bit			; Should be another 1
c78a : 90f6             [ 3] 	bcc tp_read_byte_st
                             	; Ok got 2 start
                             	
c78c : a008             [ 2] 	ldy #8				; Get 8 bits
c78e :                       tp_read_byte_bits
c78e : 2096c7           [ 6] 	jsr tp_read_bit
c791 : 6a               [ 2] 	ror a
c792 : 88               [ 2] 	dey
c793 : d0f9             [ 3] 	bne tp_read_byte_bits
                             	; Byte is in A, stop bit is not waited for..
c795 :                       tt_readbyte_end_pc			; ** FOR ORICUTRON EMULATOR 
c795 : 60               [ 6] 	rts
                             
                             ;* tp_read_bit
                             ;* Get a CB1 transition and measure the time
                             ;* The measurement indicates a 1 or 0 received
c796 :                       tp_read_bit
c796 : 48               [ 3] 	pha
c797 : ad0003           [ 4] 	lda IO_0+PRB			; Clear CB1 interrupt flag by rea
c79a :                       tp_read_bit_cb1
c79a :                       tt_getsync_loop_pc			; ** FOR ORICUTRON EMULATOR 
c79a : ad0d03           [ 4] 	lda IO_0+IFR
c79d : 2910             [ 2] 	and #IFR_CB1
c79f : f0f9             [ 3] 	beq tp_read_bit_cb1		; Keep checking until CB1 a
                             
c7a1 : ad0903           [ 4] 	lda IO_0+T2CH			; Get the high byte of T2 counte
c7a4 : 48               [ 3] 	pha
c7a5 : a9ff             [ 2] 	lda #0xff				; Reset T2 counter high byte
c7a7 : 8d0903           [ 4] 	sta IO_0+T2CH			; Reset high byte of T2 counter
c7aa : 68               [ 4] 	pla						; What was previous counter?
                             ;	beq tp_io_error			; If down to zero, then some 
c7ab : c9fe             [ 2] 	cmp #0xfe				; C=1 if T2 >= 0xfe else C=0
c7ad : 68               [ 4] 	pla
c7ae : 60               [ 6] 	rts						; Carry contains the bit received
c7af :                       tp_io_error
                             	SWBRK DFERR_BREAK		; DEFINE A NEW ERROR!
                             
                             
c7b1 :                       mod_sz_tape_e
                             
                             	endif
                             	
                             	include "file/sdcard.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
AS65 Assembler for R6502 [1.42].                                     Page   80
---------------------------------- bank0.s -----------------------------------

                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  SDCARD.S
                             ;*	These routines allow for SD card input/output
                             ;*	The file format is similar to the dflat tape
                             ;*	format but is *NOT* a block format
                             ;*
                             ;*  Controlled through port A (printer port) as f
                             ;*		PA0		Clock			Out		Controlled by Oric
                             ;*		PA1		D0				In/Out	To/from Oric protocol depen
                             ;*		PA2		D1				In/Out	To/from Oric protocol depen
                             ;*		PA3		D2				In/Out	To/from Oric protocol depen
                             ;*		PA4		D3				In/Out	To/from Oric protocol depen
                             ;*		PA5		Ready (ACK)		In		Set by Arduino (1=ACK)
                             ;*		PA6		SD Select		Out		Set low by Oric
                             ;*		PA7		SD Select		Out		Set low by Oric
                             ;*		PB4		Select (STB)	Out		Set low by Oric
                             ;*
                             ;* Protocol is that PB4,6,7 must be low for SD ca
                             ;* to respond. If PB6,7 are non zero, then it sel
                             ;* one of the joysticks.
                             ;* Protocol;
                             ;* Write:
                             ;* 0) Oric: Set PB4,6,7 low - D0-D3 as output
                             ;* 1) Oric: Set D0-D3 as output (to send)
                             ;* 2) Oric: Send write command byte
                             ;* 3) Oric: Send additional bytes (e.g. filename)
                             ;* 4) Oric: Set D0-D3 as output
                             ;* 5) Oric: Send data bytes
                             ;* 6) Oric: Set PB4,6,7 = high, D0-D3 as input
                             ;* Read:
                             ;* 0) Oric: Set PB4,6,7 low - D0-D3 as output
                             ;* 1) Oric: Set D0-D3 as output (to send)
                             ;* 2) Oric: Send write command byte
                             ;* 3) Oric: Send additional bytes (e.g. filename)
                             ;* 4) Oric: Set D0-D3 as input
                             ;* 5) Oric: Receive data bytes
                             ;* 6) Oric: Set PB4,6,7 = high, D0-D3 as input
                             ;*
                             ;* Commands
                             ;* 0x00 : Load <filename><NUL>
                             ;* 0x01 : Save <filename><NUL>
                             ;************************************************
                             
                             	if !DFLATLOCI
                             	; ROM code
                             	code
                             
c7b1 :                       mod_sz_sd_s
                             
0002 =                       SD_BIT_DELAY	=	2
                             
                             ; Release the Arduino
                             ; Toggles the clock line a few times with STB hig
                             ; This causes the Arduino to reset
c7b1 :                       sd_release
c7b1 : 2042c5           [ 6] 	jsr via_strobe_off
                             ;	ldy #10
                             ;	lda IO_0+PRA;
AS65 Assembler for R6502 [1.42].                                     Page   81
---------------------------------- bank0.s -----------------------------------

                             ;sd_reset_toggle
                             ;	eor #1
                             ;	sta IO_0+PRA;
                             ;	jsr sd_delay
                             ;	dey
                             ;	bne sd_reset_toggle
c7b4 : 2006c8           [ 6] 	jsr sd_write_byte
c7b7 : 2006c8           [ 6] 	jsr sd_write_byte
c7ba : 4cfdc4           [ 3] 	jmp init_via0
                             
                             
                             ;* Select the Arduino
c7bd :                       sd_select
c7bd : 48               [ 3] 	pha
                             
                             	;set ddra to output mode initially
c7be : a9df             [ 2] 	lda #0b11011111
c7c0 : 2036c5           [ 6] 	jsr via_strobe_init
                             
                             	;deselect joystick (and zero all other bits)
c7c3 : a900             [ 2] 	lda #0b00000000
c7c5 : 8d0103           [ 4] 	sta IO_0+PRA
                             
c7c8 : 20e9c7           [ 6] 	jsr sd_delay
c7cb : 68               [ 4] 	pla
c7cc : 60               [ 6] 	rts
                             
                             
                             ; Eerror routine if Arduino does not respond in t
                             ; E.g not connected, or could not find file (for 
                             ; This is only called from sd_ready (not a jsr) a
c7cd :                       sd_timeout
c7cd : 28               [ 4] 	plp
c7ce : b002             [ 3] 	bcs sd_timeout_brk
c7d0 : 38               [ 2] 	sec							; C=1 means error
c7d1 : 60               [ 6] 	rts
c7d2 :                       sd_timeout_brk
                             	SWBRK DFERR_FNAME
                             
                             
                             
                             ;* Wait for Arduino to be ready then short delay
                             ;* C=1 means fatal error (BRK) on timeout
                             ;* If returns (i.e. no BRK) then C=1 means timeou
c7d4 :                       sd_ready_sec
c7d4 : 38               [ 2] 	sec
c7d5 :                       sd_ready
c7d5 : 08               [ 3] 	php
c7d6 : a250             [ 2] 	ldx #80
c7d8 : a000             [ 2] 	ldy #0
c7da :                       sd_notready
c7da : c8               [ 2] 	iny							; Decrement X,Y timeout
c7db : d003             [ 3] 	bne sd_ready_skipx
c7dd : ca               [ 2] 	dex
c7de : f0ed             [ 3] 	beq sd_timeout				; If X is zero then timeout er
c7e0 :                       sd_ready_skipx
c7e0 : ad0103           [ 4] 	lda IO_0+PRA				; Get port A value
c7e3 : 2920             [ 2] 	and #0b00100000				; Check bit 5
c7e5 : f0f3             [ 3] 	beq sd_notready
c7e7 : 28               [ 4] 	plp
c7e8 : 18               [ 2] 	clc							; C=0 means ok
                             	; Fall through to delay routine once ready check
AS65 Assembler for R6502 [1.42].                                     Page   82
---------------------------------- bank0.s -----------------------------------

                             
                             ;* Delay based on X register - called direct in o
c7e9 :                       sd_delay
c7e9 : 48               [ 3] 	pha
c7ea : 8a               [ 2] 	txa
c7eb : a202             [ 2] 	ldx #SD_BIT_DELAY
c7ed :                       sd_delay_loop
c7ed : ca               [ 2] 	dex
c7ee : d0fd             [ 3] 	bne sd_delay_loop
c7f0 : aa               [ 2] 	tax
c7f1 : 68               [ 4] 	pla
c7f2 : 60               [ 6] 	rts
                             
                             ; Write nibble in bit 1..4 plus clock high
c7f3 :                       sd_write_nibble
c7f3 : a000             [ 2] 	ldy #0b00000000
c7f5 : 8c0103           [ 4] 	sty IO_0+PRA				; Clock low, data low
c7f8 : 20e9c7           [ 6] 	jsr sd_delay
c7fb : 0d0103           [ 4] 	ora IO_0+PRA				; Set bits to transfer for nibbl
c7fe : 0901             [ 2] 	ora #1						; Clock high
c800 : 8d0103           [ 4] 	sta IO_0+PRA				; Send it to Port A
c803 : 4ce9c7           [ 3] 	jmp sd_delay
                             
                             
                             ;* Write a byte in A to the Arduino
c806 :                       sd_write_byte
c806 : 8538             [ 3] 	sta tmp_d
c808 : 48               [ 3] 	pha
c809 : 8a               [ 2] 	txa
c80a : 48               [ 3] 	pha
c80b : 98               [ 2] 	tya
c80c : 48               [ 3] 	pha
                             
                             	; Make sure arduino is ready, fatal error if not
c80d : 20d4c7           [ 6] 	jsr sd_ready_sec
                             
                             	; Set DDRA to output from Oric
c810 : a9df             [ 2] 	lda #0b11011111
c812 : 8d0303           [ 4] 	sta IO_0+DDRA
                             
                             	; Write low nibble
c815 : a538             [ 3] 	lda tmp_d					; Get the byte to transmit
c817 : 290f             [ 2] 	and #0x0f					; Mask off lower nibble
c819 : 0a               [ 2] 	asl a 						; Shift from bit 0-3 to bit 1-4
c81a : 20f3c7           [ 6] 	jsr sd_write_nibble
                             
                             	; Write high nibble
c81d : a538             [ 3] 	lda tmp_d					; Get the byte to transmit
c81f : 29f0             [ 2] 	and #0xf0					; Mask off upper nibble
c821 : 4a               [ 2] 	lsr a						; Shift down to bit 1-4
c822 : 4a               [ 2] 	lsr a
c823 : 4a               [ 2] 	lsr a
c824 : 20f3c7           [ 6] 	jsr sd_write_nibble
                             
c827 : 68               [ 4] 	pla
c828 : a8               [ 2] 	tay
c829 : 68               [ 4] 	pla
c82a : aa               [ 2] 	tax
                             
c82b : 68               [ 4] 	pla
c82c : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page   83
---------------------------------- bank0.s -----------------------------------

                             
                             ;* Read nibble from Arduino plus clock high
c82d :                       sd_read_nibble
c82d : a000             [ 2] 	ldy #0b00000000
c82f : 8c0103           [ 4] 	sty IO_0+PRA				; Set clock low, data low
c832 : 20e9c7           [ 6] 	jsr sd_delay				
                             
c835 : 0901             [ 2] 	ora #1						; Clock bit high
c837 : 8d0103           [ 4] 	sta IO_0+PRA				; Store it
                             
c83a : ad0103           [ 4] 	lda IO_0+PRA				; Get bits 1..4
c83d : 291e             [ 2] 	and #0b00011110				; Mask these bits
                             
c83f : 4ce9c7           [ 3] 	jmp sd_delay
                             
                             
c842 :                       sd_read_byte
c842 : 8a               [ 2] 	txa
c843 : 48               [ 3] 	pha
c844 : 98               [ 2] 	tya
c845 : 48               [ 3] 	pha
                             
                             	; Make sure arduino is ready, fatal error if not
c846 : 20d4c7           [ 6] 	jsr sd_ready_sec
                             
                             	; Set DDRA to input to Oric
c849 : a9c1             [ 2] 	lda #0b11000001
c84b : 8d0303           [ 4] 	sta IO_0+DDRA
                             
c84e : ad0103           [ 4] 	lda IO_0+PRA				; Get port A value
c851 : 29e0             [ 2] 	and #0b11100000				; Ensure clock and data is lo
c853 : a8               [ 2] 	tay							; Y is clock zero and data zero
                             
                             	; Read low nibble
c854 : 202dc8           [ 6] 	jsr sd_read_nibble
c857 : 4a               [ 2] 	lsr a						; Shift from bit 1 to bit 0
c858 : 290f             [ 2] 	and #0x0f					; Mask off lower nibble
c85a : 8538             [ 3] 	sta tmp_d					; Save in temp
                             
                             	; Read high nibble
c85c : 202dc8           [ 6] 	jsr sd_read_nibble
c85f : 0a               [ 2] 	asl a						; Shift from bit 1 to bit 4
c860 : 0a               [ 2] 	asl a
c861 : 0a               [ 2] 	asl a
c862 : 29f0             [ 2] 	and #0xf0					; Mask off upper nibble
c864 : 0538             [ 3] 	ora tmp_d					; Merge with lower nibble
c866 : 8538             [ 3] 	sta tmp_d
                             
c868 : 68               [ 4] 	pla
c869 : a8               [ 2] 	tay
c86a : 68               [ 4] 	pla
c86b : aa               [ 2] 	tax
                             
c86c : a538             [ 3] 	lda tmp_d
c86e : 60               [ 6] 	rts
                             	
                             ;* Initialise SD card
                             ;* Use TP flag to determine the command to send t
                             ;* Send this command (read or write) plus the fil
c86f :                       sd_init
c86f : a458             [ 3] 	ldy tp_flag				; 1=read, 2=write
c871 : 88               [ 2] 	dey
AS65 Assembler for R6502 [1.42].                                     Page   84
---------------------------------- bank0.s -----------------------------------

c872 : 98               [ 2] 	tya						; 0=read, 1=write for the Arduino
c873 :                       sd_init_a					; Init with A preset to command byt
c873 : 20bdc7           [ 6] 	jsr sd_select
                             ;* Send command and filename
c876 :                       sd_commandfname
c876 : 2006c8           [ 6] 	jsr sd_write_byte		; Send command byte (0=read, 
c879 : a000             [ 2] 	ldy #0					; Start of df_linbuff
c87b :                       sd_commandfname_ch
c87b : b90004           [ 4] 	lda df_linbuff,y		; Get filename char
c87e : 2006c8           [ 6] 	jsr sd_write_byte		; Send it as command frame
c881 : c8               [ 2] 	iny						; Next char
c882 : c900             [ 2] 	cmp #0					; Unless zero terminator
c884 : d0f5             [ 3] 	bne sd_commandfname_ch
                             ;* No delay for SD card
                             ;* No block gap for SD card
c886 :                       sd_put_delay
c886 :                       sd_block_gap
c886 : 60               [ 6] 	rts
                             
                             
                             ;* Delete file from SD card
c887 :                       sd_delete
c887 : a903             [ 2] 	lda #3					; Send Delete command
c889 : 2073c8           [ 6] 	jsr sd_init_a			; And send filename to delete
c88c : 20d4c7           [ 6] 	jsr sd_ready_sec		; Check SD card is ready else 
c88f : 4cb1c7           [ 3] 	jmp sd_release			; Then done
                             
                             ;* Ouput directory listing
c892 :                       sd_dir
c892 : 20bdc7           [ 6] 	jsr sd_select
c895 : a904             [ 2] 	lda #4					; Send directory command
c897 : 2006c8           [ 6] 	jsr sd_write_byte
c89a : 20e9c7           [ 6] 	jsr sd_delay
c89d :                       sd_dir_char					; Keep getting bytes from Arduino
c89d : 20e9c7           [ 6] 	jsr sd_delay
c8a0 : 2042c8           [ 6] 	jsr sd_read_byte
c8a3 : 20e6d0           [ 6] 	jsr gr_put_byte
c8a6 : aa               [ 2] 	tax
c8a7 : d0f4             [ 3] 	bne sd_dir_char			; Until zero terminator found
c8a9 : 4cb1c7           [ 3] 	jmp sd_release			; Then done
                             	
                             
                             
c8ac :                       mod_sz_sd_e
                             
                             	endif
                             
                             	include "file/locisd.s"
                             
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2024
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  LOCISD.S
                             ;*	Routines to use LOCI SD card storage.
                             ;*	The file format is similar to the dflat tape
                             ;************************************************
                             	if DFLATLOCI
AS65 Assembler for R6502 [1.42].                                     Page   85
---------------------------------- bank0.s -----------------------------------

                             	; ROM code
                             	code
                             
                             mod_sz_lc_s
                             
                             ; Using extended RAM to keep current path
                             ; Page aligned
                             XMEM		=	0x4000
                             XMEMDIRPATH	=	(XMEM)
                             
                             	include "file/loci.i"
                             
                             loci_default_path
                             	db	":/dflat/",0
                             loci_dir_str
                             	db	"<DIR>",0
                             
                             ; a=high address, x=low address
                             ; step = 1 default
                             ; y=0 on return
                             lc_init_xmempath
                             	ldy #hi(XMEMDIRPATH)
                             	sty MIA_ADDR0+1
                             	ldy #1
                             	sty MIA_STEP0
                             	dey
                             	sty MIA_ADDR0
                             ; Convenient place for labels with immediate rts
                             lc_block_gap
                             lc_put_delay
                             	rts
                             
                             ; Copy filedes to MIA A,X
                             lc_fd_to_mia_ax
                             	lda lc_fildes
                             	sta MIA_A
                             	lda lc_fildes+1
                             	sta MIA_X
                             	rts
                             
                             ; Starting directory for dflat in LOCI
                             lc_init_path
                             	jsr lc_init_xmempath
                             	ldx #'1'							; Default device=1
                             	clc
                             	jsr gr_get_key
                             	bcs lc_init_path_skip_dev
                             	tax									; Use this key as device number
                             lc_init_path_skip_dev
                             	stx MIA_RW0
                             lc_init_path_ch
                             	iny
                             	lda loci_default_path-1,y
                             	sta MIA_RW0
                             	bne lc_init_path_ch
                             	rts
                             
                             ; Close open file or directory
                             lc_release
                             	jsr lc_fd_to_mia_ax
                             	lda #MIA_OP_CLOSEDIR
                             	ldx tp_flag
AS65 Assembler for R6502 [1.42].                                     Page   86
---------------------------------- bank0.s -----------------------------------

                             	beq lc_release_dir
                             	lda #MIA_OP_CLOSE
                             lc_release_dir
                             	sta MIA_OP
                             	jmp lc_op_wait
                             
                             ; Read byte
                             ; Only saves X (as Y not touched)
                             ; A=byte read from file
                             lc_read_byte
                             	stx tmp_d					; Save X in tmp_d
                             
                             	lda #0xd					; Assume CR (meaning directory)
                             	ldx tp_flag					; If tp_flag zero then this is a
                             	beq lc_read_byte_dir
                             	ldx #0						; Count hi = 0
                             	stx MIA_XSTACK
                             	inx							; Count lo = 1 (inefficient!)
                             	stx MIA_XSTACK
                             	jsr lc_fd_to_mia_ax
                             	lda #MIA_OP_READ_XSTACK		; Ok do a read of just 
                             	jsr lc_op_wait
                             	lda MIA_XSTACK				; Get the byte from the stack
                             lc_read_byte_dir				; If dir then skip all that
                             
                             	ldx tmp_d					; Get X back
                             	rts
                             
                             ; Write byte to file
                             ; only uses A,X (Y not touched)
                             lc_write_byte
                             	pha
                             	stx tmp_d
                             
                             	sta MIA_XSTACK
                             	jsr lc_fd_to_mia_ax
                             	lda #MIA_OP_WRITE_XSTACK	; Ok do a write of just
                             	jsr lc_op_wait
                             
                             	pla
                             	ldx tmp_d
                             	rts
                             
                             ; A = MIA op code
                             ; Waits until MIA ready
                             lc_op_wait
                             	sta MIA_OP
                             	jmp MIA_SPIN
                             
                             ; A = MIA op code
                             ; Waits until MIA ready
                             ; put A,X in filedes
                             lc_op_wait_fd
                             	jsr lc_op_wait
                             	sta lc_fildes				; Save A,X from MIA op call
                             	stx lc_fildes+1
                             	rts
                             
                             lc_push_dir_path
                             	jsr lc_init_xmempath
                             lc_find_dir_path_end
                             	iny
AS65 Assembler for R6502 [1.42].                                     Page   87
---------------------------------- bank0.s -----------------------------------

                             	lda MIA_RW0
                             	bne lc_find_dir_path_end
                             	dey							; Go back to the zero
                             	sty MIA_ADDR0				; set addr low
                             	lda #255					; -ve step
                             	sta MIA_STEP0
                             	lda MIA_RW0					; Step back xmem ptr too
                             lc_dir_path_push_ch
                             	lda MIA_RW0
                             	sta MIA_XSTACK
                             	dey
                             	bne lc_dir_path_push_ch
                             lc_dir_path_done
                             	rts
                             
                             ; Push filename onto MIA XSTACK
                             lc_push_fname
                             	ldy #0
                             lc_init_findend
                             	iny
                             	lda df_linbuff-1,y
                             	bne lc_init_findend
                             lc_push_fnchar					; Push in reverse order
                             	lda df_linbuff-1,y
                             	sta MIA_XSTACK
                             	dey
                             	bne lc_push_fnchar
                             	jsr lc_push_dir_path		; Also push path in revers
                             	rts
                             
                             ; Get a filehandle from MIA
                             ; Could be a file or a directory
                             ; If a directory can only be read mode tp_flag se
                             lc_init
                             	jsr lc_push_fname
                             	lda #0
                             	sta MIA_X					; Zero
                             	lda tp_flag					; 1=Read, 2=Write
                             	cmp #2						; If write
                             	bne lc_init_skip_create
                             	ora #0x10					; Create file if not exists
                             lc_init_skip_create	
                             	sta MIA_A
                             	lda #MIA_OP_OPEN			; Try to open file first
                             	jsr lc_op_wait_fd
                             	cmp #255					; if error try to open dir
                             	bne lc_init_done			; else done
                             	lda tp_flag					; but only if reading
                             	cmp #1
                             	bne lc_init_error
                             	jsr lc_push_fname
                             	lda #MIA_OP_OPENDIR
                             	jsr lc_op_wait_fd
                             	cmp #255					; if error try to open dir
                             	beq lc_init_error
                             	jsr lc_init_xmempath		; dir is valid so add to p
                             	sty tp_flag					; Y already zero from xmem init
                             	lda df_linbuff				; if the dir '/' ?
                             	cmp #'/'
                             	bne lc_init_dir_end
                             	jmp lc_init_path			; Then back to dflat root
                             lc_init_dir_end
AS65 Assembler for R6502 [1.42].                                     Page   88
---------------------------------- bank0.s -----------------------------------

                             	iny
                             	lda MIA_RW0
                             	bne lc_init_dir_end
                             	ldx #0
                             	dey							; Overwrite the zero in xmem0
                             	sty MIA_ADDR0
                             lc_init_dir_append
                             	lda df_linbuff,x
                             	beq lc_init_dir_term
                             	sta MIA_RW0
                             	inx
                             	bne lc_init_dir_append
                             lc_init_dir_term				; Finally add '/' and zero te
                             	lda #'/'
                             	sta MIA_RW0
                             	lda #0
                             	sta MIA_RW0
                             lc_init_done
                             	rts
                             lc_init_error
                             	SWBRK DFERR_FNAME
                             
                             sd_delete
                             	jsr lc_push_fname
                             	lda #MIA_OP_UNLINK
                             	jsr lc_op_wait
                             	cmp #255
                             	beq lc_init_error
                             	rts
                             
                             sd_dir
                             	lda #0								; No filename
                             	sta df_linbuff
                             	sta tp_flag							; Also no file mode
                             	jsr lc_push_fname					; Just push current dir
                             	ldy #0
                             	sta MIA_X							; Zero
                             	iny									; 1=read
                             	sty MIA_A
                             	lda #MIA_OP_OPENDIR
                             	jsr lc_op_wait_fd
                             	cmp #255							; Didn't open?
                             	beq lc_init_error					; Then error
                             sd_dir_read_entry
                             	jsr lc_fd_to_mia_ax
                             	lda #MIA_OP_READDIR					; Try to read entry
                             	jsr lc_op_wait
                             	ldy #0								; Pop entry off stack
                             sd_get_entry
                             	lda MIA_XSTACK						; Get a byte
                             	sta df_linbuff,y					; Save to memory
                             	iny
                             	cpy #dirent							; For size of directory entry
                             	bne sd_get_entry
                             	ldy #lo(df_linbuff+dirent_name)		; ptr to filena
                             	lda #hi(df_linbuff+dirent_name+1)
                             	jsr gr_print_line					; print the filename
                             	cpy #0								; Nothing was printed?
                             	beq sd_dir_end
                             sd_dir_padding
                             	jsr utilPrintSPC
                             	iny
AS65 Assembler for R6502 [1.42].                                     Page   89
---------------------------------- bank0.s -----------------------------------

                             	cpy #25
                             	bne sd_dir_padding
                             	ldx df_linbuff+dirent_size			; Low byte of size
                             	lda df_linbuff+dirent_size+1		; High byte of siz
                             	clc
                             	jsr int_to_str
                             	lda df_linbuff+dirent_attrib		; Directory?
                             	and #0x20							; Attribute bit for file
                             	bne sd_dir_not_folder
                             	tax
                             sd_dir_stuff_ch
                             	inx
                             	lda loci_dir_str-1,x
                             	sta num_buf-1,x
                             	bne sd_dir_stuff_ch
                             sd_dir_not_folder
                             	ldy #lo(num_buf)
                             	lda #hi(num_buf)
                             	jsr gr_print_line
                             	jsr utilPrintCRLF
                             	jmp sd_dir_read_entry
                             sd_dir_end
                             	jmp lc_release
                             
                             mod_sz_lc_e
                             
                             	endif
                             	include "keyboard/keyboard.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  KEYBOARD.S
                             ;*	Keyboard driver code. It is very slow to scan 
                             ;*	routines here do a basic scan for any key befo
                             ;*	the specific key. Still, it has a noticeable i
                             ;*	CPU especially in dflat which checks the key a
                             ;*	keyword is executed.
                             ;*	Rather than working off interrupts these routi
                             ;*	need to be called as needed. The T1 interrupt 
                             ;*	track of keyboard timers for repeat delay and 
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* init_keyboard
                             ;* Initialise the keyboard settings
                             ;****************************************
c8ac :                       init_keyboard
c8ac : a914             [ 2] 	lda #KB_REP_DEL
c8ae : 8531             [ 3] 	sta kb_rdel_tim
c8b0 : a903             [ 2] 	lda #KB_REP_TIM
c8b2 : 8530             [ 3] 	sta kb_rep_tim
c8b4 : a901             [ 2] 	lda #KB_DEBOUNCE
c8b6 : 852e             [ 3] 	sta kb_deb_tim
AS65 Assembler for R6502 [1.42].                                     Page   90
---------------------------------- bank0.s -----------------------------------

                             
                             	; ** check if IJK stick connected **
c8b8 : 08               [ 3] 	php
c8b9 : 78               [ 2] 	sei
                             	; Save port A
c8ba : ad0303           [ 4] 	lda IO_0+DDRA
c8bd : 48               [ 3] 	pha
c8be : ad0103           [ 4] 	lda IO_0+PRA
c8c1 : 48               [ 3] 	pha
                             
                             	; Check IJK present
                             	; set top two bits of porta to output and rest a
c8c2 : a9c0             [ 2] 	lda   #0b11000000
c8c4 : 2036c5           [ 6] 	jsr via_strobe_init
                             	; Select left+right stick
c8c7 : a9c0             [ 2] 	lda #0b11000000
c8c9 : 8d0f03           [ 4] 	sta IO_0+PRAH
                             	; read stick sense line
c8cc : ad0f03           [ 4] 	lda IO_0+PRAH
c8cf : 2920             [ 2] 	and #KB_IJK
c8d1 : 4920             [ 2] 	eor #KB_IJK
c8d3 : 852c             [ 3] 	sta kb_stat
c8d5 : 2042c5           [ 6] 	jsr via_strobe_off
                             
                             	; Restore port A
c8d8 : 68               [ 4] 	pla
c8d9 : 8d0103           [ 4] 	sta IO_0+PRA
c8dc : 68               [ 4] 	pla
c8dd : 8d0303           [ 4] 	sta IO_0+DDRA
                             
c8e0 : 28               [ 4] 	plp
c8e1 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* kb_stick
                             ;* Check for fire | down | up | right | left
                             ;*        bit  4     3      2     1       0
                             ;* A = Returns bit mask of keys pressed
                             ;* Y corrupted
                             ;****************************************
c8e2 :                       kb_stick
                             	; if IJK connected then read joystick
c8e2 : a52c             [ 3] 	lda kb_stat
c8e4 : 2920             [ 2] 	and #KB_IJK
c8e6 : d028             [ 4] 	bne kb_stick_ijk
                             
                             	; Select Row 4 only, all keys on this row
c8e8 : a9b4             [ 2] 	lda #4+KB_PRB			; Maintain upper nibble of PRB
c8ea : 8d0003           [ 4] 	sta IO_0+PRB
c8ed : a90e             [ 2] 	lda #SND_REG_IOA		; Select AY Port A for columns
c8ef : 204ec0           [ 6] 	jsr snd_sel_reg
c8f2 : a900             [ 2] 	lda #0					; Result will be in A
c8f4 : 48               [ 3] 	pha
c8f5 : a004             [ 2] 	ldy #4					; Go through the 5 cols on row 4
c8f7 :                       kb_stick_pos
c8f7 : b9f7ca           [ 4] 	lda kb_stick_mask,y		; Get the column mask
c8fa : 205ec0           [ 6] 	jsr snd_set_reg			; Activate column
c8fd : ea               [ 2] 	nop
c8fe : ea               [ 2] 	nop
c8ff : ea               [ 2] 	nop
c900 : ea               [ 2] 	nop
AS65 Assembler for R6502 [1.42].                                     Page   91
---------------------------------- bank0.s -----------------------------------

c901 : a908             [ 2] 	lda #KB_SENSE			; Something pressed?
c903 : 2d0003           [ 4] 	and IO_0+PRB			; Read Port B
c906 : c908             [ 2] 	cmp #KB_SENSE			; C=1 if set else 0
c908 : 68               [ 4] 	pla
c909 : 2a               [ 2] 	rol a					; Get C in to A
c90a : 48               [ 3] 	pha
c90b : 88               [ 2] 	dey
c90c : 10e9             [ 4] 	bpl kb_stick_pos		; Do all 5 positions
c90e : 68               [ 4] 	pla						; Result in A
c90f : 60               [ 6] 	rts
c910 :                       kb_stick_ijk
c910 : 08               [ 3] 	php
c911 : 78               [ 2] 	sei
                             
                             	; Save port A
c912 : ad0303           [ 4] 	lda IO_0+DDRA
c915 : 48               [ 3] 	pha
c916 : ad0103           [ 4] 	lda IO_0+PRA
c919 : 48               [ 3] 	pha
                             
                             	;set top two bits of porta to output and rest as
c91a : a9c0             [ 2] 	lda   #0b11000000
c91c : 2036c5           [ 6] 	jsr via_strobe_init
                             
                             	;Select Left Joystick
c91f : a97f             [ 2] 	lda #0b01111111
c921 : 8d0103           [ 4] 	sta IO_0+PRA
                             	;Read back Left Joystick state into A
c924 : ad0103           [ 4] 	lda IO_0+PRA
                             	; release joystick IO settings
c927 : 2042c5           [ 6] 	jsr via_strobe_off
                             	;Mask out unused bits and invert
c92a : 291f             [ 2] 	and #0b00011111
c92c : 491f             [ 2] 	eor #0b00011111
c92e : a8               [ 2] 	tay
                             	; use this as an index into the mapping
                             	; to get the same bit representation
                             	; as if using cursor and space keys
c92f : b9fcca           [ 4] 	lda kb_ijk_map,y
c932 : a8               [ 2] 	tay
                             
                             	; Restore port A
c933 : 68               [ 4] 	pla
c934 : 8d0103           [ 4] 	sta IO_0+PRA
c937 : 68               [ 4] 	pla
c938 : 8d0303           [ 4] 	sta IO_0+DDRA
                             
c93b : 28               [ 4] 	plp
                             	; result in A
c93c : 98               [ 2] 	tya
c93d : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* kb_any_key
                             ;* Quick check for any key except shifts & ctrl
                             ;* Carry = 1 means key pressed
                             ;****************************************
c93e :                       kb_any_key
c93e : a90e             [ 2] 	lda #SND_REG_IOA		; Select Port A of AY
c940 : 204ec0           [ 6] 	jsr snd_sel_reg
                             
AS65 Assembler for R6502 [1.42].                                     Page   92
---------------------------------- bank0.s -----------------------------------

c943 : a0b7             [ 2] 	ldy #7+KB_PRB			; Start from row 7
c945 :                       kb_any_key_row
c945 : 8c0003           [ 4] 	sty IO_0+PRB			; Select row on port B
                             	; Select all columns except 4
c948 : a910             [ 2] 	lda #0b00010000			; Deselect only col 4
c94a : 205ec0           [ 6] 	jsr snd_set_reg
                             
c94d : ea               [ 2] 	nop
c94e : ea               [ 2] 	nop
c94f : ea               [ 2] 	nop						; New NOP
c950 : ea               [ 2] 	nop
c951 : ea               [ 2] 	nop
                             ;	nop						; New NOP
                             
c952 : a908             [ 2] 	lda #KB_SENSE			; Something pressed?
c954 : 2d0003           [ 4] 	and IO_0+PRB			; Read Port B
c957 : d007             [ 3] 	bne kb_any_key_pressed
c959 : 88               [ 2] 	dey						; If not then next row
c95a : c0af             [ 2] 	cpy #KB_PRB-1			; Done rows 0..8?
c95c : d0e7             [ 3] 	bne kb_any_key_row		; Until all rows done
c95e :                       kb_any_key_none
c95e : 18               [ 2] 	clc						; C=0 means not pressed
c95f : 60               [ 6] 	rts
c960 :                       kb_any_key_pressed
c960 :                       kb_read_got
c960 : 38               [ 2] 	sec						; C=1 means pressed, Y=Row number
c961 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* kb_read_raw
                             ;* Read keyboard
                             ;* Y = Keyboard code
                             ;* Carry = 1 means key found, 0 = no keys found
                             ;****************************************
c962 :                       kb_read_raw
c962 : 203ec9           [ 6] 	jsr kb_any_key			; Quick check is anything down?
c965 : 903f             [ 3] 	bcc kb_read_nothing		; Don't bother if not
                             ;kb_read_raw_force
c967 : a20e             [ 2] 	ldx #SND_REG_IOA		; Select Port A of AY
c969 : 8e0f03           [ 4] 	stx SND_ADBUS			; Put reg # on Port A (sound bus
c96c : a2ff             [ 2] 	ldx #SND_SELSETADDR		; Get ready to select the r
c96e : 8e0c03           [ 4] 	stx SND_MODE			; Latch the reg # on Port A
c971 : a2dd             [ 2] 	ldx #SND_DESELECT		; Deselect AY
c973 : 8e0c03           [ 4] 	stx SND_MODE
c976 : a200             [ 2] 	ldx #0					; Start at column 0
c978 : 86ac             [ 3] 	stx zp_tmp1
c97a :                       kb_check_matrix_col
                             ;	ldy #0+KB_PRB			; Start at row 0 (maintain PRB 
c97a :                       kb_check_matrix_row
c97a : 8c0003           [ 4] 	sty IO_0+PRB			; Select row from Y
                             	; Get the col value for AY port A
c97d : a6ac             [ 3] 	ldx zp_tmp1
c97f : bdefca           [ 4] 	lda kb_col_mask,x
                             	; Write it to AY port A
c982 : 8d0f03           [ 4] 	sta SND_ADBUS			; Put col value on AY bus
c985 : a2fd             [ 2] 	ldx #SND_SELWRITE		; Select mode for writing dat
c987 : 8e0c03           [ 4] 	stx SND_MODE			; Latch reg value on Port A
c98a : a2dd             [ 2] 	ldx #SND_DESELECT		; Deselect AY
c98c : 8e0c03           [ 4] 	stx SND_MODE
                             
c98f : ea               [ 2] 	nop						; Wait 10 cycles before reading sense p
c990 : ea               [ 2] 	nop
AS65 Assembler for R6502 [1.42].                                     Page   93
---------------------------------- bank0.s -----------------------------------

c991 : ea               [ 2] 	nop
                             
c992 : a908             [ 2] 	lda #KB_SENSE			; Bit 3 is the sense
c994 : 2d0003           [ 4] 	and IO_0+PRB			; And with Port B
                             
c997 : d011             [ 3] 	bne kb_read_raw_got
                             	; No key for this row/col, next
                             ;	iny
                             ;	cpy #8+KB_PRB			; Done 8 rows?
                             ;	bne kb_check_matrix_row
                             	; ok check next row
c999 : a6ac             [ 3] 	ldx zp_tmp1
c99b :                       kb_check_skip4
c99b : e8               [ 2] 	inx
c99c : e004             [ 2] 	cpx #4					; Skip 4?
c99e : f0fb             [ 3] 	beq kb_check_skip4
c9a0 : 86ac             [ 3] 	stx zp_tmp1
c9a2 : e008             [ 2] 	cpx #8					; Done 8 cols?
c9a4 : d0d4             [ 3] 	bne kb_check_matrix_col
                             	; No key was sensed
c9a6 :                       kb_read_nothing
c9a6 : a000             [ 2] 	ldy #0					; Raw key codes
c9a8 : 18               [ 2] 	clc						; No key sensed flag
c9a9 : 60               [ 6] 	rts
c9aa :                       kb_read_raw_got
                             	;Y=row, zp_temp1=col
c9aa : a5ac             [ 3] 	lda zp_tmp1				; Get the column num
c9ac : 0a               [ 2] 	asl a					; Shift in to bits 5,4,3
c9ad : 0a               [ 2] 	asl a
c9ae : 0a               [ 2] 	asl a
c9af : 85ac             [ 3] 	sta zp_tmp1
c9b1 : 98               [ 2] 	tya						; Now or with row number
c9b2 : 2907             [ 2] 	and #7					; Only bottom 3 bits!
c9b4 : 05ac             [ 3] 	ora zp_tmp1
c9b6 : a8               [ 2] 	tay						; Put in to Y
c9b7 : 38               [ 2] 	sec
c9b8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* kb_scan_key
                             ;* Scans for a key, returns zero for no key found
                             ;* Processes caps and shift lock but these don't 
                             ;* A = Key code
                             ;****************************************
c9b9 :                       kb_scan_key
c9b9 : a52d             [ 3] 	lda kb_deb				; Do not scan keyboard too often
c9bb : d013             [ 3] 	bne kb_no_scan
c9bd : a52e             [ 3] 	lda kb_deb_tim			; Else reset debounce timer
c9bf : 852d             [ 3] 	sta kb_deb
c9c1 : 2062c9           [ 6] 	jsr kb_read_raw			; Check if a key is sensed
c9c4 : b00e             [ 3] 	bcs kb_scan_decode		; go ahead and decode
                             	; If pressed nothing then reset timers
c9c6 : a9ff             [ 2] 	lda #255
c9c8 : 8529             [ 3] 	sta kb_raw				; Reset raw key settings
c9ca : 852a             [ 3] 	sta kb_last				; And last key
c9cc : a531             [ 3] 	lda kb_rdel_tim			; Reset repeat timer to initia
c9ce : 852f             [ 3] 	sta kb_rep
c9d0 :                       kb_no_scan
c9d0 : a900             [ 2] 	lda #0
c9d2 : 38               [ 2] 	sec						; Code not valid
c9d3 : 60               [ 6] 	rts						; And done (A=0)
c9d4 :                       kb_scan_decode
AS65 Assembler for R6502 [1.42].                                     Page   94
---------------------------------- bank0.s -----------------------------------

                             	; If got here then raw key is good
c9d4 : a52a             [ 3] 	lda kb_last				; Preload A with last decoded key
c9d6 : c429             [ 3] 	cpy kb_raw				; Same as last raw key?
c9d8 : 8429             [ 3] 	sty kb_raw				; Already save new raw key
c9da : d002             [ 3] 	bne kb_process_new		; If is new raw key, look at
c9dc : f061             [ 4] 	beq kb_do_repeat		; Else go handle repeating wit
c9de :                       kb_process_new
c9de : a531             [ 3] 	lda kb_rdel_tim			; Reset repeat timer to initia
c9e0 : 852f             [ 3] 	sta kb_rep
                             	; Now to get a proper key code translated from r
                             	; Check for shift and ctrl (not debounced!)
c9e2 : a9ef             [ 2] 	lda #0b11101111			; Select column 4
c9e4 : a20e             [ 2] 	ldx #SND_REG_IOA		; On AY port A
c9e6 : 206ec0           [ 6] 	jsr snd_set
                             
                             	; check shifted keys
c9e9 : a2b4             [ 2] 	ldx #4+KB_PRB			; Row 4 (left shift)
c9eb : 8e0003           [ 4] 	stx IO_0+PRB			; Select row on port B
c9ee : ea               [ 2] 	nop
c9ef : ea               [ 2] 	nop
c9f0 : ea               [ 2] 	nop
c9f1 : ea               [ 2] 	nop
                             
c9f2 : ad0003           [ 4] 	lda IO_0+PRB			; Read Port B
                             
c9f5 : a2b7             [ 2] 	ldx #7+KB_PRB			; Row 7 (right shift)
c9f7 : 8e0003           [ 4] 	stx IO_0+PRB			; Select row on port B
c9fa : ea               [ 2] 	nop
c9fb : ea               [ 2] 	nop
c9fc : ea               [ 2] 	nop
c9fd : ea               [ 2] 	nop
                             
c9fe : 0d0003           [ 4] 	ora IO_0+PRB			; Combine Port B
ca01 : be6fca           [ 4] 	ldx kb_table_std,y		; Pre-load standard key code
ca04 : 2908             [ 2] 	and #KB_SENSE			; Bit 3 is the sense
ca06 : f003             [ 3] 	beq kb_read_noshift		; Skip over if no shift
ca08 : beafca           [ 4] 	ldx kb_table_shift,y	; Load up standard key code
ca0b :                       kb_read_noshift
ca0b : 862b             [ 3] 	stx kb_code				; Save the mapped keycode
                             	; check ctrl key
ca0d : a2b2             [ 2] 	ldx #2+KB_PRB			; Row 2 (ctrl key)
ca0f : 8e0003           [ 4] 	stx IO_0+PRB			; Select row on port B
ca12 : ea               [ 2] 	nop
ca13 : ea               [ 2] 	nop
ca14 : ea               [ 2] 	nop
ca15 : ea               [ 2] 	nop
                             
ca16 : ad0003           [ 4] 	lda IO_0+PRB			; Read Port B
ca19 : 2908             [ 2] 	and #KB_SENSE
ca1b : f00a             [ 3] 	beq kb_skip_ctrl
ca1d : a52b             [ 3] 	lda kb_code
ca1f : 291f             [ 2] 	and #0x1f				; Ctrl will result in codes 0 to 31
ca21 : 852b             [ 3] 	sta kb_code				; Override the keycode
ca23 : f02a             [ 3] 	beq kb_brk
ca25 : 1020             [ 3] 	bpl	kb_store_last		; Check repeat (bpl is always
ca27 :                       kb_skip_ctrl
ca27 : a52c             [ 3] 	lda kb_stat				; Check caps lock
ca29 : 2901             [ 2] 	and #KB_CAPSLK
ca2b : f01a             [ 3] 	beq kb_store_last
ca2d : a52b             [ 3] 	lda kb_code
ca2f : c961             [ 2] 	cmp #'a'				; If < 'a' then skip
ca31 : 9014             [ 3] 	bcc kb_store_last
AS65 Assembler for R6502 [1.42].                                     Page   95
---------------------------------- bank0.s -----------------------------------

ca33 : c97b             [ 2] 	cmp #'z'+1				; If > 'z' then skip
ca35 : b010             [ 3] 	bcs kb_store_last
ca37 : a52b             [ 3] 	lda kb_code				; Get the actual code
ca39 : 4920             [ 2] 	eor #0x20				; Switch off bit 0x20
ca3b : 852b             [ 3] 	sta kb_code				; Save the capitalised code
ca3d : d008             [ 3] 	bne kb_store_last		; always
ca3f :                       kb_do_repeat
ca3f : a62f             [ 3] 	ldx kb_rep				; Has repeat expired?
ca41 : d008             [ 3] 	bne	kb_in_repeat		; If not then still in repeat
ca43 : a630             [ 3] 	ldx kb_rep_tim			; Set repeat speed
ca45 : 862f             [ 3] 	stx kb_rep
ca47 :                       kb_store_last
ca47 : 852a             [ 3] 	sta kb_last				; Make last code same as this
ca49 : 18               [ 2] 	clc						; Code valid
ca4a : 60               [ 6] 	rts
ca4b :                       kb_in_repeat
ca4b : a900             [ 2] 	lda #0					; Don't emit a keycode
ca4d : 38               [ 2] 	sec
ca4e : 60               [ 6] 	rts
ca4f :                       kb_brk
                             	SWBRK DFERR_OK
                             
                             
                             ;****************************************
                             ;* kb_get_key
                             ;* Waits for a key press, C=1 synchronous
                             ;* A = Key code, C=1 means valid
                             ;****************************************
ca51 :                       kb_get_key
ca51 : 8a               [ 2] 	txa
ca52 : 48               [ 3] 	pha
ca53 : 98               [ 2] 	tya
ca54 : 48               [ 3] 	pha
                             
ca55 :                       kb_get_try
ca55 : 08               [ 3] 	php
ca56 : 20b9c9           [ 6] 	jsr kb_scan_key
ca59 : 900b             [ 3] 	bcc kb_scan_got_key
ca5b : 28               [ 4] 	plp						; No key, so check C
ca5c : b0f7             [ 3] 	bcs kb_get_try			; Keep looking if C
ca5e : 38               [ 2] 	sec						; Indicate key not valid
                             
ca5f : 68               [ 4] 	pla
ca60 : a8               [ 2] 	tay
ca61 : 68               [ 4] 	pla
ca62 : aa               [ 2] 	tax
ca63 : a900             [ 2] 	lda #0
                             
ca65 : 60               [ 6] 	rts
ca66 :                       kb_scan_got_key
ca66 : 28               [ 4] 	plp						; Pull stack
ca67 : 18               [ 2] 	clc						; Indicate key valid
                             
ca68 : 68               [ 4] 	pla
ca69 : a8               [ 2] 	tay
ca6a : 68               [ 4] 	pla
ca6b : aa               [ 2] 	tax
                             
ca6c : a52b             [ 3] 	lda kb_code
                             
ca6e : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page   96
---------------------------------- bank0.s -----------------------------------

                             ;****************************************
                             ;* kb_table_std (no shift)
                             ;* Each line is one column
                             ;****************************************
ca6f :                       kb_table_std
ca6f : 376a6d6b20757938      	db '7' ,'j' ,'m' ,'k' ,' ' ,'u' ,'y' ,'8'
ca77 : 6e7436392c69686c      	db 'n' ,'t' ,'6' ,'9' ,',' ,'i' ,'h' ,'l'
ca7f : 3572623b2e6f6730      	db '5' ,'r' ,'b' ,';' ,'.' ,'o' ,'g' ,'0'
ca87 : 7666342d0b70652f      	db 'v' ,'f' ,'4' ,'-' ,0x0b,'p' ,'e' ,'/'
ca8f : 0000000000000000      	db 0,0,0,0,0,0,0,0 ; Column 4 is shift and ctrl 
ca97 : 311b7a00087f610d      	db '1' ,0x1b,'z' ,0   ,0x08,0x7f,'a' ,0x0d
ca9f : 7871325c0a5d7300      	db 'x' ,'q' ,'2' ,0x5c,0x0a,']' ,'s' ,0
caa7 : 33646327095b773d      	db '3' ,'d' ,'c' ,0x27,0x09,'[' ,'w' ,'='
                             
                             ;* kb_table_shift (with shift)
caaf :                       kb_table_shift
caaf : 264a4d4b2055592a      	db '&' ,'J' ,'M' ,'K' ,' ' ,'U' ,'Y' ,'*'
cab7 : 4e545e283c49484c      	db 'N' ,'T' ,'^' ,'(' ,'<' ,'I' ,'H' ,'L'
cabf : 2552423a3e4f4729      	db '%' ,'R' ,'B' ,':' ,'>' ,'O' ,'G' ,')'
cac7 : 5646245f0b50453f      	db 'V' ,'F' ,'$' ,'_' ,0x0b,'P' ,'E' ,'?'
cacf : 0000000000000000      	db 0,0,0,0,0,0,0,0 ; Column 4 is shift and ctrl 
cad7 : 211b5a00087f410d      	db '!' ,0x1b,'Z' ,0   ,0x08,0x7f,'A' ,0x0d
cadf : 5851407c0a7d5300      	db 'X' ,'Q' ,'@' ,'|' ,0x0a,'}' ,'S' ,0
cae7 : 23444322097b572b      	db '#' ,'D' ,'C' ,0x22,0x09,'{' ,'W' ,'+'
                             
caef :                       kb_col_mask
caef : fe                    	db 0b11111110
caf0 : fd                    	db 0b11111101
caf1 : fb                    	db 0b11111011
caf2 : f7                    	db 0b11110111
caf3 : ef                    	db 0b11101111
caf4 : df                    	db 0b11011111
caf5 : bf                    	db 0b10111111
caf6 : 7f                    	db 0b01111111
                             
caf7 :                       kb_stick_mask
caf7 : df                    	db 0b11011111		; Left 	= Bit 0
caf8 : 7f                    	db 0b01111111		; Right = Bit 1
caf9 : f7                    	db 0b11110111		; Up	= Bit 2
cafa : bf                    	db 0b10111111		; Down	= Bit 3
cafb : fe                    	db 0b11111110		; Space	= Bit 4
                             
cafc :                       kb_ijk_map
cafc : 00                    	db 0b00000000		; 00000 = nothing
cafd : 02                    	db 0b00000010		; 00001 = right
cafe : 01                    	db 0b00000001		; 00010 = left
caff : 03                    	db 0b00000011		; 00011 = left+right
cb00 : 10                    	db 0b00010000		; 00100 = fire
cb01 : 12                    	db 0b00010010		; 00101 = fire+right
cb02 : 11                    	db 0b00010001		; 00110 = fire+left
cb03 : 13                    	db 0b00010011		; 00111 = fire+left+right
cb04 : 08                    	db 0b00001000		; 01000 = down
cb05 : 0a                    	db 0b00001010		; 01001 = down+right
cb06 : 09                    	db 0b00001001		; 01010 = down+left
cb07 : 0b                    	db 0b00001011		; 01011 = down+left+right
cb08 : 18                    	db 0b00011000		; 01100 = down+fire
cb09 : 1a                    	db 0b00011010		; 01101 = down+fire+right
cb0a : 19                    	db 0b00011001		; 01110 = down+fire+left
cb0b : 1b                    	db 0b00011011		; 01111 = down+fire+left+right
cb0c : 04                    	db 0b00000100		; 10000 = up
cb0d : 06                    	db 0b00000110		; 10001 = up+right
cb0e : 05                    	db 0b00000101		; 10010 = up+left
AS65 Assembler for R6502 [1.42].                                     Page   97
---------------------------------- bank0.s -----------------------------------

cb0f : 07                    	db 0b00000111		; 10011 = up+left+right
cb10 : 14                    	db 0b00010100		; 10100 = up+fire
cb11 : 16                    	db 0b00010110		; 10101 = up+fire+right
cb12 : 15                    	db 0b00010101		; 10110 = up+fire+left
cb13 : 17                    	db 0b00010111		; 10111 = up+fire+left+right
cb14 : 0c                    	db 0b00001100		; 11000 = up+down
cb15 : 0e                    	db 0b00001110		; 11001 = up+down+right
cb16 : 0d                    	db 0b00001101		; 11010 = up+down+left
cb17 : 0f                    	db 0b00001111		; 11011 = up+down+left+right
cb18 : 1c                    	db 0b00011100		; 11100 = up+down+fire
cb19 : 1e                    	db 0b00011110		; 11101 = up+down+fire+right
cb1a : 1d                    	db 0b00011101		; 11110 = up+down+fire+left
cb1b : 1f                    	db 0b00011111		; 11111 = up+down+fire+left+right
                             	
                             	include "vdp/graph.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  GRAPH.S
                             ;*  This is the graphics module, to handle text a
                             ;*  graphics.
                             ;*  For text modes, this module keeps track of wh
                             ;*  next put a character, and also takes care of 
                             ;*  to the next line as well as scrolling the con
                             ;*  when the cursor has reached the bottom right.
                             ;*  module also enables text input which is echoe
                             ;*  screen, to allow interactive input and editin
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
cb1c :                       mod_sz_graph_s
                             
                             
                             	include "vdp/font.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  FONT.S
                             ;*  This is the font definition, used to initiali
                             ;*  character set.  This is the standard Oric-1 f
                             ;*	Still called vdp as this code was ported from 
                             ;*	machine using the TMS9918a.
                             ;*
                             ;************************************************
                             
cb1c :                       vdp_font
                             ; char 32
cb1c : 00                    	db %000000
cb1d : 00                    	db %000000
AS65 Assembler for R6502 [1.42].                                     Page   98
---------------------------------- bank0.s -----------------------------------

cb1e : 00                    	db %000000
cb1f : 00                    	db %000000
cb20 : 00                    	db %000000
cb21 : 00                    	db %000000
cb22 : 00                    	db %000000
cb23 : 00                    	db %000000
                             ; char 33
cb24 : 0c                    	db %001100
cb25 : 0c                    	db %001100
cb26 : 0c                    	db %001100
cb27 : 08                    	db %001000
cb28 : 08                    	db %001000
cb29 : 00                    	db %000000
cb2a : 08                    	db %001000
cb2b : 00                    	db %000000
                             ; char 34
cb2c : 36                    	db %110110
cb2d : 36                    	db %110110
cb2e : 12                    	db %010010
cb2f : 00                    	db %000000
cb30 : 00                    	db %000000
cb31 : 00                    	db %000000
cb32 : 00                    	db %000000
cb33 : 00                    	db %000000
                             ; char 35
cb34 : 14                    	db %010100
cb35 : 14                    	db %010100
cb36 : 3e                    	db %111110
cb37 : 14                    	db %010100
cb38 : 3e                    	db %111110
cb39 : 14                    	db %010100
cb3a : 14                    	db %010100
cb3b : 00                    	db %000000
                             ; char 36
cb3c : 08                    	db %001000
cb3d : 1e                    	db %011110
cb3e : 28                    	db %101000
cb3f : 1c                    	db %011100
cb40 : 0a                    	db %001010
cb41 : 3c                    	db %111100
cb42 : 08                    	db %001000
cb43 : 00                    	db %000000
                             ; char 37
cb44 : 30                    	db %110000
cb45 : 32                    	db %110010
cb46 : 04                    	db %000100
cb47 : 08                    	db %001000
cb48 : 10                    	db %010000
cb49 : 26                    	db %100110
cb4a : 06                    	db %000110
cb4b : 00                    	db %000000
                             ; char 38
cb4c : 10                    	db %010000
cb4d : 28                    	db %101000
cb4e : 28                    	db %101000
cb4f : 10                    	db %010000
cb50 : 2a                    	db %101010
cb51 : 24                    	db %100100
cb52 : 1a                    	db %011010
cb53 : 00                    	db %000000
                             ; char 39
cb54 : 0c                    	db %001100
AS65 Assembler for R6502 [1.42].                                     Page   99
---------------------------------- bank0.s -----------------------------------

cb55 : 0c                    	db %001100
cb56 : 04                    	db %000100
cb57 : 00                    	db %000000
cb58 : 00                    	db %000000
cb59 : 00                    	db %000000
cb5a : 00                    	db %000000
cb5b : 00                    	db %000000
                             ; char 40
cb5c : 04                    	db %000100
cb5d : 08                    	db %001000
cb5e : 10                    	db %010000
cb5f : 10                    	db %010000
cb60 : 10                    	db %010000
cb61 : 08                    	db %001000
cb62 : 04                    	db %000100
cb63 : 00                    	db %000000
                             ; char 41
cb64 : 10                    	db %010000
cb65 : 08                    	db %001000
cb66 : 04                    	db %000100
cb67 : 04                    	db %000100
cb68 : 04                    	db %000100
cb69 : 08                    	db %001000
cb6a : 10                    	db %010000
cb6b : 00                    	db %000000
                             ; char 42
cb6c : 08                    	db %001000
cb6d : 2a                    	db %101010
cb6e : 1c                    	db %011100
cb6f : 08                    	db %001000
cb70 : 1c                    	db %011100
cb71 : 2a                    	db %101010
cb72 : 08                    	db %001000
cb73 : 00                    	db %000000
                             ; char 43
cb74 : 00                    	db %000000
cb75 : 08                    	db %001000
cb76 : 08                    	db %001000
cb77 : 3e                    	db %111110
cb78 : 08                    	db %001000
cb79 : 08                    	db %001000
cb7a : 00                    	db %000000
cb7b : 00                    	db %000000
                             ; char 44
cb7c : 00                    	db %000000
cb7d : 00                    	db %000000
cb7e : 00                    	db %000000
cb7f : 00                    	db %000000
cb80 : 00                    	db %000000
cb81 : 08                    	db %001000
cb82 : 08                    	db %001000
cb83 : 10                    	db %010000
                             ; char 45
cb84 : 00                    	db %000000
cb85 : 00                    	db %000000
cb86 : 00                    	db %000000
cb87 : 3e                    	db %111110
cb88 : 00                    	db %000000
cb89 : 00                    	db %000000
cb8a : 00                    	db %000000
cb8b : 00                    	db %000000
                             ; char 46
AS65 Assembler for R6502 [1.42].                                     Page  100
---------------------------------- bank0.s -----------------------------------

cb8c : 00                    	db %000000
cb8d : 00                    	db %000000
cb8e : 00                    	db %000000
cb8f : 00                    	db %000000
cb90 : 00                    	db %000000
cb91 : 04                    	db %000100
cb92 : 00                    	db %000000
cb93 : 00                    	db %000000
                             ; char 47
cb94 : 00                    	db %000000
cb95 : 02                    	db %000010
cb96 : 04                    	db %000100
cb97 : 08                    	db %001000
cb98 : 10                    	db %010000
cb99 : 20                    	db %100000
cb9a : 00                    	db %000000
cb9b : 00                    	db %000000
                             ; char 48
cb9c : 1c                    	db %011100
cb9d : 22                    	db %100010
cb9e : 26                    	db %100110
cb9f : 2a                    	db %101010
cba0 : 32                    	db %110010
cba1 : 22                    	db %100010
cba2 : 1c                    	db %011100
cba3 : 00                    	db %000000
                             ; char 49
cba4 : 08                    	db %001000
cba5 : 18                    	db %011000
cba6 : 08                    	db %001000
cba7 : 08                    	db %001000
cba8 : 08                    	db %001000
cba9 : 08                    	db %001000
cbaa : 1c                    	db %011100
cbab : 00                    	db %000000
                             ; char 50
cbac : 1c                    	db %011100
cbad : 22                    	db %100010
cbae : 02                    	db %000010
cbaf : 04                    	db %000100
cbb0 : 08                    	db %001000
cbb1 : 10                    	db %010000
cbb2 : 3e                    	db %111110
cbb3 : 00                    	db %000000
                             ; char 51
cbb4 : 3e                    	db %111110
cbb5 : 02                    	db %000010
cbb6 : 04                    	db %000100
cbb7 : 0c                    	db %001100
cbb8 : 02                    	db %000010
cbb9 : 22                    	db %100010
cbba : 1c                    	db %011100
cbbb : 00                    	db %000000
                             ; char 52
cbbc : 04                    	db %000100
cbbd : 0c                    	db %001100
cbbe : 14                    	db %010100
cbbf : 24                    	db %100100
cbc0 : 3e                    	db %111110
cbc1 : 04                    	db %000100
cbc2 : 04                    	db %000100
cbc3 : 00                    	db %000000
AS65 Assembler for R6502 [1.42].                                     Page  101
---------------------------------- bank0.s -----------------------------------

                             ; char 53
cbc4 : 3e                    	db %111110
cbc5 : 20                    	db %100000
cbc6 : 3c                    	db %111100
cbc7 : 02                    	db %000010
cbc8 : 02                    	db %000010
cbc9 : 22                    	db %100010
cbca : 1c                    	db %011100
cbcb : 00                    	db %000000
                             ; char 54
cbcc : 0c                    	db %001100
cbcd : 10                    	db %010000
cbce : 20                    	db %100000
cbcf : 3c                    	db %111100
cbd0 : 22                    	db %100010
cbd1 : 22                    	db %100010
cbd2 : 1c                    	db %011100
cbd3 : 00                    	db %000000
                             ; char 55
cbd4 : 3e                    	db %111110
cbd5 : 02                    	db %000010
cbd6 : 04                    	db %000100
cbd7 : 08                    	db %001000
cbd8 : 10                    	db %010000
cbd9 : 10                    	db %010000
cbda : 10                    	db %010000
cbdb : 00                    	db %000000
                             ; char 56
cbdc : 1c                    	db %011100
cbdd : 22                    	db %100010
cbde : 22                    	db %100010
cbdf : 1c                    	db %011100
cbe0 : 22                    	db %100010
cbe1 : 22                    	db %100010
cbe2 : 1c                    	db %011100
cbe3 : 00                    	db %000000
                             ; char 57
cbe4 : 1c                    	db %011100
cbe5 : 22                    	db %100010
cbe6 : 22                    	db %100010
cbe7 : 1e                    	db %011110
cbe8 : 02                    	db %000010
cbe9 : 04                    	db %000100
cbea : 18                    	db %011000
cbeb : 00                    	db %000000
                             ; char 58
cbec : 00                    	db %000000
cbed : 00                    	db %000000
cbee : 08                    	db %001000
cbef : 00                    	db %000000
cbf0 : 00                    	db %000000
cbf1 : 08                    	db %001000
cbf2 : 00                    	db %000000
cbf3 : 00                    	db %000000
                             ; char 59
cbf4 : 00                    	db %000000
cbf5 : 00                    	db %000000
cbf6 : 08                    	db %001000
cbf7 : 00                    	db %000000
cbf8 : 00                    	db %000000
cbf9 : 08                    	db %001000
cbfa : 08                    	db %001000
AS65 Assembler for R6502 [1.42].                                     Page  102
---------------------------------- bank0.s -----------------------------------

cbfb : 10                    	db %010000
                             ; char 60
cbfc : 04                    	db %000100
cbfd : 08                    	db %001000
cbfe : 10                    	db %010000
cbff : 20                    	db %100000
cc00 : 10                    	db %010000
cc01 : 08                    	db %001000
cc02 : 04                    	db %000100
cc03 : 00                    	db %000000
                             ; char 61
cc04 : 00                    	db %000000
cc05 : 00                    	db %000000
cc06 : 3e                    	db %111110
cc07 : 00                    	db %000000
cc08 : 3e                    	db %111110
cc09 : 00                    	db %000000
cc0a : 00                    	db %000000
cc0b : 00                    	db %000000
                             ; char 62
cc0c : 10                    	db %010000
cc0d : 08                    	db %001000
cc0e : 04                    	db %000100
cc0f : 02                    	db %000010
cc10 : 04                    	db %000100
cc11 : 08                    	db %001000
cc12 : 10                    	db %010000
cc13 : 00                    	db %000000
                             ; char 63
cc14 : 1c                    	db %011100
cc15 : 22                    	db %100010
cc16 : 04                    	db %000100
cc17 : 08                    	db %001000
cc18 : 08                    	db %001000
cc19 : 00                    	db %000000
cc1a : 08                    	db %001000
cc1b : 00                    	db %000000
                             ; char 64
cc1c : 1c                    	db %011100
cc1d : 22                    	db %100010
cc1e : 2a                    	db %101010
cc1f : 2e                    	db %101110
cc20 : 2c                    	db %101100
cc21 : 20                    	db %100000
cc22 : 1e                    	db %011110
cc23 : 00                    	db %000000
cc24 :                       vdp_font_a
                             ; char 65
cc24 : 1c                    	db %011100
cc25 : 22                    	db %100010
cc26 : 22                    	db %100010
cc27 : 3e                    	db %111110
cc28 : 22                    	db %100010
cc29 : 22                    	db %100010
cc2a : 22                    	db %100010
cc2b : 00                    	db %000000
                             ; char 66
cc2c : 3c                    	db %111100
cc2d : 22                    	db %100010
cc2e : 22                    	db %100010
cc2f : 3c                    	db %111100
cc30 : 22                    	db %100010
AS65 Assembler for R6502 [1.42].                                     Page  103
---------------------------------- bank0.s -----------------------------------

cc31 : 22                    	db %100010
cc32 : 3c                    	db %111100
cc33 : 00                    	db %000000
                             ; char 67
cc34 : 1c                    	db %011100
cc35 : 22                    	db %100010
cc36 : 20                    	db %100000
cc37 : 20                    	db %100000
cc38 : 20                    	db %100000
cc39 : 22                    	db %100010
cc3a : 1c                    	db %011100
cc3b : 00                    	db %000000
                             ; char 68
cc3c : 3c                    	db %111100
cc3d : 22                    	db %100010
cc3e : 22                    	db %100010
cc3f : 22                    	db %100010
cc40 : 22                    	db %100010
cc41 : 22                    	db %100010
cc42 : 3c                    	db %111100
cc43 : 00                    	db %000000
                             ; char 69
cc44 : 3e                    	db %111110
cc45 : 20                    	db %100000
cc46 : 20                    	db %100000
cc47 : 3c                    	db %111100
cc48 : 20                    	db %100000
cc49 : 20                    	db %100000
cc4a : 3e                    	db %111110
cc4b : 00                    	db %000000
                             ; char 70
cc4c : 3e                    	db %111110
cc4d : 20                    	db %100000
cc4e : 20                    	db %100000
cc4f : 3c                    	db %111100
cc50 : 20                    	db %100000
cc51 : 20                    	db %100000
cc52 : 20                    	db %100000
cc53 : 00                    	db %000000
                             ; char 71
cc54 : 1e                    	db %011110
cc55 : 20                    	db %100000
cc56 : 20                    	db %100000
cc57 : 20                    	db %100000
cc58 : 26                    	db %100110
cc59 : 22                    	db %100010
cc5a : 1e                    	db %011110
cc5b : 00                    	db %000000
                             ; char 72
cc5c : 22                    	db %100010
cc5d : 22                    	db %100010
cc5e : 22                    	db %100010
cc5f : 3e                    	db %111110
cc60 : 22                    	db %100010
cc61 : 22                    	db %100010
cc62 : 22                    	db %100010
cc63 : 00                    	db %000000
                             ; char 73
cc64 : 1c                    	db %011100
cc65 : 08                    	db %001000
cc66 : 08                    	db %001000
cc67 : 08                    	db %001000
AS65 Assembler for R6502 [1.42].                                     Page  104
---------------------------------- bank0.s -----------------------------------

cc68 : 08                    	db %001000
cc69 : 08                    	db %001000
cc6a : 1c                    	db %011100
cc6b : 00                    	db %000000
                             ; char 74
cc6c : 02                    	db %000010
cc6d : 02                    	db %000010
cc6e : 02                    	db %000010
cc6f : 02                    	db %000010
cc70 : 02                    	db %000010
cc71 : 22                    	db %100010
cc72 : 1c                    	db %011100
cc73 : 00                    	db %000000
                             ; char 75
cc74 : 22                    	db %100010
cc75 : 24                    	db %100100
cc76 : 28                    	db %101000
cc77 : 30                    	db %110000
cc78 : 28                    	db %101000
cc79 : 24                    	db %100100
cc7a : 22                    	db %100010
cc7b : 00                    	db %000000
                             ; char 76
cc7c : 20                    	db %100000
cc7d : 20                    	db %100000
cc7e : 20                    	db %100000
cc7f : 20                    	db %100000
cc80 : 20                    	db %100000
cc81 : 20                    	db %100000
cc82 : 3e                    	db %111110
cc83 : 00                    	db %000000
                             ; char 77
cc84 : 22                    	db %100010
cc85 : 36                    	db %110110
cc86 : 2a                    	db %101010
cc87 : 2a                    	db %101010
cc88 : 22                    	db %100010
cc89 : 22                    	db %100010
cc8a : 22                    	db %100010
cc8b : 00                    	db %000000
                             ; char 78
cc8c : 22                    	db %100010
cc8d : 22                    	db %100010
cc8e : 32                    	db %110010
cc8f : 2a                    	db %101010
cc90 : 26                    	db %100110
cc91 : 22                    	db %100010
cc92 : 22                    	db %100010
cc93 : 00                    	db %000000
                             ; char 79
cc94 : 1c                    	db %011100
cc95 : 22                    	db %100010
cc96 : 22                    	db %100010
cc97 : 22                    	db %100010
cc98 : 22                    	db %100010
cc99 : 22                    	db %100010
cc9a : 1c                    	db %011100
cc9b : 00                    	db %000000
                             ; char 80
cc9c : 3c                    	db %111100
cc9d : 22                    	db %100010
cc9e : 22                    	db %100010
AS65 Assembler for R6502 [1.42].                                     Page  105
---------------------------------- bank0.s -----------------------------------

cc9f : 3c                    	db %111100
cca0 : 20                    	db %100000
cca1 : 20                    	db %100000
cca2 : 20                    	db %100000
cca3 : 00                    	db %000000
                             ; char 81
cca4 : 1c                    	db %011100
cca5 : 22                    	db %100010
cca6 : 22                    	db %100010
cca7 : 22                    	db %100010
cca8 : 2a                    	db %101010
cca9 : 24                    	db %100100
ccaa : 1a                    	db %011010
ccab : 00                    	db %000000
                             ; char 82
ccac : 3c                    	db %111100
ccad : 22                    	db %100010
ccae : 22                    	db %100010
ccaf : 3c                    	db %111100
ccb0 : 28                    	db %101000
ccb1 : 24                    	db %100100
ccb2 : 22                    	db %100010
ccb3 : 00                    	db %000000
                             ; char 83
ccb4 : 1c                    	db %011100
ccb5 : 22                    	db %100010
ccb6 : 20                    	db %100000
ccb7 : 1c                    	db %011100
ccb8 : 02                    	db %000010
ccb9 : 22                    	db %100010
ccba : 1c                    	db %011100
ccbb : 00                    	db %000000
                             ; char 84
ccbc : 3e                    	db %111110
ccbd : 08                    	db %001000
ccbe : 08                    	db %001000
ccbf : 08                    	db %001000
ccc0 : 08                    	db %001000
ccc1 : 08                    	db %001000
ccc2 : 08                    	db %001000
ccc3 : 00                    	db %000000
                             ; char 85
ccc4 : 22                    	db %100010
ccc5 : 22                    	db %100010
ccc6 : 22                    	db %100010
ccc7 : 22                    	db %100010
ccc8 : 22                    	db %100010
ccc9 : 22                    	db %100010
ccca : 1c                    	db %011100
cccb : 00                    	db %000000
                             ; char 86
cccc : 22                    	db %100010
cccd : 22                    	db %100010
ccce : 22                    	db %100010
cccf : 22                    	db %100010
ccd0 : 22                    	db %100010
ccd1 : 14                    	db %010100
ccd2 : 08                    	db %001000
ccd3 : 00                    	db %000000
                             ; char 87
ccd4 : 22                    	db %100010
ccd5 : 22                    	db %100010
AS65 Assembler for R6502 [1.42].                                     Page  106
---------------------------------- bank0.s -----------------------------------

ccd6 : 22                    	db %100010
ccd7 : 2a                    	db %101010
ccd8 : 2a                    	db %101010
ccd9 : 36                    	db %110110
ccda : 22                    	db %100010
ccdb : 00                    	db %000000
                             ; char 88
ccdc : 22                    	db %100010
ccdd : 22                    	db %100010
ccde : 14                    	db %010100
ccdf : 08                    	db %001000
cce0 : 14                    	db %010100
cce1 : 22                    	db %100010
cce2 : 22                    	db %100010
cce3 : 00                    	db %000000
                             ; char 89
cce4 : 22                    	db %100010
cce5 : 22                    	db %100010
cce6 : 14                    	db %010100
cce7 : 08                    	db %001000
cce8 : 08                    	db %001000
cce9 : 08                    	db %001000
ccea : 08                    	db %001000
cceb : 00                    	db %000000
                             ; char 90
ccec : 3e                    	db %111110
cced : 02                    	db %000010
ccee : 04                    	db %000100
ccef : 08                    	db %001000
ccf0 : 10                    	db %010000
ccf1 : 20                    	db %100000
ccf2 : 3e                    	db %111110
ccf3 : 00                    	db %000000
                             ; char 91
ccf4 : 1c                    	db %011100
ccf5 : 10                    	db %010000
ccf6 : 10                    	db %010000
ccf7 : 10                    	db %010000
ccf8 : 10                    	db %010000
ccf9 : 10                    	db %010000
ccfa : 1c                    	db %011100
ccfb : 00                    	db %000000
                             ; char 92
ccfc : 00                    	db %000000
ccfd : 20                    	db %100000
ccfe : 10                    	db %010000
ccff : 08                    	db %001000
cd00 : 04                    	db %000100
cd01 : 02                    	db %000010
cd02 : 00                    	db %000000
cd03 : 00                    	db %000000
                             ; char 93
cd04 : 1c                    	db %011100
cd05 : 04                    	db %000100
cd06 : 04                    	db %000100
cd07 : 04                    	db %000100
cd08 : 04                    	db %000100
cd09 : 04                    	db %000100
cd0a : 1c                    	db %011100
cd0b : 00                    	db %000000
                             ; char 94
cd0c : 08                    	db %001000
AS65 Assembler for R6502 [1.42].                                     Page  107
---------------------------------- bank0.s -----------------------------------

cd0d : 1c                    	db %011100
cd0e : 3e                    	db %111110
cd0f : 08                    	db %001000
cd10 : 08                    	db %001000
cd11 : 08                    	db %001000
cd12 : 08                    	db %001000
cd13 : 00                    	db %000000
                             ; char 95
cd14 : 00                    	db %000000
cd15 : 00                    	db %000000
cd16 : 00                    	db %000000
cd17 : 00                    	db %000000
cd18 : 00                    	db %000000
cd19 : 00                    	db %000000
cd1a : 3e                    	db %111110
cd1b : 00                    	db %000000
                             ; char 96
cd1c : 0e                    	db %001110
cd1d : 10                    	db %010000
cd1e : 10                    	db %010000
cd1f : 3c                    	db %111100
cd20 : 10                    	db %010000
cd21 : 10                    	db %010000
cd22 : 3e                    	db %111110
cd23 : 00                    	db %000000
                             ; char 97
cd24 : 00                    	db %000000
cd25 : 00                    	db %000000
cd26 : 1c                    	db %011100
cd27 : 02                    	db %000010
cd28 : 1e                    	db %011110
cd29 : 22                    	db %100010
cd2a : 1e                    	db %011110
cd2b : 00                    	db %000000
                             ; char 98
cd2c : 20                    	db %100000
cd2d : 20                    	db %100000
cd2e : 3c                    	db %111100
cd2f : 22                    	db %100010
cd30 : 22                    	db %100010
cd31 : 22                    	db %100010
cd32 : 3c                    	db %111100
cd33 : 00                    	db %000000
                             ; char 99
cd34 : 00                    	db %000000
cd35 : 00                    	db %000000
cd36 : 1e                    	db %011110
cd37 : 20                    	db %100000
cd38 : 20                    	db %100000
cd39 : 20                    	db %100000
cd3a : 1e                    	db %011110
cd3b : 00                    	db %000000
                             ; char 100
cd3c : 02                    	db %000010
cd3d : 02                    	db %000010
cd3e : 1e                    	db %011110
cd3f : 22                    	db %100010
cd40 : 22                    	db %100010
cd41 : 22                    	db %100010
cd42 : 1e                    	db %011110
cd43 : 00                    	db %000000
                             ; char 101
AS65 Assembler for R6502 [1.42].                                     Page  108
---------------------------------- bank0.s -----------------------------------

cd44 : 00                    	db %000000
cd45 : 00                    	db %000000
cd46 : 1c                    	db %011100
cd47 : 22                    	db %100010
cd48 : 3e                    	db %111110
cd49 : 20                    	db %100000
cd4a : 1e                    	db %011110
cd4b : 00                    	db %000000
                             ; char 102
cd4c : 0c                    	db %001100
cd4d : 12                    	db %010010
cd4e : 10                    	db %010000
cd4f : 3c                    	db %111100
cd50 : 10                    	db %010000
cd51 : 10                    	db %010000
cd52 : 10                    	db %010000
cd53 : 00                    	db %000000
                             ; char 103
cd54 : 00                    	db %000000
cd55 : 00                    	db %000000
cd56 : 1c                    	db %011100
cd57 : 22                    	db %100010
cd58 : 22                    	db %100010
cd59 : 1e                    	db %011110
cd5a : 02                    	db %000010
cd5b : 1c                    	db %011100
                             ; char 104
cd5c : 20                    	db %100000
cd5d : 20                    	db %100000
cd5e : 3c                    	db %111100
cd5f : 22                    	db %100010
cd60 : 22                    	db %100010
cd61 : 22                    	db %100010
cd62 : 22                    	db %100010
cd63 : 00                    	db %000000
                             ; char 105
cd64 : 08                    	db %001000
cd65 : 00                    	db %000000
cd66 : 18                    	db %011000
cd67 : 08                    	db %001000
cd68 : 08                    	db %001000
cd69 : 08                    	db %001000
cd6a : 1c                    	db %011100
cd6b : 00                    	db %000000
                             ; char 106
cd6c : 04                    	db %000100
cd6d : 00                    	db %000000
cd6e : 0c                    	db %001100
cd6f : 04                    	db %000100
cd70 : 04                    	db %000100
cd71 : 04                    	db %000100
cd72 : 24                    	db %100100
cd73 : 18                    	db %011000
                             ; char 107
cd74 : 20                    	db %100000
cd75 : 20                    	db %100000
cd76 : 22                    	db %100010
cd77 : 24                    	db %100100
cd78 : 38                    	db %111000
cd79 : 24                    	db %100100
cd7a : 22                    	db %100010
cd7b : 00                    	db %000000
AS65 Assembler for R6502 [1.42].                                     Page  109
---------------------------------- bank0.s -----------------------------------

                             ; char 108
cd7c : 18                    	db %011000
cd7d : 08                    	db %001000
cd7e : 08                    	db %001000
cd7f : 08                    	db %001000
cd80 : 08                    	db %001000
cd81 : 08                    	db %001000
cd82 : 1c                    	db %011100
cd83 : 00                    	db %000000
                             ; char 109
cd84 : 00                    	db %000000
cd85 : 00                    	db %000000
cd86 : 36                    	db %110110
cd87 : 2a                    	db %101010
cd88 : 2a                    	db %101010
cd89 : 2a                    	db %101010
cd8a : 22                    	db %100010
cd8b : 00                    	db %000000
                             ; char 110
cd8c : 00                    	db %000000
cd8d : 00                    	db %000000
cd8e : 3c                    	db %111100
cd8f : 22                    	db %100010
cd90 : 22                    	db %100010
cd91 : 22                    	db %100010
cd92 : 22                    	db %100010
cd93 : 00                    	db %000000
                             ; char 111
cd94 : 00                    	db %000000
cd95 : 00                    	db %000000
cd96 : 1c                    	db %011100
cd97 : 22                    	db %100010
cd98 : 22                    	db %100010
cd99 : 22                    	db %100010
cd9a : 1c                    	db %011100
cd9b : 00                    	db %000000
                             ; char 112
cd9c : 00                    	db %000000
cd9d : 00                    	db %000000
cd9e : 3c                    	db %111100
cd9f : 22                    	db %100010
cda0 : 22                    	db %100010
cda1 : 3c                    	db %111100
cda2 : 20                    	db %100000
cda3 : 20                    	db %100000
                             ; char 113
cda4 : 00                    	db %000000
cda5 : 00                    	db %000000
cda6 : 1e                    	db %011110
cda7 : 22                    	db %100010
cda8 : 22                    	db %100010
cda9 : 1e                    	db %011110
cdaa : 02                    	db %000010
cdab : 02                    	db %000010
                             ; char 114
cdac : 00                    	db %000000
cdad : 00                    	db %000000
cdae : 2e                    	db %101110
cdaf : 30                    	db %110000
cdb0 : 20                    	db %100000
cdb1 : 20                    	db %100000
cdb2 : 20                    	db %100000
AS65 Assembler for R6502 [1.42].                                     Page  110
---------------------------------- bank0.s -----------------------------------

cdb3 : 00                    	db %000000
                             ; char 115
cdb4 : 00                    	db %000000
cdb5 : 00                    	db %000000
cdb6 : 1e                    	db %011110
cdb7 : 20                    	db %100000
cdb8 : 1c                    	db %011100
cdb9 : 02                    	db %000010
cdba : 3c                    	db %111100
cdbb : 00                    	db %000000
                             ; char 116
cdbc : 10                    	db %010000
cdbd : 10                    	db %010000
cdbe : 3c                    	db %111100
cdbf : 10                    	db %010000
cdc0 : 10                    	db %010000
cdc1 : 12                    	db %010010
cdc2 : 0c                    	db %001100
cdc3 : 00                    	db %000000
                             ; char 117
cdc4 : 00                    	db %000000
cdc5 : 00                    	db %000000
cdc6 : 22                    	db %100010
cdc7 : 22                    	db %100010
cdc8 : 22                    	db %100010
cdc9 : 26                    	db %100110
cdca : 1a                    	db %011010
cdcb : 00                    	db %000000
                             ; char 118
cdcc : 00                    	db %000000
cdcd : 00                    	db %000000
cdce : 22                    	db %100010
cdcf : 22                    	db %100010
cdd0 : 22                    	db %100010
cdd1 : 14                    	db %010100
cdd2 : 08                    	db %001000
cdd3 : 00                    	db %000000
                             ; char 119
cdd4 : 00                    	db %000000
cdd5 : 00                    	db %000000
cdd6 : 22                    	db %100010
cdd7 : 22                    	db %100010
cdd8 : 2a                    	db %101010
cdd9 : 2a                    	db %101010
cdda : 36                    	db %110110
cddb : 00                    	db %000000
                             ; char 120
cddc : 00                    	db %000000
cddd : 00                    	db %000000
cdde : 22                    	db %100010
cddf : 14                    	db %010100
cde0 : 08                    	db %001000
cde1 : 14                    	db %010100
cde2 : 22                    	db %100010
cde3 : 00                    	db %000000
                             ; char 121
cde4 : 00                    	db %000000
cde5 : 00                    	db %000000
cde6 : 22                    	db %100010
cde7 : 22                    	db %100010
cde8 : 22                    	db %100010
cde9 : 1e                    	db %011110
AS65 Assembler for R6502 [1.42].                                     Page  111
---------------------------------- bank0.s -----------------------------------

cdea : 02                    	db %000010
cdeb : 1c                    	db %011100
                             ; char 122
cdec : 00                    	db %000000
cded : 00                    	db %000000
cdee : 3e                    	db %111110
cdef : 04                    	db %000100
cdf0 : 08                    	db %001000
cdf1 : 10                    	db %010000
cdf2 : 3e                    	db %111110
cdf3 : 00                    	db %000000
                             ; char 123
cdf4 : 0e                    	db %001110
cdf5 : 18                    	db %011000
cdf6 : 18                    	db %011000
cdf7 : 30                    	db %110000
cdf8 : 18                    	db %011000
cdf9 : 18                    	db %011000
cdfa : 0e                    	db %001110
cdfb : 00                    	db %000000
                             ; char 124
cdfc : 08                    	db %001000
cdfd : 08                    	db %001000
cdfe : 08                    	db %001000
cdff : 08                    	db %001000
ce00 : 08                    	db %001000
ce01 : 08                    	db %001000
ce02 : 08                    	db %001000
ce03 : 00                    	db %000000
                             ; char 125
ce04 : 38                    	db %111000
ce05 : 0c                    	db %001100
ce06 : 0c                    	db %001100
ce07 : 06                    	db %000110
ce08 : 0c                    	db %001100
ce09 : 0c                    	db %001100
ce0a : 38                    	db %111000
ce0b : 00                    	db %000000
                             ; char 126
ce0c : 00                    	db %000000
ce0d : 00                    	db %000000
ce0e : 10                    	db %010000
ce0f : 2a                    	db %101010
ce10 : 04                    	db %000100
ce11 : 00                    	db %000000
ce12 : 00                    	db %000000
ce13 : 00                    	db %000000
                             ; char 127
ce14 : 2a                    	db %101010
ce15 : 15                    	db %010101
ce16 : 2a                    	db %101010
ce17 : 15                    	db %010101
ce18 : 2a                    	db %101010
ce19 : 15                    	db %010101
ce1a : 2a                    	db %101010
ce1b : 15                    	db %010101
                             	
                             	
                             
                             ;****************************************
                             ;* vdp_init_font
                             ;* Initialise fonts from ROM
AS65 Assembler for R6502 [1.42].                                     Page  112
---------------------------------- bank0.s -----------------------------------

                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
ce1c :                       gr_init_font
                             	; Get char base from vdp structure
ce1c : a614             [ 3] 	ldx gr_scrngeom+gr_char
ce1e : 8634             [ 3] 	stx tmp_blo
ce20 : a615             [ 3] 	ldx gr_scrngeom+gr_char+1
ce22 : e8               [ 2] 	inx						; ASCII patterns start 1 page later
ce23 : 8635             [ 3] 	stx tmp_bhi
                             
ce25 : a91c             [ 2] 	lda #lo(vdp_font)		; Low byte of fonts source
ce27 : 8536             [ 3] 	sta tmp_clo
ce29 : a9cb             [ 2] 	lda #hi(vdp_font)		; High byte of fonts source
ce2b : 8537             [ 3] 	sta tmp_chi
ce2d : a203             [ 2] 	ldx #3					; Copy 3 pages
ce2f : 4c32ce           [ 3] 	jmp gr_copy_mem
                             
                             
                             ;****************************************
                             ;* vdp_copy_mem
                             ;* Copy memory pages at a time
                             ;* Input :	clo/hi	=	source
                             ;*			blo/hi	=	dest
                             ;*			X		=	pages to copy
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
ce32 :                       gr_copy_mem
ce32 : a000             [ 2] 	ldy #0					; byte within page
ce34 : a536             [ 3] 	lda tmp_clo				; Low byte of source
ce36 : 8532             [ 3] 	sta tmp_alo
ce38 : a537             [ 3] 	lda tmp_chi				; High byte of source
ce3a : 8533             [ 3] 	sta tmp_ahi
ce3c :                       gr_copy_byte
ce3c : 98               [ 2] 	tya
ce3d : b132             [ 5] 	lda (tmp_alo),y			; Get byte from font table
ce3f : 9134             [ 5] 	sta (tmp_blo),y			; Put it to the memory
ce41 : c8               [ 2] 	iny
ce42 : d0f8             [ 3] 	bne gr_copy_byte		; keep going for 1 page
ce44 : e633             [ 5] 	inc tmp_ahi				; only need to increment high byt
ce46 : e635             [ 5] 	inc tmp_bhi				; source and destination ptr
ce48 : ca               [ 2] 	dex						; page counter
ce49 : d0f1             [ 3] 	bne gr_copy_byte		; keep going for X pages
ce4b : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_init
                             ;* First initialisation of screen
                             ;****************************************
ce4c :                       gr_init
ce4c : a210             [ 2] 	ldx #VDP_FLASH			; Default cursor flash rate
ce4e : 860b             [ 3] 	stx vdp_curtim
ce50 : 860c             [ 3] 	stx vdp_curcnt
ce52 : a200             [ 2] 	ldx #0
ce54 : 860e             [ 3] 	stx vdp_curstat
                             
                             	; Hard reset initial geom values (X=0)
ce56 : 207dce           [ 6] 	jsr gr_init_geom
                             
AS65 Assembler for R6502 [1.42].                                     Page  113
---------------------------------- bank0.s -----------------------------------

                             	; Copy font from ROM to char base
ce59 : 201cce           [ 6] 	jsr gr_init_font
                             
                             	; Go in to hires mode to generate tables
ce5c : 20d3ce           [ 6] 	jsr gr_init_hires
ce5f : 200ccf           [ 6] 	jsr gr_init_hires_tables
                             
                             	; But start in text mode
ce62 : 4cbace           [ 3] 	jmp gr_init_screen_txt
                             
                             
                             ;****************************************
                             ;* gr_check_font_copy
                             ;* check font needs to be copied from
                             ;* current location to another
                             ;* A=high byte of page aligned font addr
                             ;* that the font needs to be at
                             ;****************************************
ce65 :                       gr_check_font_copy
                             	; Compare with current high byte
ce65 : c515             [ 3] 	cmp gr_scrngeom+gr_char+1
ce67 : f013             [ 3] 	beq gr_check_font_copy_done
                             	; save A as high byte of destination
ce69 : 8535             [ 3] 	sta tmp_blo+1
                             	; destination low is 0
ce6b : a900             [ 2] 	lda #0
ce6d : 8534             [ 3] 	sta tmp_blo
                             
                             	; Get source from current vdp structure
ce6f : a515             [ 3] 	lda gr_scrngeom+gr_char+1
ce71 : 8537             [ 3] 	sta tmp_clo+1
ce73 : a514             [ 3] 	lda gr_scrngeom+gr_char
ce75 : 8536             [ 3] 	sta tmp_clo
                             
                             	; Copy all 8 pages of font (std + alt) data
ce77 : a208             [ 2] 	ldx #8
ce79 : 2032ce           [ 6] 	jsr gr_copy_mem
ce7c :                       gr_check_font_copy_done
ce7c :                       gr_init_geom_done
ce7c : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_init_geom
                             ;* initialise geometry entries from X
                             ;* position from base until -1
                             ;****************************************
ce7d :                       gr_init_geom
                             	; Which geom entry to init = Y
ce7d : bc8cce           [ 4] 	ldy gr_scrngeom_base,x
ce80 : 30fa             [ 3] 	bmi gr_init_geom_done		; Just somewhere with an 
                             	; skip to data and put in A
ce82 : e8               [ 2] 	inx
ce83 : bd8cce           [ 4] 	lda gr_scrngeom_base,x
                             	; save it in Y
ce86 : 991100           [ 5] 	sta gr_scrngeom,y
                             	; next entry
ce89 : e8               [ 2] 	inx
ce8a : d0f1             [ 3] 	bne gr_init_geom	; Always
                             	; Hope we don't get here - will crash!
                             
                             ; Geometry initialisation tables
AS65 Assembler for R6502 [1.42].                                     Page  114
---------------------------------- bank0.s -----------------------------------

ce8c :                       gr_scrngeom_base
ce8c : 1204                  	db gr_ink, 4				; Blue ink
ce8e : 1313                  	db gr_paper, 16+3			; Yellow paper
ce90 : 1402                  	db gr_margin, 2
                             	; Not terminated by -1 : continues in to _txt va
                             ;* Geometry for text/lores
ce92 :                       gr_scrngeom_text
ce92 : 0000                  	db gr_mode, 0
                             
ce94 : 0300                  	db gr_char,   lo(TEXTCHAR)
ce96 : 04b4                  	db gr_char+1, hi(TEXTCHAR)
                             
ce98 : 0580                  	db gr_text_start,   lo(TEXTSCRN)
ce9a : 06bb                  	db gr_text_start+1, hi(TEXTSCRN)
                             
ce9c : 0828                  	db gr_text_w, 40
ce9e : 091c                  	db gr_text_h, 28
cea0 : ff                    	db -1
                             ;* Geometry for hires
cea1 :                       gr_scrngeom_hires
cea1 : 0001                  	db gr_mode, 1
                             
cea3 : 0100                  	db gr_hi_start,   lo(HISCRN)
cea5 : 02a0                  	db gr_hi_start+1, hi(HISCRN)
cea7 : 0300                  	db gr_char,   lo(HICHAR)
cea9 : 0498                  	db gr_char+1, hi(HICHAR)
                             
ceab : 0568                  	db gr_text_start,   lo(HITEXT)
cead : 06bf                  	db gr_text_start+1, hi(HITEXT)
                             
ceaf : 1000                  	db gr_hires_x, 0
ceb1 : 1100                  	db gr_hires_y, 0
                             
                             	; Only need to initialise text height, width is 
ceb3 : 0903                  	db gr_text_h, 3
                             
ceb5 : 0e01                  	db gr_pixmode, 1
ceb7 : 0f06                  	db gr_pitch, 6
ceb9 : ff                    	db -1
                             
                             
                             
                             ;****************************************
                             ;* gr_init_screen_txt
                             ;* initialise the screen in text mode
                             ;****************************************
ceba :                       gr_init_screen_txt
ceba : e60d             [ 5] 	inc vdp_curoff
                             
                             	; Check if font copy needed to 0xb400
cebc : a9b4             [ 2] 	lda #hi(TEXTCHAR)
cebe : 2065ce           [ 6] 	jsr gr_check_font_copy
                             
                             	; Initialise geom for text
cec1 : a206             [ 2] 	ldx #gr_scrngeom_text-gr_scrngeom_base
cec3 : 207dce           [ 6] 	jsr gr_init_geom
                             
cec6 : 201fd4           [ 6] 	jsr gr_spr_init					; SW Sprites are reset
                             
cec9 : a920             [ 2] 	lda #' '						; Blank is SPACE
cecb : 8510             [ 3] 	sta vdp_blank
cecd : 2050cf           [ 6] 	jsr gr_cls
AS65 Assembler for R6502 [1.42].                                     Page  115
---------------------------------- bank0.s -----------------------------------

                             
ced0 : c60d             [ 5] 	dec vdp_curoff
                             
ced2 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_hires
                             ;* Input : X = Colour table fill value
                             ;* initialise the screen in hires mode
                             ;****************************************
ced3 :                       gr_init_hires
ced3 : e60d             [ 5] 	inc vdp_curoff
                             	; Check if font copy needed to 0x9800
ced5 : a998             [ 2] 	lda #hi(HICHAR)
ced7 : 2065ce           [ 6] 	jsr gr_check_font_copy
                             
                             	; Initialise geom for hires
ceda : a215             [ 2] 	ldx #gr_scrngeom_hires-gr_scrngeom_base
cedc : 207dce           [ 6] 	jsr gr_init_geom
                             
cedf : a920             [ 2] 	lda #' '						; Blank is SPACE
cee1 : 8510             [ 3] 	sta vdp_blank
cee3 : 2050cf           [ 6] 	jsr gr_cls
                             
                             	; Zero out hires area 0xa000 for 8000 (0x1f40) b
cee6 : a900             [ 2] 	lda #lo(HISCRN)
cee8 : 8532             [ 3] 	sta tmp_alo
ceea : a9a0             [ 2] 	lda #hi(HISCRN)
ceec : 8533             [ 3] 	sta tmp_ahi
ceee : a940             [ 2] 	lda #0x40						; Set bit 6
cef0 : a000             [ 2] 	ldy #0
cef2 : a200             [ 2] 	ldx #0
cef4 :                       vdp_fill_vram_loop
cef4 : 9132             [ 5] 	sta (tmp_alo),y
cef6 : c8               [ 2] 	iny
cef7 : d003             [ 3] 	bne vdp_fill_vram_noinc
cef9 : e633             [ 5] 	inc tmp_ahi
cefb : e8               [ 2] 	inx
cefc :                       vdp_fill_vram_noinc
cefc : e01f             [ 2] 	cpx #hi(0x1f40)			; Reached page count?
cefe : d0f4             [ 3] 	bne vdp_fill_vram_loop
cf00 : c040             [ 2] 	cpy #lo(0x1f40)			; Reached byte in page?
cf02 : d0f0             [ 4] 	bne vdp_fill_vram_loop
                             
                             	; Set hires attribute in the magic location
cf04 : a91e             [ 2] 	lda #30			; Hires attribute
cf06 : 8ddfbf           [ 4] 	sta 0xbfdf		; Last pos of screen memory
                             
cf09 : c60d             [ 5] 	dec vdp_curoff
cf0b : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_init_hires_tables
                             ;* Generate the hires tables
                             ;* Do this whilst in hires mode
                             ;****************************************
cf0c :                       gr_init_hires_tables
                             	; Initialise address pointer to start of high re
cf0c : a900             [ 2] 	lda #lo(HISCRN)
cf0e : 8532             [ 3] 	sta tmp_alo
cf10 : a9a0             [ 2] 	lda #hi(HISCRN)
cf12 : 8533             [ 3] 	sta tmp_ahi
AS65 Assembler for R6502 [1.42].                                     Page  116
---------------------------------- bank0.s -----------------------------------

                             	; Starting from row zero, do 200 rows
cf14 : a000             [ 2] 	ldy #0
cf16 :                       gr_init_tab_row
                             	; Save low and high bytes of screen address in t
cf16 : a532             [ 3] 	lda tmp_alo
cf18 : 99009c           [ 5] 	sta hires_row_low,y
cf1b : a533             [ 3] 	lda tmp_ahi
cf1d : 99c89c           [ 5] 	sta hires_row_hi,y
                             	; add 40 ready for next row
cf20 : 18               [ 2] 	clc
cf21 : a532             [ 3] 	lda tmp_alo
cf23 : 6928             [ 2] 	adc #40
cf25 : 8532             [ 3] 	sta tmp_alo
                             	_bcc 2
                             
cf29 : e633             [ 5] 	inc tmp_ahi
                             	; Max 200 rows
cf2b : c8               [ 2] 	iny
cf2c : c0c8             [ 2] 	cpy #200
cf2e : d0e6             [ 3] 	bne gr_init_tab_row
                             	; From column 0, do 240 columns
                             	; Mask starts at 0x20, when shifts to 0 then
                             	; the column increments
cf30 : a920             [ 2] 	lda #0x20
cf32 : 8534             [ 3] 	sta tmp_blo			; Pixel mask
cf34 : a200             [ 2] 	ldx #0				; Pixel column
cf36 : a000             [ 2] 	ldy #0				; Byte column
cf38 :                       gr_init_tab_col
                             	; Save current mask and column
cf38 : a534             [ 3] 	lda tmp_blo
cf3a : 9d809e           [ 5] 	sta hires_mask,x
cf3d : 98               [ 2] 	tya
cf3e : 9d909d           [ 5] 	sta hires_col,x
                             	; shift mask, if zero then increment col and res
cf41 : 4634             [ 5] 	lsr tmp_blo
cf43 : d005             [ 3] 	bne gr_init_tab_col_skip
cf45 : a920             [ 2] 	lda #0x20
cf47 : 8534             [ 3] 	sta tmp_blo
cf49 : c8               [ 2] 	iny
cf4a :                       gr_init_tab_col_skip
cf4a : e8               [ 2] 	inx
cf4b : e0f0             [ 2] 	cpx #240
cf4d : d0e9             [ 3] 	bne gr_init_tab_col
cf4f : 60               [ 6] 	rts
                             
                             
                             
                             ;****************************************
                             ;* gr_cls
                             ;* Clear the text screen
                             ;****************************************
cf50 :                       gr_cls
cf50 : e60d             [ 5] 	inc vdp_curoff
                             	; Set screen address for text mode
cf52 : a516             [ 3] 	lda gr_scrngeom+gr_text_start
cf54 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
cf56 : a517             [ 3] 	lda gr_scrngeom+gr_text_start+1
cf58 : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
                             
cf5a : a61a             [ 3] 	ldx gr_scrngeom+gr_text_h		; Count of rows to cl
                             
                             	; X and Y count bytes to fill
AS65 Assembler for R6502 [1.42].                                     Page  117
---------------------------------- bank0.s -----------------------------------

cf5c :                       gr_cls_row
cf5c : a000             [ 2] 	ldy #0							; Count of columns
cf5e : a525             [ 3] 	lda gr_scrngeom+gr_margin		; Is there a margin?
cf60 : f00a             [ 3] 	beq gr_cls_skip_marg
cf62 : a524             [ 3] 	lda gr_scrngeom+gr_paper		; Set Paper
cf64 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cf66 : c8               [ 2] 	iny
cf67 : a523             [ 3] 	lda gr_scrngeom+gr_ink			; Set Ink
cf69 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cf6b : c8               [ 2] 	iny
cf6c :                       gr_cls_skip_marg
cf6c : a510             [ 3] 	lda vdp_blank
cf6e : 850f             [ 3] 	sta vdp_curval					; Under cursor is also blank
cf70 :                       gr_cls_col
cf70 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cf72 : c8               [ 2] 	iny
cf73 : c419             [ 3] 	cpy gr_scrngeom+gr_text_w		; Done all columns?
cf75 : d0f9             [ 3] 	bne gr_cls_col
                             	; Update pointer
cf77 : 18               [ 2] 	clc
cf78 : a526             [ 3] 	lda gr_scrngeom+gr_geom_tmp
cf7a : 6519             [ 3] 	adc gr_scrngeom+gr_text_w
cf7c : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
                             	_bcc 2
                             
cf80 : e627             [ 5] 	inc gr_scrngeom+gr_geom_tmp+1
cf82 : ca               [ 2] 	dex								; 1 row done
cf83 : d0d7             [ 3] 	bne gr_cls_row					; Done all rows?
                             
                             	; set cursror position to top left
cf85 : a510             [ 3] 	lda vdp_blank
cf87 : 850f             [ 3] 	sta vdp_curval
cf89 : a625             [ 3] 	ldx gr_scrngeom+gr_margin
cf8b : a000             [ 2] 	ldy #0
cf8d : 38               [ 2] 	sec								; Init mode
cf8e : 20becf           [ 6] 	jsr gr_set_cur_init
                             
cf91 : c60d             [ 5] 	dec vdp_curoff
                             
cf93 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_getXY_base
                             ;* Get base screen address using Y coord only
                             ;* Input : X = y coord
                             ;* Output :	gr_geom_tmp updated with base
                             ;* Regs affected : A
                             ;****************************************
cf94 :                       gr_getXY_base
                             	; Find y offset using **X register**
cf94 : 18               [ 2] 	clc
cf95 : bde7d3           [ 4] 	lda gr_offset_40lo,x
cf98 : 6516             [ 3] 	adc gr_scrngeom+gr_text_start
cf9a : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
cf9c : bd03d4           [ 4] 	lda gr_offset_40hi,x
cf9f : 6517             [ 3] 	adc gr_scrngeom+gr_text_start+1
cfa1 : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
                             
                             	; A = high byte of base address
cfa3 : 60               [ 6] 	rts
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  118
---------------------------------- bank0.s -----------------------------------

                             ;* gr_plot
                             ;* Write a byte in the screen pos
                             ;* Input :	Y,X = coord, A = Byte to put
                             ;*			X = Y COORDINATE
                             ;*			Y = X COORDINATE!!
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
cfa4 :                       gr_plot
cfa4 : 48               [ 3] 	pha					; Save byte to put
cfa5 : 2094cf           [ 6] 	jsr gr_getXY_base	; base addre
cfa8 : 68               [ 4] 	pla					; Get byte to put
cfa9 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
cfab : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_put
                             ;* Write a byte in the current cursor position
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
cfac :                       gr_put
cfac : e60d             [ 5] 	inc vdp_curoff		; Disable cusror
cfae : 850f             [ 3] 	sta vdp_curval		; Update cursor value
                             	; Base address plus X offset
cfb0 : a41b             [ 3] 	ldy gr_scrngeom+gr_cur_x
cfb2 : 911d             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
cfb4 : c60d             [ 5] 	dec vdp_curoff		; Allow cursor flashing
cfb6 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_get
                             ;* Get the byte in the screen pos
                             ;* Input : Y,X = coord (**Y = X coordinate!!)
                             ;* Output : X,Y = address, A = peeked byte
                             ;* Regs affected : All
                             ;****************************************
cfb7 :                       gr_get
cfb7 : 2094cf           [ 6] 	jsr gr_getXY_base	; Base address
cfba : b126             [ 5] 	lda (gr_scrngeom+gr_geom_tmp),y
cfbc : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_set_cur
                             ;* Set the cursor position
                             ;* Input : X, Y = position
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
cfbd :                       gr_set_cur
cfbd : 18               [ 2] 	clc
cfbe :                       gr_set_cur_init
cfbe : a50d             [ 3] 	lda vdp_curoff
cfc0 : e60d             [ 5] 	inc vdp_curoff				; Disable cursor
cfc2 : b012             [ 3] 	bcs gr_set_cur_skip			; Skip restore if C=1
cfc4 : c900             [ 2] 	cmp #0						; Was cursor anyway disabled?
cfc6 : d00e             [ 3] 	bne gr_set_cur_skip			; if so then skip restore
cfc8 : 8632             [ 3] 	stx tmp_alo
cfca : 8433             [ 3] 	sty tmp_ahi
                             	; First restore what is under the cursor
AS65 Assembler for R6502 [1.42].                                     Page  119
---------------------------------- bank0.s -----------------------------------

                             	; in case cursor is ON
cfcc : 8426             [ 3] 	sty gr_scrngeom+gr_geom_tmp
cfce : a50f             [ 3] 	lda vdp_curval
cfd0 : a41b             [ 3] 	ldy gr_scrngeom+gr_cur_x
cfd2 : 911d             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
cfd4 : a426             [ 3] 	ldy gr_scrngeom+gr_geom_tmp
cfd6 :                       gr_set_cur_skip
                             	; Save new cursor position
cfd6 : 861b             [ 3] 	stx gr_scrngeom+gr_cur_x
cfd8 : 841c             [ 3] 	sty gr_scrngeom+gr_cur_y
                             
                             	; Now calculate the new cursor vram address
cfda : a61c             [ 3] 	ldx gr_scrngeom+gr_cur_y
cfdc : 2094cf           [ 6] 	jsr gr_getXY_base
                             	; Update pointer in tmp, A already has high byte
cfdf : 851e             [ 3] 	sta gr_scrngeom+gr_cur_ptr+1
cfe1 : a526             [ 3] 	lda gr_scrngeom+gr_geom_tmp
cfe3 : 851d             [ 3] 	sta gr_scrngeom+gr_cur_ptr
                             	; Read screen at this position, offset with X co
cfe5 : a41b             [ 3] 	ldy gr_scrngeom+gr_cur_x
cfe7 : b11d             [ 5] 	lda (gr_scrngeom+gr_cur_ptr),y
cfe9 : 850f             [ 3] 	sta vdp_curval
                             	; Reset cursor so it's visible
cfeb : a900             [ 2] 	lda #0
cfed : 850e             [ 3] 	sta vdp_curstat
cfef : a901             [ 2] 	lda #1
cff1 : 850c             [ 3] 	sta vdp_curcnt
                             
cff3 : c60d             [ 5] 	dec vdp_curoff
                             
cff5 : 60               [ 6] 	rts
                             
                             
                             
                             ;****************************************
                             ;* gr_scroll_up
                             ;* Scroll screen one line up
                             ;****************************************
cff6 :                       gr_scroll_up
cff6 : e60d             [ 5] 	inc vdp_curoff
                             
                             	; Set source in a and dest in b
                             	; b is first line, source is second
cff8 : 18               [ 2] 	clc
cff9 : a516             [ 3] 	lda gr_scrngeom+gr_text_start
cffb : 8534             [ 3] 	sta tmp_blo
cffd : 6519             [ 3] 	adc gr_scrngeom+gr_text_w
cfff : 8532             [ 3] 	sta tmp_alo
d001 : a517             [ 3] 	lda gr_scrngeom+gr_text_start+1
d003 : 8535             [ 3] 	sta tmp_bhi
d005 : 6900             [ 2] 	adc #0
d007 : 8533             [ 3] 	sta tmp_ahi
                             
                             	; Restore what was underneath cursor
d009 : a50f             [ 3] 	lda vdp_curval
d00b : a41b             [ 3] 	ldy gr_scrngeom+gr_cur_x
d00d : 911d             [ 5] 	sta (gr_scrngeom+gr_cur_ptr),y
                             
                             	; x = lines to scroll (1 less than screen height
d00f : a61a             [ 3] 	ldx gr_scrngeom+gr_text_h
d011 : ca               [ 2] 	dex
                             
AS65 Assembler for R6502 [1.42].                                     Page  120
---------------------------------- bank0.s -----------------------------------

d012 :                       gr_scroll_cpy_ln
                             	; Start from right hand edge (easier)
d012 : a419             [ 3] 	ldy gr_scrngeom+gr_text_w
d014 : 88               [ 2] 	dey
d015 :                       gr_scroll_char
                             	; get char from source and copy to dest
d015 : b132             [ 5] 	lda (tmp_alo),y
d017 : 9134             [ 5] 	sta (tmp_blo),y
d019 : 88               [ 2] 	dey
d01a : 10f9             [ 3] 	bpl gr_scroll_char
                             
                             	; Update source address
d01c : 18               [ 2] 	clc
d01d : a532             [ 3] 	lda tmp_alo
d01f : 6519             [ 3] 	adc gr_scrngeom+gr_text_w
d021 : 8532             [ 3] 	sta tmp_alo
                             	_bcc 2
                             
d025 : e633             [ 5] 	inc tmp_ahi
                             	; Update destination address
d027 : 18               [ 2] 	clc
d028 : a534             [ 3] 	lda tmp_blo
d02a : 6519             [ 3] 	adc gr_scrngeom+gr_text_w
d02c : 8534             [ 3] 	sta tmp_blo
                             	_bcc 2
                             
d030 : e635             [ 5] 	inc tmp_bhi
                             
                             	; One line complete
d032 : ca               [ 2] 	dex
d033 : d0dd             [ 3] 	bne gr_scroll_cpy_ln
                             
                             	; Source is pointing at last line
                             	; Last line needs filling
d035 : a000             [ 2] 	ldy #0							; Start from left
d037 : a525             [ 3] 	lda gr_scrngeom+gr_margin		; Margin?
d039 : f00a             [ 3] 	beq gr_scroll_marg				; Skip if not
d03b : a524             [ 3] 	lda gr_scrngeom+gr_paper		; Set Paper
d03d : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d03f : c8               [ 2] 	iny
d040 : a523             [ 3] 	lda gr_scrngeom+gr_ink			; Set Ink
d042 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d044 : c8               [ 2] 	iny
d045 :                       gr_scroll_marg
                             	; Needs to be filled with blank
d045 : a510             [ 3] 	lda vdp_blank
d047 : 850f             [ 3] 	sta vdp_curval			; Also this is the cursor value
d049 :                       gr_scroll_erase_ln
d049 : 9134             [ 5] 	sta (tmp_blo),y
d04b : c8               [ 2] 	iny
d04c : c419             [ 3] 	cpy gr_scrngeom+gr_text_w
d04e : d0f9             [ 3] 	bne gr_scroll_erase_ln
                             
d050 : c60d             [ 5] 	dec vdp_curoff
                             
d052 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_new_ln
                             ;* Carry out a new line
                             ;* Input : None
                             ;* Output : None
AS65 Assembler for R6502 [1.42].                                     Page  121
---------------------------------- bank0.s -----------------------------------

                             ;* Regs affected : None
                             ;****************************************
d053 :                       gr_new_ln
                             	; X pos is zero, Y needs to increment
d053 : a625             [ 3] 	ldx gr_scrngeom+gr_margin
d055 : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_y
d057 : c8               [ 2] 	iny
d058 : c41a             [ 3] 	cpy gr_scrngeom+gr_text_h
d05a : d00c             [ 3] 	bne gr_nl_skip_nl
                             	; If got here then screen needs to scroll
                             	; Common routine also used by cursor right
d05c :                       gr_scroll_routine
d05c : 88               [ 2] 	dey
d05d : 8a               [ 2] 	txa
d05e : 48               [ 3] 	pha
d05f : 98               [ 2] 	tya
d060 : 48               [ 3] 	pha
d061 : 20f6cf           [ 6] 	jsr gr_scroll_up
d064 : 68               [ 4] 	pla
d065 : a8               [ 2] 	tay
d066 : 68               [ 4] 	pla
d067 : aa               [ 2] 	tax
d068 :                       gr_nl_skip_nl
d068 : 4cbdcf           [ 3] 	jmp gr_set_cur
                             
                             
                             ;****************************************
                             ;* gr_cur_right
                             ;* Advance cursor position
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d06b :                       gr_cur_right
                             	; Load cursor x,y position
d06b : a61b             [ 3] 	ldx gr_scrngeom+gr_cur_x
d06d : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             
                             	; Move cursor right
d06f : e8               [ 2] 	inx
                             	; Check if reached past edge of line
d070 : e419             [ 3] 	cpx gr_scrngeom+gr_text_w
d072 : d0f4             [ 3] 	bne gr_nl_skip_nl
                             	; If got here then wrap to next line
d074 : a625             [ 3] 	ldx gr_scrngeom+gr_margin
d076 : c8               [ 2] 	iny
d077 : c41a             [ 3] 	cpy gr_scrngeom+gr_text_h
d079 : f0e1             [ 3] 	beq gr_scroll_routine		; Common scroll routine
d07b : d0eb             [ 3] 	bne gr_nl_skip_nl			; Common set cursor
                             
                             ;****************************************
                             ;* gr_cur_left
                             ;* Advance cursor left
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d07d :                       gr_cur_left
                             	; Load cursor x,y position, load X last to check
d07d : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_y
d07f : a61b             [ 3] 	ldx gr_scrngeom+gr_cur_x
                             
AS65 Assembler for R6502 [1.42].                                     Page  122
---------------------------------- bank0.s -----------------------------------

                             	; Decrement screen pointer
                             	; Move cursor left
d081 : e425             [ 3] 	cpx gr_scrngeom+gr_margin	; Already at left marg
d083 : d007             [ 3] 	bne gr_cur_skip_at_left		; No, then just go left
d085 : c000             [ 2] 	cpy #0						; Else check if can wrap up
d087 : f007             [ 3] 	beq gr_cur_skip_at_tl
d089 : 88               [ 2] 	dey
d08a : a619             [ 3] 	ldx gr_scrngeom+gr_text_w
d08c :                       gr_cur_skip_at_left
d08c : ca               [ 2] 	dex
d08d : 4cbdcf           [ 3] 	jmp gr_set_cur
                             
d090 :                       gr_cur_skip_at_tl
d090 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_cur_up
                             ;* Advance cursor up
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d091 :                       gr_cur_up
                             	; Load cursor x,y position, load Y last to check
d091 : a61b             [ 3] 	ldx gr_scrngeom+gr_cur_x
d093 : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_y
                             	; if y==0 then don't do anything
d095 : f0f9             [ 3] 	beq gr_cur_skip_at_tl	; Just somewhere with an r
d097 : 88               [ 2] 	dey
d098 : 4cbdcf           [ 3] 	jmp gr_set_cur
                             
                             ;****************************************
                             ;* gr_cur_down
                             ;* Advance cursor down
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d09b :                       gr_cur_down
                             	; Load cursor x,y position
d09b : a61b             [ 3] 	ldx gr_scrngeom+gr_cur_x
d09d : a41c             [ 3] 	ldy gr_scrngeom+gr_cur_y
d09f : c8               [ 2] 	iny
                             	; If already at  bottom then don't do anything
d0a0 : c41a             [ 3] 	cpy gr_scrngeom+gr_text_h			
d0a2 : f0ec             [ 3] 	beq gr_cur_skip_at_tl				; Just somewhere with a
d0a4 : 20bdcf           [ 6] 	jsr gr_set_cur
                             
d0a7 :                       gr_cur_skip_at_bot
d0a7 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* gr_del
                             ;* Action del
                             ;* Input : None
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d0a8 :                       gr_del
d0a8 : 207dd0           [ 6] 	jsr gr_cur_left
d0ab : a920             [ 2] 	lda #' '							; Put a space
AS65 Assembler for R6502 [1.42].                                     Page  123
---------------------------------- bank0.s -----------------------------------

d0ad : 4caccf           [ 3] 	jmp gr_put
                             
                             ;****************************************
                             ;* gr_get_key
                             ;* Waits for a key press, C=1 synchronous
                             ;* A = Key code, C=0 means valid code
                             ;****************************************
d0b0 :                       gr_get_key
                             	; save X,Y but A is ok to trample
d0b0 : 8a               [ 2] 	txa
d0b1 : 48               [ 3] 	pha
d0b2 : 98               [ 2] 	tya
d0b3 : 48               [ 3] 	pha
d0b4 :                       gr_get_key_2
d0b4 : 08               [ 3] 	php
d0b5 : 2051ca           [ 6] 	jsr kb_get_key
d0b8 : 9006             [ 3] 	bcc gr_key_check_key
d0ba : 28               [ 4] 	plp									; Get async pref
d0bb : b0f7             [ 3] 	bcs	gr_get_key_2					; Keep checking if sync
d0bd : 38               [ 2] 	sec
d0be : b019             [ 3] 	bcs gr_key_tidy_up					; Finish if not
d0c0 :                       gr_key_check_key						; Check the key pressed
d0c0 : c901             [ 2] 	cmp #UTF_ACK						; Copy key pressed?
d0c2 : d004             [ 3] 	bne gr_key_skip_copy
d0c4 : a50f             [ 3] 	lda vdp_curval						; If yes the get char under 
d0c6 : b00f             [ 3] 	bcs gr_key_got_key					; Always branches (n=1, c
d0c8 :                       gr_key_skip_copy
d0c8 : c914             [ 2] 	cmp #CTRL_CAPS
d0ca : d00b             [ 3] 	bne gr_key_got_key
d0cc : a52c             [ 3] 	lda kb_stat							; Toggle caps bit
d0ce : 4901             [ 2] 	eor #KB_CAPSLK
d0d0 : 852c             [ 3] 	sta kb_stat
d0d2 : 28               [ 4] 	plp									; Get back synchronous pref
d0d3 : b0df             [ 3] 	bcs gr_get_key_2					; And check again for sync
d0d5 : 900b             [ 3] 	bcc gr_key_no_key					; Else no key
d0d7 :                       gr_key_got_key
d0d7 : 28               [ 4] 	plp
d0d8 : 18               [ 2] 	clc									; Ensure C=0 for valid key
d0d9 :                       gr_key_tidy_up
                             	; restore X,Y but don't lose A
d0d9 : 8538             [ 3] 	sta tmp_d
d0db : 68               [ 4] 	pla
d0dc : a8               [ 2] 	tay
d0dd : 68               [ 4] 	pla
d0de : aa               [ 2] 	tax
d0df : a538             [ 3] 	lda tmp_d
d0e1 : 60               [ 6] 	rts
d0e2 :                       gr_key_no_key
d0e2 : 28               [ 4] 	plp
d0e3 : 38               [ 2] 	sec									; Ensure C=1 for invalid key
d0e4 : b0f3             [ 3] 	bcs gr_key_tidy_up					; Always branches
                             
                             ;****************************************
                             ;* gr_put_byte
                             ;* Put a byte out
                             ;* Input : A = Byte to put
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d0e6 :                       gr_put_byte
                             	_pushAXY
                             
AS65 Assembler for R6502 [1.42].                                     Page  124
---------------------------------- bank0.s -----------------------------------

d0ef : 20f8d0           [ 6] 	jsr gr_put_byte_low
                             	_pullAXY
                             
d0f7 :                       gr_no_special
d0f7 : 60               [ 6] 	rts
                             
d0f8 :                       gr_put_byte_low
d0f8 : c97f             [ 2] 	cmp #UTF_DEL			; Del key
d0fa : f004             [ 4] 	beq gr_process_special
d0fc : c920             [ 2] 	cmp #32					; Special char?
d0fe : b01b             [ 4] 	bcs gr_printable		; >=32 == carry clear
d100 :                       gr_process_special
                             	; Else find special behaviour to do
d100 : a2ff             [ 2] 	ldx #-1
d102 : 8532             [ 3] 	sta tmp_alo
d104 :                       gr_special_loop
d104 : e8               [ 2] 	inx
d105 : bd21d1           [ 4] 	lda gr_special_ch,x
d108 : f0ed             [ 4] 	beq gr_no_special		; Somewhere with an rts!
d10a : c532             [ 3] 	cmp tmp_alo
d10c : d0f6             [ 3] 	bne gr_special_loop
d10e : bd2ad1           [ 4] 	lda gr_special_fn_lo,x
d111 : 8532             [ 3] 	sta tmp_alo
d113 : bd32d1           [ 4] 	lda gr_special_fn_hi,x
d116 : 8533             [ 3] 	sta tmp_ahi
d118 : 6c3200           [ 6] 	jmp (tmp_alo)
                             
                             	;	Normal caracter processing here.
d11b :                       gr_printable
                             	; Place in current position and move right
d11b : 20accf           [ 6] 	jsr gr_put
d11e : 4c6bd0           [ 3] 	jmp gr_cur_right
                             
d121 :                       gr_special_ch
d121 : 0d                    	db UTF_CR
d122 : 7f                    	db UTF_DEL
d123 : 08                    	db CRSR_LEFT
d124 : 09                    	db CRSR_RIGHT
d125 : 0b                    	db CRSR_UP
d126 : 0a                    	db CRSR_DOWN
d127 : 0c                    	db UTF_FF
d128 : 07                    	db UTF_BEL
d129 : 00                    	db 0
                             
d12a :                       gr_special_fn_lo
d12a : 53                    	db lo(gr_new_ln)
d12b : a8                    	db lo(gr_del)
d12c : 7d                    	db lo(gr_cur_left)
d12d : 6b                    	db lo(gr_cur_right)
d12e : 91                    	db lo(gr_cur_up)
d12f : 9b                    	db lo(gr_cur_down)
d130 : 50                    	db lo(gr_cls)
d131 : e9                    	db lo(init_snd)
                             
d132 :                       gr_special_fn_hi
d132 : d0                    	db hi(gr_new_ln)
d133 : d0                    	db hi(gr_del)
d134 : d0                    	db hi(gr_cur_left)
d135 : d0                    	db hi(gr_cur_right)
d136 : d0                    	db hi(gr_cur_up)
d137 : d0                    	db hi(gr_cur_down)
d138 : cf                    	db hi(gr_cls)
AS65 Assembler for R6502 [1.42].                                     Page  125
---------------------------------- bank0.s -----------------------------------

d139 : d5                    	db hi(init_snd)
                             
                             ; Special command to print to the screen
                             ; Y,A=Message, zero terminated
                             ; Y=number of chars printed
d13a :                       gr_print_line
d13a : 8449             [ 3] 	sty num_tmp
d13c : 854a             [ 3] 	sta num_tmp+1
d13e : a000             [ 2] 	ldy #0
d140 :                       gr_print_msg_loop
d140 : b149             [ 5] 	lda (num_tmp),y
d142 : f006             [ 3] 	beq gr_print_msg_done
d144 : 20e6d0           [ 6] 	jsr gr_put_byte
d147 : c8               [ 2] 	iny
d148 : d0f6             [ 3] 	bne gr_print_msg_loop
d14a :                       gr_print_msg_done
d14a : 60               [ 6] 	rts
                             
                             ;******* HIRES STUFF *****
                             
                             
                             ;****************************************
                             ;* gr_hcode
                             ;* Plot bytecode at hires X,Y coordinates with co
                             ;* Input : X,Y = coord, A = Char code
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d14b :                       gr_hcode
d14b : 48               [ 3] 	pha
                             	; Set up destination position tmpalo,hi and Y
d14c : 2007d2           [ 6] 	jsr gr_point_setup
d14f : a208             [ 2] 	ldx #8				; Always do 8 rows like a character
d151 :                       gr_hcode_loop
d151 : 68               [ 4] 	pla 				; Get the code to place
d152 : 48               [ 3] 	pha					; Need to save it back
d153 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y		; Store it in d
d155 : 18               [ 2] 	clc
d156 : a526             [ 3] 	lda gr_scrngeom+gr_geom_tmp			; Update base poin
d158 : 6519             [ 3] 	adc gr_scrngeom+gr_text_w
d15a : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
                             	_bcc 2
                             
d15e : e627             [ 5] 	inc gr_scrngeom+gr_geom_tmp+1
d160 : ca               [ 2] 	dex
d161 : d0ee             [ 3] 	bne gr_hcode_loop
d163 : 68               [ 4] 	pla
d164 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_hchar
                             ;* Plot character to hires X,Y coordinates with c
                             ;* Input : X,Y = coord, A = Char code
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d165 :                       gr_hchar
                             	; If char code < 32 then plot attribute
d165 : c91f             [ 2] 	cmp #31
d167 : 90e2             [ 3] 	bcc gr_hcode
                             	; Multiply char code by 8
                             	; and add to char font base
AS65 Assembler for R6502 [1.42].                                     Page  126
---------------------------------- bank0.s -----------------------------------

                             	; tmp_clo contains base address
d169 : 0a               [ 2] 	asl a
d16a : 2637             [ 5] 	rol tmp_chi
d16c : 0a               [ 2] 	asl a
d16d : 2637             [ 5] 	rol tmp_chi
d16f : 0a               [ 2] 	asl a
d170 : 2637             [ 5] 	rol tmp_chi
d172 : 18               [ 2] 	clc
d173 : 6514             [ 3] 	adc gr_scrngeom+gr_char
d175 : 8536             [ 3] 	sta tmp_clo
d177 : a537             [ 3] 	lda tmp_chi
d179 : 2907             [ 2] 	and #7
d17b : 6515             [ 3] 	adc gr_scrngeom+gr_char+1
d17d : 8537             [ 3] 	sta tmp_chi
                             
                             	; Set up destination position
d17f : 2007d2           [ 6] 	jsr gr_point_setup
                             	; tmp needs to contains address including column
d182 : 18               [ 2] 	clc
d183 : 98               [ 2] 	tya
d184 : 6526             [ 3] 	adc gr_scrngeom+gr_geom_tmp
d186 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
                             	_bcc 2
                             
d18a : e627             [ 5] 	inc gr_scrngeom+gr_geom_tmp+1
                             
d18c : a528             [ 3] 	lda gr_scrngeom+gr_geom_tmp2		; Get the mask
d18e : a207             [ 2] 	ldx #7
d190 :                       gr_hchar_mask							; Calculate how many shifts t
d190 : ca               [ 2] 	dex
d191 : 4a               [ 2] 	lsr a
d192 : d0fc             [ 3] 	bne gr_hchar_mask
d194 : 8628             [ 3] 	stx gr_scrngeom+gr_geom_tmp2		; number between 1
                             
                             	; copy font bytes and shift the required number 
                             	; go from bottom to top as data gets stored on t
d196 : a007             [ 2] 	ldy #7
d198 :                       gr_hchar_getfont
d198 : b136             [ 5] 	lda (tmp_clo),y
d19a : 853d             [ 3] 	sta ztmp_24
d19c : a900             [ 2] 	lda #0
d19e : 853e             [ 3] 	sta ztmp_24+1
                             
                             	; shift the right number of times
d1a0 : a628             [ 3] 	ldx gr_scrngeom+gr_geom_tmp2
d1a2 :                       gr_hchar_rot1bit
d1a2 : ca               [ 2] 	dex
d1a3 : f00d             [ 3] 	beq gr_hchar_rot1bit_nx
d1a5 : 463d             [ 5] 	lsr ztmp_24					; Rotate left hand side
d1a7 : a53e             [ 3] 	lda ztmp_24+1				; Rotate right hand side
d1a9 : 9002             [ 3] 	bcc gr_hchar_rot1bit_bcc
d1ab : 0940             [ 2] 	ora #0x40					; account for 6 bits per byte
d1ad :                       gr_hchar_rot1bit_bcc
d1ad : 4a               [ 2] 	lsr a
d1ae : 853e             [ 3] 	sta ztmp_24+1
d1b0 : 10f0             [ 3] 	bpl gr_hchar_rot1bit		; Always as lsr sets N=0
d1b2 :                       gr_hchar_rot1bit_nx
d1b2 : a53e             [ 3] 	lda ztmp_24+1				; Get RHS
d1b4 : 48               [ 3] 	pha							; Push RHS on to stack
d1b5 : a53d             [ 3] 	lda ztmp_24					; Get LHS
d1b7 : 48               [ 3] 	pha							; Push that too - LH gets pulled first
d1b8 : 88               [ 2] 	dey							; Bottom to to lines
AS65 Assembler for R6502 [1.42].                                     Page  127
---------------------------------- bank0.s -----------------------------------

d1b9 : 10dd             [ 3] 	bpl gr_hchar_getfont
                             
                             	; Now copy shift source to destination, accounti
d1bb : a208             [ 2] 	ldx #8
d1bd :                       gr_hchar_copyline
d1bd : a41f             [ 3] 	ldy gr_scrngeom+gr_pixmode	; Mode determines how
d1bf : f022             [ 3] 	beq gr_hchar_copyline_erase
d1c1 : 3010             [ 3] 	bmi gr_hchar_copyline_eor
                             
                             	; Mode = ~Z : OR
d1c3 : a000             [ 2] 	ldy #0						; Get lh side source
d1c5 : 68               [ 4] 	pla
d1c6 : 1126             [ 5] 	ora (gr_scrngeom+gr_geom_tmp),y
d1c8 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d1ca : c8               [ 2] 	iny							; Get rh side source
d1cb : 68               [ 4] 	pla
d1cc : 1126             [ 5] 	ora (gr_scrngeom+gr_geom_tmp),y
d1ce : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d1d0 : 4cf8d1           [ 3] 	jmp gr_hchar_copyline_nx
d1d3 :                       gr_hchar_copyline_eor
                             	; Mode = N : EOR
d1d3 : a000             [ 2] 	ldy #0						; Get lh side source
d1d5 : 68               [ 4] 	pla
d1d6 : 5126             [ 5] 	eor (gr_scrngeom+gr_geom_tmp),y
d1d8 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d1da : c8               [ 2] 	iny							; Get rh side source
d1db : 68               [ 4] 	pla
d1dc : 5126             [ 5] 	eor (gr_scrngeom+gr_geom_tmp),y
d1de : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d1e0 : 4cf8d1           [ 3] 	jmp gr_hchar_copyline_nx
d1e3 :                       gr_hchar_copyline_erase
                             	; Mode = Z : erase
d1e3 : a000             [ 2] 	ldy #0						; Get lh side source
d1e5 : 68               [ 4] 	pla
d1e6 : 853d             [ 3] 	sta ztmp_24
d1e8 : 1126             [ 5] 	ora (gr_scrngeom+gr_geom_tmp),y
d1ea : 453d             [ 3] 	eor ztmp_24
d1ec : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d1ee : c8               [ 2] 	iny							; Get rh side source
d1ef : 68               [ 4] 	pla
d1f0 : 853d             [ 3] 	sta ztmp_24
d1f2 : 1126             [ 5] 	ora (gr_scrngeom+gr_geom_tmp),y
d1f4 : 453d             [ 3] 	eor ztmp_24
d1f6 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d1f8 :                       gr_hchar_copyline_nx
d1f8 : 18               [ 2] 	clc							; Next address
d1f9 : a526             [ 3] 	lda gr_scrngeom+gr_geom_tmp
d1fb : 6928             [ 2] 	adc #40
d1fd : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
                             	_bcc 2
                             
d201 : e627             [ 5] 	inc gr_scrngeom+gr_geom_tmp+1
d203 : ca               [ 2] 	dex
d204 : d0b7             [ 4] 	bne gr_hchar_copyline
d206 : 60               [ 6] 	rts							; Done after 8 lines
                             
                             ;****************************************
                             ;* gr_point_setup
                             ;* Calculate information about a pixel location
                             ;* Input : X,Y = coord
                             ;* Output : None
                             ;* Regs affected :
AS65 Assembler for R6502 [1.42].                                     Page  128
---------------------------------- bank0.s -----------------------------------

                             ;* gr_geom_tmp contains the row base address
                             ;* gr_geom_tmp2 contains the mask
                             ;* A contains the mask
                             ;* X untouched
                             ;* Y contains column offet from base address
                             ;****************************************
d207 :                       gr_point_setup
                             	; Get row address
d207 : b9009c           [ 4] 	lda hires_row_low,y
d20a : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d20c : b9c89c           [ 4] 	lda hires_row_hi,y
d20f : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
                             	; Get the pixel mask
d211 : bd809e           [ 4] 	lda hires_mask,x
d214 : 8528             [ 3] 	sta gr_scrngeom+gr_geom_tmp2
                             	; Get the column offset to Y
d216 : bc909d           [ 4] 	ldy hires_col,x
d219 : 60               [ 6] 	rts
                             
d21a :                       gr_set_hires_cur
d21a : 8621             [ 3] 	stx gr_scrngeom+gr_hires_x
d21c : 8422             [ 3] 	sty gr_scrngeom+gr_hires_y
d21e : 60               [ 6] 	rts
                             
                             ;* Get pixel value at X,Y in to A
d21f :                       gr_pixel
d21f : 2007d2           [ 6] 	jsr gr_point_setup				; Set up mask and addresse
d222 : 3126             [ 5] 	and (gr_scrngeom+gr_geom_tmp),y	; And with scree
d224 : 60               [ 6] 	rts
                             
                             ;* Plot a point based on X,Y coordinates
d225 :                       gr_point
d225 : e0f0             [ 2] 	cpx #240						; Check bounds
d227 : b02c             [ 3] 	bcs gr_point_done
d229 : c0c8             [ 2] 	cpy #200
d22b : b028             [ 3] 	bcs gr_point_done
                             
                             	;** FOR SPEED COPYING THE POINT SETUP ROUTINE **
                             	;** OBVS MAKE SURE THIS REFLECTS ANY POINT SETUP
                             	; Get row address
d22d : b9009c           [ 4] 	lda hires_row_low,y
d230 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d232 : b9c89c           [ 4] 	lda hires_row_hi,y
d235 : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
                             	; Get the pixel mask
d237 : bd809e           [ 4] 	lda hires_mask,x
d23a : 8528             [ 3] 	sta gr_scrngeom+gr_geom_tmp2
                             	; Get the column offset to Y
d23c : bc909d           [ 4] 	ldy hires_col,x
                             
                             ;* Plot a point based on gr_geom_tmp base, Y offs
d23f : b126             [ 5] 	lda (gr_scrngeom+gr_geom_tmp),y	; Get screen byt
d241 : c920             [ 2] 	cmp #32							; If less than 32 (i.e. an attribu
d243 : b002             [ 3] 	bcs gr_point_skip_attr
d245 : a940             [ 2] 	lda #64							; then make it a normal cell (else
d247 :                       gr_point_skip_attr
d247 : a61f             [ 3] 	ldx gr_scrngeom+gr_pixmode		; Look at the mode
d249 : 3006             [ 3] 	bmi gr_point_eor				; If eor mode then go and wr
d24b : 0528             [ 3] 	ora gr_scrngeom+gr_geom_tmp2	; Or with MASK
d24d : e000             [ 2] 	cpx #0							; But if zero mode then eor
d24f : d002             [ 3] 	bne gr_point_write
d251 :                       gr_point_eor
AS65 Assembler for R6502 [1.42].                                     Page  129
---------------------------------- bank0.s -----------------------------------

d251 : 4528             [ 3] 	eor gr_scrngeom+gr_geom_tmp2	; EOR with MASK
d253 :                       gr_point_write
d253 : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y
d255 :                       gr_point_done
d255 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* gr_circle
                             ;* Draw a circle centre x0,y0, radius r
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
                             ;*			num_a+2 = r
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d256 :                       gr_circle
                             ; Local definitions of temp space to make
                             ; the rest of the code easier to read
003d =                       grc_x0 	= (num_a)
003e =                       grc_y0 	= (num_a+1)
003f =                       grc_r 	= (num_a+2)
0040 =                       grc_x 	= (num_a+3)
0042 =                       grc_y	= (num_b+1)
0043 =                       grc_d	= (num_b+2)
                             
                             	;x = radius
d256 : a53f             [ 3] 	lda grc_r
d258 : 8540             [ 3] 	sta grc_x
                             	;decision = 1 - x
d25a : a900             [ 2] 	lda #0
                             	;y = 0
d25c : 8542             [ 3] 	sta grc_y
d25e : 18               [ 2] 	clc			; A=0 so CLC subtracts 1 :-)
d25f : e540             [ 3] 	sbc grc_x
d261 : 8543             [ 3] 	sta grc_d
d263 :                       gr_circle_plot
                             	;while(x >= y)
d263 : a540             [ 3] 	lda grc_x
d265 : c542             [ 3] 	cmp grc_y
d267 : 902a             [ 3] 	bcc gr_circle_done
                             	;plot 8 points on current x,y
d269 : 2094d2           [ 6] 	jsr gr_circle_points
                             	;y++
d26c : e642             [ 5] 	inc grc_y
                             	;if d<=0
d26e : a543             [ 3] 	lda grc_d
d270 : f014             [ 3] 	beq gr_circle_d_lte0
d272 : 3012             [ 3] 	bmi gr_circle_d_lte0
                             	;else
                             	;x--
d274 : c640             [ 5] 	dec grc_x
                             	;decision += 2 * (y - x) + 1
d276 : a542             [ 3] 	lda grc_y
d278 : 38               [ 2] 	sec
d279 : e540             [ 3] 	sbc grc_x
d27b : 0a               [ 2] 	asl a
d27c : 18               [ 2] 	clc
d27d : 6901             [ 2] 	adc #1
d27f : 6543             [ 3] 	adc grc_d
d281 : 8543             [ 3] 	sta grc_d
d283 : 4c63d2           [ 3] 	jmp gr_circle_plot
d286 :                       gr_circle_d_lte0
AS65 Assembler for R6502 [1.42].                                     Page  130
---------------------------------- bank0.s -----------------------------------

                             	;decision += 2 * y + 1
d286 : a542             [ 3] 	lda grc_y
d288 : 0a               [ 2] 	asl a
d289 : 18               [ 2] 	clc
d28a : 6901             [ 2] 	adc #1
d28c : 6543             [ 3] 	adc grc_d
d28e : 8543             [ 3] 	sta grc_d
d290 : 4c63d2           [ 3] 	jmp gr_circle_plot
d293 :                       gr_circle_done
d293 : 60               [ 6] 	rts
d294 :                       gr_circle_points
                             ; Local names of temp storage
                             ; to make code easier to read
                             	;DrawPixel( x + x0,  yh + y0);
d294 : a540             [ 3] 	lda grc_x
d296 : 18               [ 2] 	clc
d297 : 653d             [ 3] 	adc grc_x0
d299 : aa               [ 2] 	tax
d29a : a542             [ 3] 	lda grc_y
d29c : 18               [ 2] 	clc
d29d : 653e             [ 3] 	adc grc_y0
d29f : a8               [ 2] 	tay
d2a0 : 2025d2           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0,  xh + y0);
d2a3 : a542             [ 3] 	lda grc_y
d2a5 : 18               [ 2] 	clc
d2a6 : 653d             [ 3] 	adc grc_x0
d2a8 : aa               [ 2] 	tax
d2a9 : a540             [ 3] 	lda grc_x
d2ab : 18               [ 2] 	clc
d2ac : 653e             [ 3] 	adc grc_y0
d2ae : a8               [ 2] 	tay
d2af : 2025d2           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0,  yh + y0);
d2b2 : a53d             [ 3] 	lda grc_x0
d2b4 : 38               [ 2] 	sec
d2b5 : e540             [ 3] 	sbc grc_x
d2b7 : aa               [ 2] 	tax
d2b8 : a542             [ 3] 	lda grc_y
d2ba : 18               [ 2] 	clc
d2bb : 653e             [ 3] 	adc grc_y0
d2bd : a8               [ 2] 	tay
d2be : 2025d2           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0,  xh + y0);
d2c1 : a53d             [ 3] 	lda grc_x0
d2c3 : 38               [ 2] 	sec
d2c4 : e542             [ 3] 	sbc grc_y
d2c6 : aa               [ 2] 	tax
d2c7 : a540             [ 3] 	lda grc_x
d2c9 : 18               [ 2] 	clc
d2ca : 653e             [ 3] 	adc grc_y0
d2cc : a8               [ 2] 	tay
d2cd : 2025d2           [ 6] 	jsr gr_point
                             	;DrawPixel(-x + x0, -yh + y0);
d2d0 : a53d             [ 3] 	lda grc_x0
d2d2 : 38               [ 2] 	sec
d2d3 : e540             [ 3] 	sbc grc_x
d2d5 : aa               [ 2] 	tax
d2d6 : a53e             [ 3] 	lda grc_y0
d2d8 : 38               [ 2] 	sec
d2d9 : e542             [ 3] 	sbc grc_y
d2db : a8               [ 2] 	tay
AS65 Assembler for R6502 [1.42].                                     Page  131
---------------------------------- bank0.s -----------------------------------

d2dc : 2025d2           [ 6] 	jsr gr_point
                             	;DrawPixel(-y + x0, -xh + y0);
d2df : a53d             [ 3] 	lda grc_x0
d2e1 : 38               [ 2] 	sec
d2e2 : e542             [ 3] 	sbc grc_y
d2e4 : aa               [ 2] 	tax
d2e5 : a53e             [ 3] 	lda grc_y0
d2e7 : 38               [ 2] 	sec
d2e8 : e540             [ 3] 	sbc grc_x
d2ea : a8               [ 2] 	tay
d2eb : 2025d2           [ 6] 	jsr gr_point
                             	;DrawPixel( x + x0, -yh + y0);
d2ee : a540             [ 3] 	lda grc_x
d2f0 : 18               [ 2] 	clc
d2f1 : 653d             [ 3] 	adc grc_x0
d2f3 : aa               [ 2] 	tax
d2f4 : a53e             [ 3] 	lda grc_y0
d2f6 : 38               [ 2] 	sec
d2f7 : e542             [ 3] 	sbc grc_y
d2f9 : a8               [ 2] 	tay
d2fa : 2025d2           [ 6] 	jsr gr_point
                             	;DrawPixel( y + x0, -xh + y0);
d2fd : a542             [ 3] 	lda grc_y
d2ff : 18               [ 2] 	clc
d300 : 653d             [ 3] 	adc grc_x0
d302 : aa               [ 2] 	tax
d303 : a53e             [ 3] 	lda grc_y0
d305 : 38               [ 2] 	sec
d306 : e540             [ 3] 	sbc grc_x
d308 : a8               [ 2] 	tay
d309 : 4c25d2           [ 3] 	jmp gr_point
                             
                             
                             
                             ;****************************************
                             ;* gr_line
                             ;* Draw a line from x0,y0 -> x1,y1
                             ;* Input :	num_a   = x0
                             ;*			num_a+1 = y0
                             ;*			num_a+2 = x1
                             ;*			num_a+3 = y1
                             ;* Output : None
                             ;* Regs affected : None
                             ;****************************************
d30c :                       gr_line
                             
                             ; Local definitions of temp space to make
                             ; the rest of the code easier to read
003d =                       grl_x0 	= (num_a)
003e =                       grl_y0 	= (num_a+1)
003f =                       grl_x1 	= (num_a+2)
0040 =                       grl_y1 	= (num_a+3)
0041 =                       grl_dx	= (ztmp_24+4)
0042 =                       grl_dy	= (ztmp_24+5)
0043 =                       grl_xyyx= (ztmp_24+6)
0044 =                       grl_2dx	= (ztmp_24+7)			; Word
0046 =                       grl_2dy	= (ztmp_24+9)			; Word
0048 =                       grl_2dxy= (ztmp_24+11)			; Word
004a =                       grl_sinx= (ztmp_24+13)
004b =                       grl_p	= (ztmp_24+14)			; Word
004d =                       grl_siny= (ztmp_24+16)
                             
AS65 Assembler for R6502 [1.42].                                     Page  132
---------------------------------- bank0.s -----------------------------------

                             	; Start from hires cursor position
                             	; New cursor pos = end of line pos
d30c : a521             [ 3] 	lda gr_scrngeom+gr_hires_x
d30e : 853d             [ 3] 	sta grl_x0
d310 : a522             [ 3] 	lda gr_scrngeom+gr_hires_y
d312 : 853e             [ 3] 	sta grl_y0
d314 : a63f             [ 3] 	ldx grl_x1
d316 : a440             [ 3] 	ldy grl_y1
d318 : 201ad2           [ 6] 	jsr gr_set_hires_cur
                             	
d31b : a900             [ 2] 	lda #0
d31d : 8543             [ 3] 	sta grl_xyyx				; Assume normal xy axis
                             
                             	; check if abs(dy)>abs(dx) if so need to swap xy
                             	; num_b = abs(x), num_b+1 = abs(dy)
d31f : 38               [ 2] 	sec
d320 : a53f             [ 3] 	lda grl_x1
d322 : e53d             [ 3] 	sbc grl_x0
d324 : b004             [ 3] 	bcs gr_line_skip_dx_neg
d326 : 49ff             [ 2] 	eor #0xff
d328 : 6901             [ 2] 	adc #1
d32a :                       gr_line_skip_dx_neg
d32a : 8541             [ 3] 	sta grl_dx
d32c : 38               [ 2] 	sec
d32d : a540             [ 3] 	lda grl_y1
d32f : e53e             [ 3] 	sbc grl_y0
d331 : b004             [ 3] 	bcs gr_line_skip_dy_neg
d333 : 49ff             [ 2] 	eor #0xff
d335 : 6901             [ 2] 	adc #1
d337 :                       gr_line_skip_dy_neg
d337 : 8542             [ 3] 	sta grl_dy
d339 : c541             [ 3] 	cmp grl_dx
d33b : 901a             [ 3] 	bcc gr_line_skip_xy_swap
                             	; swap xy axes and also dx and dy
d33d : a53d             [ 3] 	lda grl_x0					; swap x0 and y0
d33f : a63e             [ 3] 	ldx grl_y0
d341 : 853e             [ 3] 	sta grl_y0
d343 : 863d             [ 3] 	stx grl_x0
d345 : a53f             [ 3] 	lda grl_x1					; swap x1 and y1
d347 : a640             [ 3] 	ldx grl_y1
d349 : 8540             [ 3] 	sta grl_y1
d34b : 863f             [ 3] 	stx grl_x1
d34d : a541             [ 3] 	lda grl_dx					; swap dy and dx
d34f : a642             [ 3] 	ldx grl_dy
d351 : 8542             [ 3] 	sta grl_dy
d353 : 8641             [ 3] 	stx grl_dx
d355 : e643             [ 5] 	inc grl_xyyx				; set flag to Not Z to know abou
                             
d357 :                       gr_line_skip_xy_swap
                             	; assume going from left to right and top to bot
d357 : a901             [ 2] 	lda #1
d359 : a0ff             [ 2] 	ldy #255					; -1
d35b : 854a             [ 3] 	sta grl_sinx
d35d : 854d             [ 3] 	sta grl_siny
                             
                             	; check going right to left
d35f : a53d             [ 3] 	lda grl_x0
d361 : c53f             [ 3] 	cmp grl_x1
d363 : 9002             [ 3] 	bcc gr_line_skip_left
d365 : 844a             [ 3] 	sty grl_sinx				; make -1
d367 :                       gr_line_skip_left
                             	; check going bottom to top
AS65 Assembler for R6502 [1.42].                                     Page  133
---------------------------------- bank0.s -----------------------------------

d367 : a53e             [ 3] 	lda grl_y0
d369 : c540             [ 3] 	cmp grl_y1
d36b : 9002             [ 3] 	bcc gr_line_skip_y_up
d36d : 844d             [ 3] 	sty grl_siny				; make -1
                             
d36f :                       gr_line_skip_y_up
d36f : a541             [ 3] 	lda grl_dx
d371 : 0a               [ 2] 	asl a
d372 : 8544             [ 3] 	sta grl_2dx					; 2*dx (word)
d374 : a900             [ 2] 	lda #0
d376 : 8545             [ 3] 	sta grl_2dx+1
d378 : 2645             [ 5] 	rol grl_2dx+1
                             
d37a : a542             [ 3] 	lda grl_dy
d37c : 0a               [ 2] 	asl a
d37d : 8546             [ 3] 	sta grl_2dy					; 2*dy (word)
d37f : a900             [ 2] 	lda #0
d381 : 8547             [ 3] 	sta grl_2dy+1
d383 : 2647             [ 5] 	rol grl_2dy+1
                             
                             ;    p=2*dy-dx;					; p (word)
d385 : 38               [ 2] 	sec
d386 : a546             [ 3] 	lda grl_2dy
d388 : e541             [ 3] 	sbc grl_dx
d38a : 854b             [ 3] 	sta grl_p
d38c : a547             [ 3] 	lda grl_2dy+1
d38e : e900             [ 2] 	sbc #0
d390 : 854c             [ 3] 	sta grl_p+1
                             
                             ;   2*(dy-dx)					; num_tmp+2 = 2*(dy-dx)
d392 : 38               [ 2] 	sec
d393 : a546             [ 3] 	lda grl_2dy
d395 : e544             [ 3] 	sbc grl_2dx
d397 : 8548             [ 3] 	sta grl_2dxy
d399 : a547             [ 3] 	lda grl_2dy+1
d39b : e545             [ 3] 	sbc grl_2dx+1
d39d : 8549             [ 3] 	sta grl_2dxy+1
                             
d39f :                       gr_line_pixel
d39f : a63d             [ 3] 	ldx grl_x0
d3a1 : a43e             [ 3] 	ldy grl_y0
d3a3 : a543             [ 3] 	lda grl_xyyx				; Swapped?
d3a5 : f004             [ 3] 	beq gr_line_yx_skip
d3a7 : a63e             [ 3] 	ldx grl_y0
d3a9 : a43d             [ 3] 	ldy grl_x0
d3ab :                       gr_line_yx_skip
d3ab : 2025d2           [ 6] 	jsr gr_point				; Plot point x,y
                             
d3ae : a53d             [ 3] 	lda grl_x0					; Check if done
d3b0 : c53f             [ 3] 	cmp grl_x1
d3b2 : f032             [ 3] 	beq gr_line_done
                             
                             	; Increment x always
d3b4 : 18               [ 2] 	clc
d3b5 : a53d             [ 3] 	lda grl_x0
d3b7 : 654a             [ 3] 	adc grl_sinx
d3b9 : 853d             [ 3] 	sta grl_x0
                             
                             	; check sign of p
d3bb : a54c             [ 3] 	lda grl_p+1
d3bd : 3017             [ 3] 	bmi gr_line_neg_p
                             
AS65 Assembler for R6502 [1.42].                                     Page  134
---------------------------------- bank0.s -----------------------------------

                             	; if p >=0
                             
                             	; y=y+increment
d3bf : 18               [ 2] 	clc
d3c0 : a53e             [ 3] 	lda grl_y0
d3c2 : 654d             [ 3] 	adc grl_siny
d3c4 : 853e             [ 3] 	sta grl_y0
                             
                             	; p=p+2*dy-2*dx
                             	_addZPWord grl_p,grl_2dxy
                             
d3d3 : 4c9fd3           [ 3] 	jmp gr_line_pixel
                             
d3d6 :                       gr_line_neg_p
                             	; if p < 0
                             	; p=p+2*dy
                             	_addZPWord grl_p,grl_2dy
                             
                             
d3e3 : 4c9fd3           [ 3] 	jmp gr_line_pixel
d3e6 :                       gr_line_done
d3e6 : 60               [ 6] 	rts
                             
                             
                             ; Line drawing pseudo code
                             ;    while(x<x1)
                             ;    {
                             ;        putpixel(x,y);
                             ;        if(p>=0)
                             ;        {
                             ;            y=y+1;
                             ;            p=p+2*dy-2*dx;
                             ;        }
                             ;        else
                             ;        {
                             ;            p=p+2*dy;
                             ;        }
                             ;        x=x+1;
                             ;    }
                             
                             
                             ;* These tables are to speed up calculating the
                             ;* offset for plot commands
d3e7 :                       gr_offset_40lo
d3e7 : 00285078a0            	db lo(000*40), lo(001*40), lo(002*40), lo(003*40
d3ec : c8f0184068            	db lo(005*40), lo(006*40), lo(007*40), lo(008*40
d3f1 : 90b8e00830            	db lo(010*40), lo(011*40), lo(012*40), lo(013*40
d3f6 : 5880a8d0f8            	db lo(015*40), lo(016*40), lo(017*40), lo(018*40
d3fb : 20487098c0            	db lo(020*40), lo(021*40), lo(022*40), lo(023*40
d400 : e81038                	db lo(025*40), lo(026*40), lo(027*40)
d403 :                       gr_offset_40hi
d403 : 0000000000            	db hi(000*40), hi(001*40), hi(002*40), hi(003*40
d408 : 0000010101            	db hi(005*40), hi(006*40), hi(007*40), hi(008*40
d40d : 0101010202            	db hi(010*40), hi(011*40), hi(012*40), hi(013*40
d412 : 0202020202            	db hi(015*40), hi(016*40), hi(017*40), hi(018*40
d417 : 0303030303            	db hi(020*40), hi(021*40), hi(022*40), hi(023*40
d41c : 030404                	db hi(025*40), hi(026*40), hi(027*40)
                             
                             
                             ;* Character based sprites for text mode only
d41f :                       mod_sz_sprite_s
                             ;* Initialisation
AS65 Assembler for R6502 [1.42].                                     Page  135
---------------------------------- bank0.s -----------------------------------

d41f :                       gr_spr_init
d41f : a21f             [ 2] 	ldx #31							; Start at last sprite
d421 :                       gr_spr_init_loop
d421 : a9ff             [ 2] 	lda #-1							; Put -1 in the x coords
d423 : 9d00b4           [ 5] 	sta spr_curX,x
d426 : 9d20b4           [ 5] 	sta spr_newX,x
d429 : ca               [ 2] 	dex								; Next sprite
d42a : 10f5             [ 3] 	bpl gr_spr_init_loop			; Until all 32 sprites in
d42c : 60               [ 6] 	rts
                             
                             
                             ;* Erase all active sprites
d42d :                       gr_spr_erase
                             	; First restore background from sprites
                             	; that are active and new pos is different from 
d42d : a21f             [ 2] 	ldx #31							; Start at last sprite
d42f :                       gr_spr_erase_loop
d42f : bd00b4           [ 4] 	lda spr_curX,x					; Is sprite active?
d432 : 3007             [ 3] 	bmi gr_spr_erase_next
d434 : a8               [ 2] 	tay								; x pos in to Y
d435 :                       gr_spr_erase_do
d435 : bda0b4           [ 4] 	lda spr_bgnd,x					; Get the background
d438 : 2083d4           [ 6] 	jsr gr_spr_put					; And restore it
d43b :                       gr_spr_erase_next
d43b : ca               [ 2] 	dex
d43c : 10f1             [ 3] 	bpl gr_spr_erase_loop
d43e : 60               [ 6] 	rts
                             
                             ;* Get ready for new position
d43f :                       gr_spr_new
d43f : a21f             [ 2] 	ldx #31							; Start at last sprite
d441 :                       gr_spr_new_loop
d441 : bd60b4           [ 4] 	lda spr_newY,x					; Get new Y
d444 : 9d40b4           [ 5] 	sta spr_curY,x					; Update new->cur Y
d447 : a8               [ 2] 	tay								; Used for address calc.
d448 : bd20b4           [ 4] 	lda spr_newX,x					; Get new X
d44b : 9d00b4           [ 5] 	sta spr_curX,x					; Update new->cur X
d44e : 301d             [ 3] 	bmi gr_spr_new_next				; Is the new position act
d450 : 48               [ 3] 	pha 							; x pos saved for later
                             	; Calculate screen address
                             	; save as part of sprite data and in zp area
d451 : 18               [ 2] 	clc
d452 : b9e7d3           [ 4] 	lda gr_offset_40lo,y
d455 : 6980             [ 2] 	adc #lo(TEXTSCRN)
d457 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d459 : 9dc0b4           [ 5] 	sta spr_baseadrl,x
d45c : b903d4           [ 4] 	lda gr_offset_40hi,y
d45f : 69bb             [ 2] 	adc #hi(TEXTSCRN)
d461 : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
d463 : 9de0b4           [ 5] 	sta spr_baseadrh,x
d466 : 68               [ 4] 	pla								; Get x pos back in to Y reg
d467 : a8               [ 2] 	tay
d468 : b126             [ 5] 	lda (gr_scrngeom+gr_geom_tmp),y	; Get background
d46a : 9da0b4           [ 5] 	sta spr_bgnd,x					; And save this
d46d :                       gr_spr_new_next
d46d : ca               [ 2] 	dex
d46e : 10d1             [ 3] 	bpl gr_spr_new_loop
d470 : 60               [ 6] 	rts
                             
                             
                             ; Draw all active sprites
                             ; Active sprites are always drawn - 0 = highest p
AS65 Assembler for R6502 [1.42].                                     Page  136
---------------------------------- bank0.s -----------------------------------

d471 :                       gr_spr_draw
d471 : a21f             [ 2] 	ldx #31							; Start at last sprite
d473 :                       gr_spr_draw_loop
d473 : bd20b4           [ 4] 	lda spr_newX,x					; Is sprite active?
d476 : 3007             [ 3] 	bmi gr_spr_draw_next
d478 : a8               [ 2] 	tay								; X pos in to Y
d479 : bd80b4           [ 4] 	lda spr_chr,x					; Get the sprite char
d47c : 2083d4           [ 6] 	jsr gr_spr_put
d47f :                       gr_spr_draw_next
d47f : ca               [ 2] 	dex
d480 : 10f1             [ 3] 	bpl gr_spr_draw_loop
d482 : 60               [ 6] 	rts
                             
                             
                             ;* Common routine to put A to screen address
                             ;* Used for erase and draw of sprites
                             ;* X=index in to sprite table
                             ;* Y=X offset from screen pointer
d483 :                       gr_spr_put
d483 : 48               [ 3] 	pha
d484 : bdc0b4           [ 4] 	lda spr_baseadrl,x		; Get the screen pointer
d487 : 8526             [ 3] 	sta gr_scrngeom+gr_geom_tmp
d489 : bde0b4           [ 4] 	lda spr_baseadrh,x
d48c : 8527             [ 3] 	sta gr_scrngeom+gr_geom_tmp+1
d48e : 68               [ 4] 	pla								; Get back the char to
d48f : 9126             [ 5] 	sta (gr_scrngeom+gr_geom_tmp),y	; put on to scre
d491 : 60               [ 6] 	rts
                             
                             
                             ;* Update spr A with char X
d492 :                       gr_spr_char
d492 : a8               [ 2] 	tay
d493 : 8a               [ 2] 	txa
d494 : 9980b4           [ 5] 	sta spr_chr,y
d497 : 60               [ 6] 	rts
                             
                             ;* Locate what is at the location of sprite A, re
                             ;* C=1 if sprite it not active
d498 :                       gr_spr_hit
d498 : aa               [ 2] 	tax
d499 : bd00b4           [ 4] 	lda spr_curX,x
d49c : c980             [ 2] 	cmp #0x80						; If A>=0x80 then C=1
d49e : bda0b4           [ 4] 	lda spr_bgnd,x
d4a1 : 60               [ 6] 	rts
                             
                             ;* Update spr A with coords X,Y
d4a2 :                       gr_spr_pos
d4a2 : 8432             [ 3] 	sty tmp_alo
d4a4 : a8               [ 2] 	tay
d4a5 : 8a               [ 2] 	txa								; X coord still in X reg
d4a6 : 9920b4           [ 5] 	sta spr_newX,y
d4a9 : a532             [ 3] 	lda tmp_alo						; Y coord from temp
d4ab : 9960b4           [ 5] 	sta spr_newY,y
d4ae : 60               [ 6] 	rts
                             
                             ;* Update all sprite positions from df_tmpptra, d
d4af :                       gr_spr_multi_pos
d4af : a03e             [ 2] 	ldy #62
d4b1 : a21f             [ 2] 	ldx #31
d4b3 :                       gr_spr_multi_loop
d4b3 : b1a2             [ 5] 	lda (df_tmpptra),y
d4b5 : 9d20b4           [ 5] 	sta spr_newX,x
AS65 Assembler for R6502 [1.42].                                     Page  137
---------------------------------- bank0.s -----------------------------------

d4b8 : b1a4             [ 5] 	lda (df_tmpptrb),y
d4ba : 9d60b4           [ 5] 	sta spr_newY,x
d4bd : 88               [ 2] 	dey
d4be : 88               [ 2] 	dey
d4bf : ca               [ 2] 	dex
d4c0 : 10f1             [ 3] 	bpl gr_spr_multi_loop
d4c2 : 60               [ 6] 	rts
                             
d4c3 :                       mod_sz_sprite_e
d4c3 :                       mod_sz_graph_e
                             
                             ; Old version of point calculator - in case I nee
                             ;	; Calculate destination address
                             ;	lda #0
                             ;	sta tmp_ahi
                             ;
                             ;	tya				; Row number in A
                             ;	; Multiply 8
                             ;	asl a
                             ;	rol tmp_ahi
                             ;	asl a
                             ;	rol tmp_ahi
                             ;	asl a
                             ;	rol tmp_ahi
                             ;	sta tmp_alo
                             ;
                             ;	; Multiply 32
                             ;	; Use partial result from m8
                             ;	lda tmp_ahi
                             ;	sta tmp_bhi
                             ;	lda tmp_alo
                             ;	; Just two more rotates to get m32
                             ;	asl a
                             ;	rol tmp_bhi
                             ;	asl a
                             ;	rol tmp_bhi
                             ;	sta tmp_blo
                             ;	; Add m8 and m32 for m40
                             ;	clc
                             ;	lda tmp_alo
                             ;	adc tmp_blo
                             ;	sta tmp_alo
                             ;	lda tmp_ahi
                             ;	adc tmp_bhi
                             ;	; Add high byte of screen address
                             ;	adc gr_scrngeom+vdp_scrn+1
                             ;	sta tmp_ahi
                             ;	; Dest offset in tmp_alo
                             ;
                             ;	; pixel x coord in to A
                             ;	; We dvide by 48 doing trial subtracts
                             ;	; This leaves Y with a number 0..5
                             ;	; And A has the remainder 0..47
                             ;	; Use these to look up byte column and mask
                             ;	; We don't do more than 5 trial subtracts
                             ;	; plus the table size is much smaller
                             ;	; Comprimise of space vs speed
                             ;	txa
                             ;	ldy #0				; Start at segment 0
                             ;	sec
                             ;gr_point_d48
                             ;	sbc #48
AS65 Assembler for R6502 [1.42].                                     Page  138
---------------------------------- bank0.s -----------------------------------

                             ;	iny
                             ;	bcs gr_point_d48				; Keep going until underflo
                             ;
                             ;	dey								; Adjust segment count
                             ;	adc #48							; Get remainder in A
                             ;	tax								; Put remainder in to X (0..47)
                             ;	lda gr_col_seg,y				; Get the start column of s
                             ;	clc
                             ;	adc gr_col_offset,x				; Add segment offset usi
                             ;	tay								; We have the byte column in Y
                             ;	sty tmp_bhi						; Save in tmp, also still in Y
                             ;	stx tmp_blo						; Save remainder 0..47
                             ;	rts
                             
                             ;gr_point_mask
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;	db 0x20,0x10,0x08,0x04,0x02,0x01
                             ;gr_col_offset
                             ;	db 0,0,0,0,0,0
                             ;	db 1,1,1,1,1,1
                             ;	db 2,2,2,2,2,2
                             ;	db 3,3,3,3,3,3
                             ;	db 4,4,4,4,4,4
                             ;	db 5,5,5,5,5,5
                             ;	db 6,6,6,6,6,6
                             ;	db 7,7,7,7,7,7
                             ;gr_col_seg
                             ;	db 0,8,16,24,32
                             
                             	include "monitor/cmd.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  CMD.S
                             ;*	A really simple monitor that needs to be impro
                             ;*	optimised.  Only has these commands;
                             ;*		dxxxx			Dump memory location xxxx
                             ;*						Press enter for more else stop
                             ;*		sxxxx [yy]		Set memory location xxxx with hex
                             ;*						bytes, respond with next location
                             ;*		q				Quit
                             ;*	Now you see why this needs optimising!
                             ;*
                             ;************************************************
                             
0095 =                       cmd_lo					= df_currdat
0096 =                       cmd_hi					= (df_currdat+1)
                             
                             	; ROM code
                             	code  
                             
AS65 Assembler for R6502 [1.42].                                     Page  139
---------------------------------- bank0.s -----------------------------------

d4c3 :                       _mod_sz_cmd_s
                             
d4c3 :                       command_line
                             
d4c3 :                       cmd_ready
                             	_println_low msg_ready
                             
                             
d4ca : 38               [ 2] 	sec							; Set carry flag = echo characters
d4cb : 2045c4           [ 6] 	jsr io_read_line			; Get a command line
d4ce : a000             [ 2] 	ldy #0
d4d0 : b139             [ 5] 	lda (buf_lo),y
d4d2 : c971             [ 2] 	cmp #'q'
d4d4 : d001             [ 3] 	bne cmd_check_cmd
d4d6 : 60               [ 6] 	rts
d4d7 :                       cmd_check_cmd
d4d7 : 20e9d4           [ 6] 	jsr cmd_parse				; Find command and execute
d4da : b003             [ 3] 	bcs cmd_error				; Carry set = error condition
d4dc : 4cc3d4           [ 3] 	jmp cmd_ready
                             
d4df :                       cmd_error
                             	_println_low msg_errmsg
                             
d4e6 : 4cc3d4           [ 3] 	jmp cmd_ready
                             
                             
                             ;****************************************
                             ;* cmd_parse
                             ;* Parse the command line in the io buffer
                             ;* Regs affected : 
                             ;****************************************
d4e9 :                       cmd_parse
d4e9 : c8               [ 2] 	iny						; Ready for next char
                             	
d4ea :                       cmd_check_d
d4ea : c964             [ 2] 	cmp #'d'				; Check for d
d4ec : f030             [ 4] 	beq cmd_dumpmem
d4ee :                       cmd_check_s
d4ee : c973             [ 2] 	cmp #'s'				; Check for s
d4f0 : f006             [ 3] 	beq cmd_setmem
                             
d4f2 :                       cmd_not_found
d4f2 : a901             [ 2] 	lda #CMD_ERR_NOTFOUND
d4f4 : 855e             [ 3] 	sta errno
d4f6 : 38               [ 2] 	sec
d4f7 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_setmem
                             ;* Set the memory at address AAAA to byte string
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;*          x = index to routine pointer
                             ;* Regs affected : A
                             ;****************************************
d4f8 :                       cmd_setmem
d4f8 : 20afd5           [ 6] 	jsr cmd_parse_word
d4fb : b01f             [ 4] 	bcs cmd_setmem_err
d4fd :                       cmd_setmem_byte
d4fd : 2093d5           [ 6] 	jsr cmd_parse_byte
d500 : b01a             [ 3] 	bcs cmd_setmem_err
d502 : 208ad5           [ 6] 	jsr cmd_poke				; Poke A in to cmd_lo, hi
AS65 Assembler for R6502 [1.42].                                     Page  140
---------------------------------- bank0.s -----------------------------------

d505 : 207ed5           [ 6] 	jsr cmd_incmem
d508 : 20c1d5           [ 6] 	jsr cmd_parse_next_parm		; Try and find another 
d50b : 90f0             [ 4] 	bcc cmd_setmem_byte			; Process if found, else f
d50d : a596             [ 3] 	lda cmd_hi
d50f : 2073c1           [ 6] 	jsr utilPrintA
d512 : a595             [ 3] 	lda cmd_lo
d514 : 2073c1           [ 6] 	jsr utilPrintA
d517 : 206bc1           [ 6] 	jsr utilPrintCRLF
d51a : 18               [ 2] 	clc
d51b : 60               [ 6] 	rts
d51c :                       cmd_setmem_err
d51c : 38               [ 2] 	sec
d51d : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* cmd_dumpmem
                             ;* Dump memory at address AAAA
                             ;* Input : buflo, bufhi
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
d51e :                       cmd_dumpmem
d51e : 20afd5           [ 6] 	jsr cmd_parse_word			; Get address to dump
d521 : 9001             [ 3] 	bcc cmd_dumpmem_block
d523 : 60               [ 6] 	rts							; C is set
d524 :                       cmd_dumpmem_block
d524 : a596             [ 3] 	lda cmd_hi					; Show the address
d526 : 2073c1           [ 6] 	jsr utilPrintA
d529 : a595             [ 3] 	lda cmd_lo
d52b : 2073c1           [ 6] 	jsr utilPrintA
d52e : 2063c1           [ 6] 	jsr utilPrintSPC
                             	
d531 : a008             [ 2] 	ldy #8						; 8 Bytes per line
d533 :                       cmd_dumpmem_byte
d533 : 2085d5           [ 6] 	jsr cmd_peek
d536 : 2073c1           [ 6] 	jsr utilPrintA
d539 : 2063c1           [ 6] 	jsr utilPrintSPC
d53c : 207ed5           [ 6] 	jsr cmd_incmem
d53f : 88               [ 2] 	dey
d540 : d0f1             [ 3] 	bne cmd_dumpmem_byte
d542 :                       cmd_dumpmemASCII
d542 : 38               [ 2] 	sec							; Move pointer back to start
d543 : a595             [ 3] 	lda cmd_lo
d545 : e908             [ 2] 	sbc #8
d547 : 8595             [ 3] 	sta cmd_lo
d549 : a596             [ 3] 	lda cmd_hi
d54b : e900             [ 2] 	sbc #0
d54d : 8596             [ 3] 	sta cmd_hi
                             	
d54f : 2063c1           [ 6] 	jsr utilPrintSPC
d552 : a008             [ 2] 	ldy #8						; 8 Bytes per line
d554 :                       cmd_dumpmem_ascii
d554 : 2085d5           [ 6] 	jsr cmd_peek
d557 : a22e             [ 2] 	ldx #'.'					; Non-printable char
d559 : c920             [ 2] 	cmp #' '					; A<32 is unprintable
d55b : b001             [ 3] 	bcs cmd_dump_skip_ctrl
d55d : 8a               [ 2] 	txa							; Replace with dot
d55e :                       cmd_dump_skip_ctrl
d55e : c97f             [ 2] 	cmp #UTF_DEL				; >= DEL is unprintable
d560 : 9001             [ 3] 	bcc cmd_dump_skip_del
d562 : 8a               [ 2] 	txa							; Replace with dot
AS65 Assembler for R6502 [1.42].                                     Page  141
---------------------------------- bank0.s -----------------------------------

d563 :                       cmd_dump_skip_del	
d563 : 2030c4           [ 6] 	jsr io_put_ch
d566 : 207ed5           [ 6] 	jsr cmd_incmem
d569 : 88               [ 2] 	dey		
d56a : d0e8             [ 3] 	bne cmd_dumpmem_ascii		; Show 8 bytes
d56c : 38               [ 2] 	sec
d56d : 202dc4           [ 6] 	jsr io_get_ch				; Wait for key press
d570 : c90d             [ 2] 	cmp #UTF_CR		
d572 : d003             [ 3] 	bne cmd_dumpmemFin			; Any key but enter finishe
                             ;	jsr io_put_ch				; Do new line
d574 : 4c24d5           [ 3] 	jmp cmd_dumpmem_block
d577 :                       cmd_dumpmemFin
d577 : a90d             [ 2] 	lda #UTF_CR
d579 : 2030c4           [ 6] 	jsr io_put_ch
d57c : 18               [ 2] 	clc
d57d : 60               [ 6] 	rts
                             	
                             	
                             ;****************************************
                             ;* cmd_incmem
                             ;* Increment pointer
                             ;* Input : cmd_lo, cmd_hi
                             ;* Output : cmd_lo, cmd_hi
                             ;* Regs affected : 
                             ;****************************************
d57e :                       cmd_incmem
                             	_incZPWord cmd_lo
                             
d584 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_peek
                             ;* Read byte
                             ;* Input : cmd_lo, cmd_hi
                             ;* Output : A
                             ;* Regs affected : 
                             ;****************************************
d585 :                       cmd_peek
d585 : a200             [ 2] 	ldx #0
d587 : a195             [ 6] 	lda (cmd_lo,x)
d589 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* cmd_poke
                             ;* Read byte
                             ;* Input : cmd_lo, cmd_hi, A
                             ;* Output : A
                             ;* Regs affected : 
                             ;****************************************
d58a :                       cmd_poke
d58a : 8638             [ 3] 	stx tmp_d
d58c : a200             [ 2] 	ldx #0
d58e : 8195             [ 6] 	sta (cmd_lo,x)
d590 : a638             [ 3] 	ldx tmp_d
d592 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_byte
                             ;* Find 2 char hex byte
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = char after hex byte, A = value
                             ;* Regs affected : A,Y
AS65 Assembler for R6502 [1.42].                                     Page  142
---------------------------------- bank0.s -----------------------------------

                             ;****************************************
d593 :                       cmd_parse_byte
d593 : 20c1d5           [ 6] 	jsr cmd_parse_next_parm	; Find the next paramete
d596 : b015             [ 3] 	bcs cmd_parse_byte_err
d598 : b139             [ 5] 	lda (buf_lo),y			; Get hi nibble of high byte
d59a : f011             [ 3] 	beq cmd_parse_byte_err	; If no char then error w
d59c : 48               [ 3] 	pha						; Save on stack
d59d : c8               [ 2] 	iny
d59e : b139             [ 5] 	lda (buf_lo),y			; Get lo nibble of high byte
d5a0 : f00a             [ 3] 	beq cmd_parse_byte_errp	; If no char then error 
d5a2 : aa               [ 2] 	tax						; Lo nibble goes to X
d5a3 : 68               [ 4] 	pla						; Restore hi nibble
d5a4 : 20a4c1           [ 6] 	jsr str_x_to_a			; Convert from hex to A
d5a7 : b004             [ 3] 	bcs cmd_parse_byte_err	; If error then stop
d5a9 : c8               [ 2] 	iny						; Point to next char
d5aa : 18               [ 2] 	clc
d5ab : 60               [ 6] 	rts						; A contains the byte
d5ac :                       cmd_parse_byte_errp
d5ac : 68               [ 4] 	pla
d5ad :                       cmd_parse_byte_err
d5ad : aa               [ 2] 	tax
d5ae : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_word
                             ;* Find 4 char hex word
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = char after hex byte, A = hi, X = 
                             ;* Regs affected : A,X,Y
                             ;****************************************
d5af :                       cmd_parse_word
d5af : 2093d5           [ 6] 	jsr cmd_parse_byte			; Get hi byte of word
d5b2 : b00b             [ 3] 	bcs cmd_word_err
d5b4 : 8596             [ 3] 	sta cmd_hi					; Save hi byte of word
d5b6 : 2093d5           [ 6] 	jsr cmd_parse_byte			; Get lo byte of word
d5b9 : b004             [ 3] 	bcs cmd_word_err
d5bb : 8595             [ 3] 	sta cmd_lo
d5bd : 18               [ 2] 	clc
d5be : 60               [ 6] 	rts
d5bf :                       cmd_word_err
d5bf : 38               [ 2] 	sec
d5c0 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* cmd_parse_next_parm
                             ;* Find next non-white space
                             ;* Input : buflo, bufhi, y offset
                             ;* Output : y = start of first parm byte
                             ;* Regs affected : A
                             ;****************************************
d5c1 :                       cmd_parse_next_parm
d5c1 : 88               [ 2] 	dey
d5c2 :                       cmd_find_parm
d5c2 : c8               [ 2] 	iny
d5c3 : b139             [ 5] 	lda (buf_lo),y
d5c5 : f005             [ 3] 	beq cmd_next_parm_err	; If z then no parms, fin 
d5c7 : c921             [ 2] 	cmp #' '+1				; Ignore space or less
d5c9 : f0f7             [ 3] 	beq cmd_find_parm
d5cb : 18               [ 2] 	clc						; else ok, C is cleared
d5cc :                       cmd_next_parm_err
d5cc : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  143
---------------------------------- bank0.s -----------------------------------

                             	
d5cd : 3e00                  msg_ready				db ">\x0"
d5cf : 3f0d00                msg_errmsg				db "?\xd\x0"
d5d2 :                       _mod_sz_cmd_e
                             
                             	include "sound/sound.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  SOUND.S
                             ;*  Sound driver module - routines to access the 
                             ;*  This sound chip was found in a number of popu
                             ;*  in the early to mid 80s, including my first c
                             ;*  the Oric-1, as well as the MSX range.
                             ;*
                             ;************************************************
                             
                             
                             	; ROM code
                             	code
                             
d5d2 :                       mod_sz_sound_s
                             
                             
                             ;****************************************
                             ;* snd_get_note
                             ;* Get a note from the music scale table
                             ;* Input : Octave in X, note in Y
                             ;*         Octave between 1 and 6
                             ;* Output : A,X = Value hi,lo
                             ;* Regs affected : X
                             ;****************************************
d5d2 :                       snd_get_note
d5d2 : 98               [ 2] 	tya
d5d3 : 0a               [ 2] 	asl a
d5d4 : a8               [ 2] 	tay
                             	; Get note for octave 1
d5d5 : b905d6           [ 4] 	lda snd_music_tab,y
d5d8 : 8532             [ 3] 	sta tmp_alo
d5da : b906d6           [ 4] 	lda snd_music_tab+1,y
                             	
d5dd :                       snd_get_note_oct
d5dd : ca               [ 2] 	dex
d5de : f006             [ 3] 	beq snd_note_done
                             	; Divide freq by 2 each octave
d5e0 : 4a               [ 2] 	lsr a
d5e1 : 6632             [ 5] 	ror tmp_alo
d5e3 : 4cddd5           [ 3] 	jmp snd_get_note_oct
d5e6 :                       snd_note_done
d5e6 : a632             [ 3] 	ldx tmp_alo
d5e8 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* init_snd
                             ;* Initialise sound - after cia 1 has been initia
                             ;* Input : None
AS65 Assembler for R6502 [1.42].                                     Page  144
---------------------------------- bank0.s -----------------------------------

                             ;* Output : None
                             ;* Regs affected : All
                             ;****************************************
d5e9 :                       init_snd
d5e9 : a20f             [ 2] 	ldx #15
d5eb :                       init_snd_regs
d5eb : bdf5d5           [ 4] 	lda snd_init_tab,x
d5ee : 206ec0           [ 6] 	jsr snd_set				; Set X to A
d5f1 : ca               [ 2] 	dex
d5f2 : 10f7             [ 3] 	bpl init_snd_regs		; 16 regs
                             	
d5f4 : 60               [ 6] 	rts						; return from sub
                             
                             	; Register array initialisation values
                             	; Assuming 1Mhz input clock
d5f5 :                       snd_init_tab
d5f5 : 40                    	db 0x40				; R0 = Channel A Tone Low
d5f6 : 00                    	db 0x00				; R1 = Channel A Tone High
d5f7 : 00                    	db 0x00				; R2 = Channel B Tone Low
d5f8 : 01                    	db 0x01				; R3 = Channel B Tone High
d5f9 : 00                    	db 0x00				; R4 = Channel C Tone Low
d5fa : 02                    	db 0x02				; R5 = Channel C Tone High
d5fb : 00                    	db 0x00				; R6 = Noise period
d5fc : 7e                    	db 0b01111110		; R7 = Control : IOB input, IOA o
d5fd : 1f                    	db 0x1f				; R8 = Channel A Vol
d5fe : 1f                    	db 0x1f				; R9 = Channel B Vol
d5ff : 1f                    	db 0x1f				; R10 = Channel C Vol
d600 : 00                    	db 0x00				; R11 = Envelope Period Low
d601 : 03                    	db 0x03				; R12 = Envelope Period High
d602 : 00                    	db 0b00000000		; R13 = Envelope Shape : 0000
d603 : ff                    	db 0xff				; R14 = IO Port A - KB lines disabled
d604 : 00                    	db 0x00				; R15 = IO Port B ; Initialise to 0 (
                             
d605 :                       snd_music_tab
d605 : f20b                  	dw 3058				; C		0 (Octave 1 3058Hz)
d607 : 460b                  	dw 2886				; C#	1
d609 : a40a                  	dw 2724				; D		2
d60b : 0b0a                  	dw 2571				; D#	3
d60d : 7b09                  	dw 2427				; E		4
d60f : f308                  	dw 2291				; F		5
d611 : 7208                  	dw 2162				; F#	6
d613 : f907                  	dw 2041				; G		7
d615 : 8607                  	dw 1926				; G#	8
d617 : 1a07                  	dw 1818				; A		9
d619 : b406                  	dw 1716				; A#	10
d61b : 5406                  	dw 1620				; B		11
d61d : 0000                  	dw 0				; Null  12
                             
d61f :                       mod_sz_sound_e
                             
d61f :                       mod_sz_bios_e
d61f :                       mod_sz_language_s
                             	include "utils/intmath.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  INTMATH.S
AS65 Assembler for R6502 [1.42].                                     Page  145
---------------------------------- bank0.s -----------------------------------

                             ;*  Core module for integer maths supported by df
                             ;*  Now supports signed integers in 2s complement
                             ;*  Uses the intmath registers: num_a, num_b, num
                             ;*  Most inputs are through num_a and num_b, with
                             ;*  num_a
                             ;*  Operations: add, sub, swap, 8 bit mult, mult,
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
                             ;****************************************
                             ;* Add : A + B result in A
                             ;****************************************
                             ;int_add
                             ;	clc
                             ;	lda num_a
                             ;	adc num_b
                             ;	sta num_a
                             ;	lda num_a+1
                             ;	adc num_b+1
                             ;	sta num_a+1
                             ;	rts
                             	
                             ;****************************************
                             ;* Sub : A - B result in A
                             ;****************************************
                             ;int_sub
                             ;	sec
                             ;	lda num_a
                             ;	sbc num_b
                             ;	sta num_a
                             ;	lda num_a+1
                             ;	sbc num_b+1
                             ;	sta num_a+1
                             ;	rts
                             	
                             ;****************************************
                             ;* Swp : A <-> B 
                             ;****************************************
                             ;int_swp
                             ;	lda num_a
                             ;	ldx num_b
                             ;	sta num_b
                             ;	stx num_a
                             ;	lda num_a+1
                             ;	ldx num_b+1
                             ;	sta num_b+1
                             ;	stx num_a+1
                             ;	rts
                             	
                             ;****************************************
                             ;* Mult : A * B result in A
                             ;* B assumed to be an 8 bit quantity 
                             ;****************************************
d61f :                       int_fast_mult
                             	_cpyZPWord num_a,num_tmp
                             
d627 : a900             [ 2] 	lda #0
d629 : 853d             [ 3] 	sta num_a
d62b : 853e             [ 3] 	sta num_a+1
AS65 Assembler for R6502 [1.42].                                     Page  146
---------------------------------- bank0.s -----------------------------------

d62d : a008             [ 2] 	ldy #8
d62f :                       int_fast_mult_cycle
d62f : 4641             [ 5] 	lsr num_b
d631 : 900d             [ 3] 	bcc int_fast_mult_next
d633 : 18               [ 2] 	clc
d634 : a53d             [ 3] 	lda num_a
d636 : 6549             [ 3] 	adc num_tmp
d638 : 853d             [ 3] 	sta num_a
d63a : a53e             [ 3] 	lda num_a+1
d63c : 654a             [ 3] 	adc num_tmp+1
d63e : 853e             [ 3] 	sta num_a+1
d640 :                       int_fast_mult_next
d640 : 0649             [ 5] 	asl num_tmp
d642 : 264a             [ 5] 	rol num_tmp+1
d644 : 88               [ 2] 	dey
d645 : d0e8             [ 3] 	bne int_fast_mult_cycle
d647 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Mult : A * B result in A
                             ;****************************************
d648 :                       int_mult
                             	_cpyZPWord num_a,num_tmp
                             
d650 : a900             [ 2] 	lda #0
d652 : 853d             [ 3] 	sta num_a
d654 : 853e             [ 3] 	sta num_a+1
d656 : a010             [ 2] 	ldy #16
d658 :                       int_mult_cycle
d658 : 4642             [ 5] 	lsr num_b+1
d65a : 6641             [ 5] 	ror num_b
d65c : 900d             [ 3] 	bcc int_mult_next
d65e : 18               [ 2] 	clc
d65f : a53d             [ 3] 	lda num_a
d661 : 6549             [ 3] 	adc num_tmp
d663 : 853d             [ 3] 	sta num_a
d665 : a53e             [ 3] 	lda num_a+1
d667 : 654a             [ 3] 	adc num_tmp+1
d669 : 853e             [ 3] 	sta num_a+1
d66b :                       int_mult_next
d66b : 0649             [ 5] 	asl num_tmp
d66d : 264a             [ 5] 	rol num_tmp+1
d66f : 88               [ 2] 	dey
d670 : d0e6             [ 3] 	bne int_mult_cycle
d672 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Div : A / B result in A, remainder X
                             ;****************************************
d673 :                       int_div
                             	; adjust signs
d673 : a900             [ 2] 	lda #0
d675 : 8549             [ 3] 	sta num_tmp				; Assume all +ve
d677 : a53e             [ 3] 	lda num_a+1				; Check A hi
d679 : 100f             [ 3] 	bpl int_div_skip_negA
d67b : e649             [ 5] 	inc num_tmp				; Record sign flip
d67d : 38               [ 2] 	sec						; 2's complement A
d67e : a900             [ 2] 	lda #0					; by 0-A
d680 : e53d             [ 3] 	sbc num_a				; A is now +ve
d682 : 853d             [ 3] 	sta num_a
d684 : a900             [ 2] 	lda #0
d686 : e53e             [ 3] 	sbc num_a+1
AS65 Assembler for R6502 [1.42].                                     Page  147
---------------------------------- bank0.s -----------------------------------

d688 : 853e             [ 3] 	sta num_a+1	
d68a :                       int_div_skip_negA
d68a : a542             [ 3] 	lda num_b+1				; Check B hi
d68c : 100f             [ 3] 	bpl int_div_skip_negB
d68e : e649             [ 5] 	inc num_tmp				; Record sign flip
d690 : 38               [ 2] 	sec						; 2's complement B
d691 : a900             [ 2] 	lda #0					; by 0-B
d693 : e541             [ 3] 	sbc num_b				; B is now +ve
d695 : 8541             [ 3] 	sta num_b
d697 : a900             [ 2] 	lda #0
d699 : e542             [ 3] 	sbc num_b+1
d69b : 8542             [ 3] 	sta num_b+1
d69d :                       int_div_skip_negB			; num_tmp bit 0=1 for result 
                             	; x is the remainder
d69d : a900             [ 2] 	lda #0
d69f : 8545             [ 3] 	sta num_x
d6a1 : 8546             [ 3] 	sta num_x+1
                             	; 16 bit division
d6a3 : a010             [ 2] 	ldy #16
d6a5 :                       int_div_cycle
                             	; shift a left 1 bit
d6a5 : 063d             [ 5] 	asl num_a
d6a7 : 263e             [ 5] 	rol num_a+1
                             	; shift in to remainder
d6a9 : 2645             [ 5] 	rol num_x
d6ab : 2646             [ 5] 	rol num_x+1
                             	; try and subtract b from remainder
d6ad : 38               [ 2] 	sec
d6ae : a545             [ 3] 	lda num_x
d6b0 : e541             [ 3] 	sbc num_b
d6b2 : aa               [ 2] 	tax
d6b3 : a546             [ 3] 	lda num_x+1
d6b5 : e542             [ 3] 	sbc num_b+1
d6b7 : 9006             [ 3] 	bcc int_div_skip
                             	; so b did fit in to remainder, save it
d6b9 : 8645             [ 3] 	stx num_x
d6bb : 8546             [ 3] 	sta num_x+1
d6bd : e63d             [ 5] 	inc num_a
d6bf :                       int_div_skip
                             	; carry on for 16 bits
d6bf : 88               [ 2] 	dey
d6c0 : d0e3             [ 3] 	bne int_div_cycle
                             	; result in a, remainder in x
                             	; check num_tmp bit 0
d6c2 : a549             [ 3] 	lda num_tmp
d6c4 : 2901             [ 2] 	and #1
d6c6 : f00d             [ 3] 	beq int_div_noflip
d6c8 : 38               [ 2] 	sec						; 2's complement A
d6c9 : a900             [ 2] 	lda #0					; by 0-A
d6cb : e53d             [ 3] 	sbc num_a				; A is now +ve
d6cd : 853d             [ 3] 	sta num_a
d6cf : a900             [ 2] 	lda #0
d6d1 : e53e             [ 3] 	sbc num_a+1
d6d3 : 853e             [ 3] 	sta num_a+1	
d6d5 :                       int_div_noflip
d6d5 : 60               [ 6] 	rts
                             	
                             
                             	include "dflat/dflat.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
AS65 Assembler for R6502 [1.42].                                     Page  148
---------------------------------- bank0.s -----------------------------------

                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  DFLAT.S
                             ;*  This is the main controller code file for dfl
                             ;*  This file includes all the required dflat sou
                             ;*  needed:
                             ;*  - error.s is the error handling module
                             ;*  - var.s is the variable handling module
                             ;*  - tokenise.s is the tokenisation module
                             ;*  - progedit.s is the program editing module
                             ;*  - runtime.s is the runtime module
                             ;*  - stack.s is the stack handling module
                             ;*  The above modules include further source file
                             ;*  needed.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
d6d6 :                       mod_sz_dflat_s
                             
                             ;	include "dflat/error.s"  ** included in the mai
                             	include "dflat/var.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  VAR.S
                             ;*  This module handles all the variable manageme
                             ;*  When a new variable is detected during tokeni
                             ;*  is added to the variable tables.  Any subsequ
                             ;*  that variable is tokenised as an index in to 
                             ;*  table.  There are two variable tables:
                             ;*  Variable name table (VNT) keeps track of vari
                             ;*  Variable value table (VVT) maintains variable
                             ;*  including type, dimension (if array) and of c
                             ;*  actual values.  For an array, the value is a 
                             ;*  memory grabbed using the 'malloc' function (s
                             ;*  This approach to variable managemet is direct
                             ;*  Atari 8 bit.  The disadvantage is that during
                             ;*  session you may end up having a much larger v
                             ;*  table than you need.  Why?  Well because say 
                             ;*  a as a new variable, but then later change it
                             ;*  In this case a remains in the variable tables
                             ;*  only ever adds to the table!  However it is e
                             ;*  solved - when you save and then reload from n
                             ;*  program, the variable table is built up as th
                             ;*  is loaded.
                             ;*  The VNT grows DOWN from the top of free memor
                             ;*  the VVT growing UP from just below the VNT.
                             ;*	This means that the VVT for a variable will al
                             ;*	found in a fixed place in the VVT table and me
                             ;*	For the VNT (names) it grows from vvstart at l
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page  149
---------------------------------- bank0.s -----------------------------------

                             ;************************************************
                             
                             
                             	; ROM code
                             	code  
                             
d6d6 :                       mod_sz_var_s
                             
                             
                             ;****************************************
                             ;* Find a variable
                             ;* CC if found, A has index
                             ;****************************************
d6d6 :                       df_var_find
                             	; start at the beginning of the vnt table
                             	; vars are stored in reverse order
                             	_cpyZPWord df_vntstrt,df_tmpptrb
                             
                             	; start at end of VVT
                             	_cpyZPWord df_vvtend,df_tmpptra
                             
d6e6 :                       df_var_match_vnt
                             	; If reached top of VVT then not found
d6e6 : a5a2             [ 3] 	lda df_tmpptra
d6e8 : c56e             [ 3] 	cmp df_vvtstrt
d6ea : d006             [ 3] 	bne df_var_match_vnt_do
d6ec : a5a3             [ 3] 	lda df_tmpptra+1
d6ee : c56f             [ 3] 	cmp df_vvtstrt+1
d6f0 : f042             [ 4] 	beq df_var_find_no_vnt
d6f2 :                       df_var_match_vnt_do
                             	; match each char in buffer with vnt
d6f2 : a47d             [ 3] 	ldy df_linoff
d6f4 : a200             [ 2] 	ldx #0
d6f6 :                       df_var_match_vnt_sym
d6f6 : b90004           [ 4] 	lda df_linbuff,y
d6f9 : c1a4             [ 6] 	cmp (df_tmpptrb,x)
d6fb : d017             [ 4] 	bne df_var_vnt_sym_nomatch
                             	; if single char match then increment
                             	; source and search
d6fd : c8               [ 2] 	iny
                             	_incZPWord df_tmpptrb
                             
                             	; if more chars in vnt entry then continue
d704 : a1a4             [ 6] 	lda (df_tmpptrb,x)
d706 : d0ee             [ 4] 	bne df_var_match_vnt_sym
                             	; if no more chars in vnt entry but
                             	; but chars in buffer then try next vnt
d708 : b90004           [ 4] 	lda df_linbuff,y
                             	; check for valid alpha-numeric
d70b : 20b4d8           [ 6] 	jsr df_tk_isalphanum
                             	; if there is a valid alpha-num then no match
d70e : b004             [ 3] 	bcs df_var_vnt_sym_nomatch
                             	; else check type
d710 :                       df_var_check_type
                             	; if not alpha-num then check for type
                             	; string or int postfix didn't match with VNT
                             ;	cmp #'%'
                             ;	beq df_var_vnt_sym_nomatch
d710 : c924             [ 2] 	cmp #'$'
                             	; ok, all good got a match
d712 : d025             [ 3] 	bne df_var_find_true
d714 :                       df_var_vnt_sym_nomatch
AS65 Assembler for R6502 [1.42].                                     Page  150
---------------------------------- bank0.s -----------------------------------

                             	; find the zero terminator
d714 : a1a4             [ 6] 	lda (df_tmpptrb,x)
d716 : f009             [ 3] 	beq	df_var_vnt_entry_end
                             	_incZPWord df_tmpptrb
                             
d71e : 4c14d7           [ 3] 	jmp df_var_vnt_sym_nomatch
d721 :                       df_var_vnt_entry_end
                             	; skip over zero terminator
                             	_incZPWord df_tmpptrb
                             
                             	; update vvt address pointer
d727 : 18               [ 2] 	clc
d728 : a5a2             [ 3] 	lda df_tmpptra
d72a : 6908             [ 2] 	adc #8
d72c : 85a2             [ 3] 	sta df_tmpptra
                             	_bcc 2
                             
d730 : e6a3             [ 5] 	inc df_tmpptra+1
d732 : d0b2             [ 4] 	bne df_var_match_vnt		; Always - high byte is no
                             
                             	; if at end of vnt then no matches found
d734 :                       df_var_find_no_vnt
d734 : a900             [ 2] 	lda #0
d736 : aa               [ 2] 	tax
d737 : 38               [ 2] 	sec
d738 : 60               [ 6] 	rts
                             
d739 :                       df_var_find_true
                             	; Get slot address into x,a
d739 : a6a2             [ 3] 	ldx df_tmpptra
d73b : a5a3             [ 3] 	lda df_tmpptra+1
                             	
                             	; Consume characters found in source
d73d : 847d             [ 3] 	sty df_linoff
d73f : 18               [ 2] 	clc
d740 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* Insert a variable name in to vnt
                             ;* X = number of bytes to make room
                             ;* Space allocated is;
                             ;*	8 bytes for the new VVT entry
                             ;*  X bytes for the new VNT entry
                             ;* df_vntstrt is new var name entry
                             ;* df_vvtend is new vvt entry
                             ;****************************************
d741 :                       df_var_insert_space
                             	; *** REMEMBER TO DO A SPACE CHECK EVENTUALLY! *
                             
                             	; adjust down the VNT start by VVT size (for ext
                             	; put it in tmpptrb
d741 : 38               [ 2] 	sec
d742 : a56a             [ 3] 	lda df_vntstrt
d744 : e908             [ 2] 	sbc #DFVVT_SZ
d746 : 856a             [ 3] 	sta df_vntstrt
d748 : a56b             [ 3] 	lda df_vntstrt+1
d74a : e900             [ 2] 	sbc #0
d74c : 856b             [ 3] 	sta df_vntstrt+1
                             	
                             	; adjust VNT end by VVT size (for extra VVT entr
                             	; and put it in tmpptrc
AS65 Assembler for R6502 [1.42].                                     Page  151
---------------------------------- bank0.s -----------------------------------

d74e : 38               [ 2] 	sec
d74f : a56c             [ 3] 	lda df_vntend
d751 : e908             [ 2] 	sbc #DFVVT_SZ
d753 : 856c             [ 3] 	sta df_vntend
d755 : a56d             [ 3] 	lda df_vntend+1
d757 : e900             [ 2] 	sbc #0
d759 : 856d             [ 3] 	sta df_vntend+1
                             
                             	; Set copy point to new start of VNT
                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
                             
                             	; Now move all bytes from old VNT (higher up) to
d763 :                       df_var_move_byte
                             	; When pointer = vntend then done
d763 : a5a2             [ 3] 	lda df_tmpptra
d765 : c56c             [ 3] 	cmp df_vntend
d767 : d006             [ 3] 	bne df_var_move_byte_do
d769 : a5a3             [ 3] 	lda df_tmpptra+1
d76b : c56d             [ 3] 	cmp df_vntend+1
d76d : f011             [ 3] 	beq df_var_move_byte_fin
d76f :                       df_var_move_byte_do
                             	; First the source byte VVT size higher in memor
d76f : a008             [ 2] 	ldy #DFVVT_SZ
d771 : b1a2             [ 5] 	lda (df_tmpptra),y
                             	; And copy to new position lower in memory
d773 : a000             [ 2] 	ldy #0
d775 : 91a2             [ 5] 	sta (df_tmpptra),y
                             	; Increment memory pointer
                             	_incZPWord df_tmpptra
                             
d77d : 4c63d7           [ 3] 	jmp df_var_move_byte		; Always as C is not touch
d780 :                       df_var_move_byte_fin
                             	
                             	; Now subtract X bytes from VNT start to accommo
d780 : 8638             [ 3] 	stx tmp_d
d782 : 38               [ 2] 	sec
d783 : a56a             [ 3] 	lda df_vntstrt
d785 : e538             [ 3] 	sbc tmp_d
d787 : 856a             [ 3] 	sta df_vntstrt
d789 : a56b             [ 3] 	lda df_vntstrt+1
d78b : e900             [ 2] 	sbc #0
d78d : 856b             [ 3] 	sta df_vntstrt+1
                             
                             	; VVT end is the same as VNT end
                             	_cpyZPWord df_vntend,df_vvtend
                             
                             
                             	; Copy done increment variable count
d797 : e672             [ 5] 	inc df_varcnt
d799 : 18               [ 2] 	clc
d79a : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* Iterate through a valid variable name
                             ;* starts with alpha, then any number of
                             ;* alphanums.
                             ;****************************************
d79b :                       df_var_countlen
                             	; count alpha nums
d79b : c8               [ 2] 	iny
AS65 Assembler for R6502 [1.42].                                     Page  152
---------------------------------- bank0.s -----------------------------------

d79c : e8               [ 2] 	inx
d79d : b90004           [ 4] 	lda df_linbuff,y
                             	; first char has to be alpha, rest can be alpha-
d7a0 : e000             [ 2] 	cpx #0
d7a2 : d006             [ 3] 	bne df_var_countlen_alphanum
d7a4 : 20a7d8           [ 6] 	jsr df_tk_isalpha
d7a7 : 4cadd7           [ 3] 	jmp df_var_countlen_loop
d7aa :                       df_var_countlen_alphanum
d7aa : 20b4d8           [ 6] 	jsr df_tk_isalphanum
d7ad :                       df_var_countlen_loop
d7ad : b0ec             [ 3] 	bcs df_var_countlen
d7af : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Analyse variable name
                             ;* Return type in A
                             ;* NOT C = It is a variable
                             ;* C = It is not a variable
                             ;* X = Length including pre-fixes
                             ;* Y = Offset to next char after var name
                             ;****************************************
d7b0 :                       df_var_analyse
                             	; start at the current buffer position
d7b0 : a47d             [ 3] 	ldy df_linoff
                             	
                             	; actual number of alpha nums = -1 to start
d7b2 : a2ff             [ 2] 	ldx #-1
                             
                             	; Default type is INT
d7b4 : a901             [ 2] 	lda #DFVVT_INT
d7b6 : 85a2             [ 3] 	sta df_tmpptra
                             	
                             	; check for PROC prefix
d7b8 : b90004           [ 4] 	lda df_linbuff,y
d7bb : c95f             [ 2] 	cmp #'_'
                             	; if it is not proc then get the name
d7bd : d011             [ 3] 	bne df_var_not_proc
                             	; analyse for proc variable names
                             	; else set type to PROC
d7bf : a940             [ 2] 	lda #DFVVT_PROC
d7c1 : 85a2             [ 3] 	sta df_tmpptra
d7c3 : 209bd7           [ 6] 	jsr df_var_countlen
                             	; Length must be >=1
d7c6 : e001             [ 2] 	cpx #1
d7c8 : 9004             [ 3] 	bcc df_var_analyse_fatal_err
                             	; Next char has to be '('
d7ca : c928             [ 2] 	cmp #'('
d7cc : f022             [ 3] 	beq df_var_finalise_len
d7ce :                       df_var_analyse_fatal_err
                             	SWBRK DFERR_SYNTAX
                             
                             	; Analyse for non-proc variable names
d7d0 :                       df_var_not_proc
                             	; go back on pos on index as loop always does in
d7d0 : 88               [ 2] 	dey
d7d1 : 209bd7           [ 6] 	jsr df_var_countlen
d7d4 : e000             [ 2] 	cpx #0
d7d6 : d002             [ 3] 	bne df_var_analyse_chk_post
                             	; if zero alphanums error but not fatal
d7d8 : 38               [ 2] 	sec
d7d9 : 60               [ 6] 	rts
                             	; check for post qualifiers e.g. $
AS65 Assembler for R6502 [1.42].                                     Page  153
---------------------------------- bank0.s -----------------------------------

d7da :                       df_var_analyse_chk_post
                             	; first see if the char is $
                             	; but cannot already have PROC prefix
                             ;	cmp #'%'
                             ;	bne df_var_analyse_chk_dollar
                             ; Set to INT type although it is the default alre
                             ;	lda #DFVVT_INT
                             ;	sta df_tmpptra
                             	; advance the buffer index
                             ;	iny
                             ;	bne df_var_analyse_chk_arry
d7da :                       df_var_analyse_chk_dollar
                             	; now see if the char is $
                             	; but cannot already have PROC prefix
d7da : c924             [ 2] 	cmp #'$'
d7dc : d005             [ 3] 	bne df_var_analyse_chk_arry
                             	; Set to STRING type
d7de : a904             [ 2] 	lda #DFVVT_STR
d7e0 : 85a2             [ 3] 	sta df_tmpptra
                             	; advance the buffer index
d7e2 : c8               [ 2] 	iny
d7e3 :                       df_var_analyse_chk_arry
                             	; Check for array type vs PROC
d7e3 : b90004           [ 4] 	lda df_linbuff,y
d7e6 : c95b             [ 2] 	cmp #'['
d7e8 : d006             [ 3] 	bne df_var_finalise_len
d7ea : a5a2             [ 3] 	lda df_tmpptra
d7ec : 0980             [ 2] 	ora #DFVVT_PTR
d7ee : 85a2             [ 3] 	sta df_tmpptra
d7f0 :                       df_var_finalise_len
                             	; Ok got everything
                             	; calculate length from y
                             	; y is next char after var name
d7f0 : 98               [ 2] 	tya
d7f1 : 38               [ 2] 	sec
d7f2 : e57d             [ 3] 	sbc df_linoff			; where we started
                             	; put len in X
d7f4 : aa               [ 2] 	tax
                             	; put type in A
d7f5 : a5a2             [ 3] 	lda df_tmpptra
d7f7 : 18               [ 2] 	clc
d7f8 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find or create a variable
                             ;* If found then type needs to match mask
                             ;* Not a fatal error because could be part
                             ;* of a trial of different parsing options
                             ;****************************************
d7f9 :                       df_var_findcreate
                             	; save mask
d7f9 : 48               [ 3] 	pha
d7fa : 20d6d6           [ 6] 	jsr df_var_find
d7fd : b013             [ 4] 	bcs df_var_findcreate_create
                             	; restore mask to check for 0 then push
d7ff : 68               [ 4] 	pla
d800 : 48               [ 3] 	pha
                             	; don't check mask if zero
d801 : f008             [ 3] 	beq df_var_findcreate_found
                             	; restore mask
d803 : 68               [ 4] 	pla
d804 : a000             [ 2] 	ldy #DFVVT_TYPE
AS65 Assembler for R6502 [1.42].                                     Page  154
---------------------------------- bank0.s -----------------------------------

d806 : 31a2             [ 5] 	and (df_tmpptra),y
                             	; but if mask is non zero then this must be non 
d808 : f019             [ 3] 	beq df_var_findcreate_err
d80a : 48               [ 3] 	pha		; Dummy push to match the pla
d80b :                       df_var_findcreate_found
                             	; discard mask
d80b : 68               [ 4] 	pla	
                             	; put slot address in x,a
d80c : a6a2             [ 3] 	ldx df_tmpptra
d80e : a5a3             [ 3] 	lda df_tmpptra+1
d810 : 18               [ 2] 	clc
d811 : 60               [ 6] 	rts
                             	
                             	;* If no existing variable found, add one to VNT
d812 :                       df_var_findcreate_create
                             	; find type (A) and length (X)
d812 : 20b0d7           [ 6] 	jsr df_var_analyse
                             	; keep A temporarily
d815 : 85a2             [ 3] 	sta df_tmpptra
                             	; if not a variable then return with C=1
d817 : b009             [ 3] 	bcs df_var_findcreate_errp
                             	; check if mask needs to be applied
d819 : 68               [ 4] 	pla
d81a : f009             [ 3] 	beq df_var_analyse_ok
                             	; else mask and check
d81c : 25a2             [ 3] 	and df_tmpptra
                             	; mask match is ok
d81e : d005             [ 3] 	bne df_var_analyse_ok
                             	; else return not found
d820 : f001             [ 3] 	beq df_var_findcreate_err
d822 :                       df_var_findcreate_errp
d822 : 68               [ 4] 	pla
d823 :                       df_var_findcreate_err
d823 : 38               [ 2] 	sec
d824 : 60               [ 6] 	rts
                             
d825 :                       df_var_analyse_ok
                             	; extra space for zero terminator
d825 : e8               [ 2] 	inx
                             	; save data in reverse order to when needed
                             	; by the initialise section x,a (var name sz, ty
                             	; insert space of X bytes
d826 : a5a2             [ 3] 	lda df_tmpptra
d828 : 48               [ 3] 	pha
d829 : 8a               [ 2] 	txa
d82a : 48               [ 3] 	pha
                             	
d82b : 2041d7           [ 6] 	jsr df_var_insert_space
d82e : 9002             [ 3] 	bcc df_var_initialise_var
                             	; error inserting space
                             	SWBRK DFERR_OK
                             
                             	
d832 :                       df_var_initialise_var
d832 : 68               [ 4] 	pla
d833 : 85a6             [ 3] 	sta df_tmpptrc				; var name size + 1
                             
d835 : 68               [ 4] 	pla							; type
d836 : a000             [ 2] 	ldy #DFVVT_TYPE
d838 : 9170             [ 5] 	sta (df_vvtend),y			; put type in vvt slot
d83a : a900             [ 2] 	lda #0						; zero the rest
d83c : a007             [ 2] 	ldy #7
AS65 Assembler for R6502 [1.42].                                     Page  155
---------------------------------- bank0.s -----------------------------------

d83e :                       df_var_zero_vnt
d83e : 9170             [ 5] 	sta (df_vvtend),y
d840 : 88               [ 2] 	dey
d841 : d0fb             [ 3] 	bne df_var_zero_vnt			; Don't zero out the type
                             
d843 : c6a6             [ 5] 	dec df_tmpptrc				; 1 less to copy variable name
                             
d845 : a67d             [ 3] 	ldx df_linoff				; Start at var name beginning, 
                             	; copy variable name to vnt slot
d847 :                       df_var_findcreate_copy
d847 : bd0004           [ 4] 	lda df_linbuff,x
d84a : 916a             [ 5] 	sta (df_vntstrt),y
d84c : e8               [ 2] 	inx
d84d : c8               [ 2] 	iny
d84e : c6a6             [ 5] 	dec df_tmpptrc
d850 : d0f5             [ 3] 	bne df_var_findcreate_copy
                             	; put in zero terminator
d852 : a900             [ 2] 	lda #0
d854 : 916a             [ 5] 	sta (df_vntstrt),y
                             
d856 : 867d             [ 3] 	stx df_linoff				; Update line pointer
                             
                             	; Return address of slot in X,A
d858 : a670             [ 3] 	ldx df_vvtend
d85a : a571             [ 3] 	lda df_vvtend+1
                             	
d85c : 18               [ 2] 	clc
d85d : 60               [ 6] 	rts
                             	
d85e :                       mod_sz_var_e
                             
                             	include "dflat/tokenise.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TOKENISE.S
                             ;*  Controlling module for tokenisation.  Basical
                             ;*  module is given a raw input buffer, which it 
                             ;*  attempt to tokenise fully.  Any syntax errors
                             ;*  thrown at the first point of detection.  If a
                             ;*  well, the parsed input will be in a tokenised
                             ;*  which can be executed in immediate mode or sa
                             ;*  line number order to memory.
                             ;*  dflat syntax is very simple - every statement
                             ;*  with a keyword.  The only exception is assign
                             ;*  procedure invocation - but even these scenari
                             ;*  tokenised so during runtime we just execute t
                             ;*  The raw buffer is consumed one byte at a time
                             ;*  tokenised buffer is written one byte at a tim
                             ;*  syntax means there is no need to undo reads o
                             ;*  or tokenised buffer.  The only refinement is 
                             ;*  allowed to peek a character in the raw buffer
                             ;*  consuming it.
                             ;*
                             ;************************************************
                             
                             	; ROM code
AS65 Assembler for R6502 [1.42].                                     Page  156
---------------------------------- bank0.s -----------------------------------

                             	code
                             
d85e :                       mod_sz_tokenise_s
                             
                             
                             ;****************************************
                             ;* df_tk_peek_buf
                             ;* Return next char in A but no change to pointer
                             ;****************************************
d85e :                       df_tk_peek_buf
d85e : a47d             [ 3] 	ldy df_linoff
d860 : b90004           [ 4] 	lda df_linbuff,y
d863 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_get_buf
                             ;* Return next char in A and inc pointer
                             ;* Don't advance if null char found and Z=1
                             ;****************************************
d864 :                       df_tk_get_buf
d864 : a47d             [ 3] 	ldy df_linoff
d866 : b90004           [ 4] 	lda df_linbuff,y
d869 : f003             [ 3] 	beq df_tk_get_buf_null
d86b : c8               [ 2] 	iny
d86c : 847d             [ 3] 	sty df_linoff
d86e :                       df_tk_get_buf_null
d86e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_put_tok
                             ;* Put A in token buffer and inc pointer
                             ;* C=Clear on exit
                             ;****************************************
d86f :                       df_tk_put_tok
d86f : a47e             [ 3] 	ldy df_tokoff
d871 : 998004           [ 5] 	sta df_tokbuff,y
d874 : c8               [ 2] 	iny
d875 : 3004             [ 3] 	bmi df_tk_put_overflow
d877 : 847e             [ 3] 	sty df_tokoff
d879 : 18               [ 2] 	clc
d87a : 60               [ 6] 	rts
d87b :                       df_tk_put_overflow
                             	SWBRK DFERR_STRLONG
                             
                             
                             ;****************************************
                             ;* df_tk_isdigit
                             ;* Check char in A for number 0-9
                             ;* Return: CC = False, CS = True
                             ;****************************************
d87d :                       df_tk_isdigit
d87d : c93a             [ 2] 	cmp #'9'+1
d87f : b005             [ 3] 	bcs df_tk_isdigit_false
d881 : c930             [ 2] 	cmp #'0'
d883 : 9001             [ 3] 	bcc df_tk_isdigit_false
d885 : 60               [ 6] 	rts						; C must be 1
d886 :                       df_tk_isdigit_false
d886 : 18               [ 2] 	clc
d887 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isbin
AS65 Assembler for R6502 [1.42].                                     Page  157
---------------------------------- bank0.s -----------------------------------

                             ;* Check char in A for binary digit
                             ;* Return: CC = False, CS = True
                             ;****************************************
d888 :                       df_tk_isbin
d888 : c930             [ 2] 	cmp #'0'
d88a : f005             [ 3] 	beq df_tk_isbin_true	; C=1
d88c : c931             [ 2] 	cmp #'1'
d88e : f001             [ 3] 	beq df_tk_isbin_true	; C=1
d890 : 18               [ 2] 	clc
d891 :                       df_tk_isbin_true
d891 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_ishex
                             ;* Check char in A for number 0-9, A-F, a-f
                             ;* Return: CC = False, CS = True
                             ;****************************************
d892 :                       df_tk_ishex
d892 : 48               [ 3] 	pha
d893 : 207dd8           [ 6] 	jsr df_tk_isdigit
d896 : b00a             [ 3] 	bcs df_tk_ishex_truep
d898 : 0920             [ 2] 	ora #0x20
d89a : c967             [ 2] 	cmp #'f'+1
d89c : b006             [ 3] 	bcs df_tk_ishex_false
d89e : c961             [ 2] 	cmp #'a'
d8a0 : 9002             [ 3] 	bcc df_tk_ishex_false
                             	; C must be 1 here
d8a2 :                       df_tk_ishex_truep
d8a2 : 68               [ 4] 	pla
d8a3 : 60               [ 6] 	rts
d8a4 :                       df_tk_ishex_false
d8a4 :                       df_tk_isalpha_false
d8a4 : 18               [ 2] 	clc
d8a5 : 68               [ 4] 	pla
d8a6 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isalpha
                             ;* Check next char in A alpha a-z, A-Z
                             ;* Return: CC = False, CS = True
                             ;****************************************
d8a7 :                       df_tk_isalpha
d8a7 : 48               [ 3] 	pha
d8a8 : 0920             [ 2] 	ora #0x20					; Convert to lower case for checki
d8aa : c97b             [ 2] 	cmp #'z'+1
d8ac : b0f6             [ 3] 	bcs df_tk_isalpha_false
d8ae : c961             [ 2] 	cmp #'a'
d8b0 : 90f2             [ 3] 	bcc df_tk_isalpha_false
                             	; C must be 1 here
d8b2 : 68               [ 4] 	pla
d8b3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_isalphanum
                             ;* Check next char A for a-z,A-Z,0-9
                             ;* Return: CC = False, CS = True
                             ;****************************************
d8b4 :                       df_tk_isalphanum
d8b4 : 20a7d8           [ 6] 	jsr df_tk_isalpha
d8b7 : 90c4             [ 3] 	bcc df_tk_isdigit
d8b9 :                       df_tk_rts1				; branch to this RTS where possible
d8b9 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  158
---------------------------------- bank0.s -----------------------------------

                             
                             ;****************************************
                             ;* df_tk_isproc
                             ;* Check next char A for _
                             ;* Return: CC = False, CS = True
                             ;****************************************
d8ba :                       df_tk_isproc
d8ba : c95f             [ 2] 	cmp #'_'
d8bc : f001             [ 3] 	beq df_tk_isproc_true	; C=1
d8be : 18               [ 2] 	clc
d8bf :                       df_tk_isproc_true
d8bf : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_skip_ws
                             ;* Skip ws in linbuff
                             ;* Return: linoff updated to next non-ws, A = cha
                             ;****************************************
d8c0 :                       df_tk_skip_ws
d8c0 :                       df_tk_ws_loop1
d8c0 : 205ed8           [ 6] 	jsr df_tk_peek_buf
d8c3 : 20cfd8           [ 6] 	jsr df_tk_isws
d8c6 : 90f1             [ 3] 	bcc df_tk_rts1
d8c8 : e67d             [ 5] 	inc df_linoff
d8ca : 206fd8           [ 6] 	jsr df_tk_put_tok
d8cd : 90f1             [ 3] 	bcc df_tk_ws_loop1		; Always as put_tok clears C
                             
                             ;****************************************
                             ;* df_tk_skip_ws
                             ;* Skip ws in linbuff
                             ;* Return: linoff updated to next non-ws, A = cha
                             ;****************************************
                             ;df_tk_strip_ws
                             ;df_tk_sws_loop1
                             ;	jsr df_tk_peek_buf
                             ;	jsr df_tk_isws
                             ;	bcc df_tk_rts1
                             ;	inc df_linoff
                             ;	bcs df_tk_sws_loop1		; Always as C is not touch
                             
                             ;****************************************
                             ;* df_tk_isws
                             ;* Check char is ws (only space is counted)
                             ;* Return: CC = False, CS = True
                             ;****************************************
d8cf :                       df_tk_isws
d8cf : c920             [ 2] 	cmp #' '
d8d1 : d001             [ 3] 	bne df_tk_isws_false
                             	; C must be 1 here
d8d3 : 60               [ 6] 	rts
d8d4 :                       df_tk_isws_false
d8d4 :                       df_tk_expectok
d8d4 : 18               [ 2] 	clc
d8d5 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* CC = found, CS = Error
                             ;****************************************
d8d6 :                       df_tk_expect
d8d6 : 48               [ 3] 	pha
AS65 Assembler for R6502 [1.42].                                     Page  159
---------------------------------- bank0.s -----------------------------------

                             	; skip ws
d8d7 : 20c0d8           [ 6] 	jsr df_tk_skip_ws
                             	; peek the buffer
d8da : 68               [ 4] 	pla
d8db : a47d             [ 3] 	ldy df_linoff
d8dd : d90004           [ 4] 	cmp df_linbuff,y
                             	; if expected char then ok
d8e0 : f0f2             [ 3] 	beq df_tk_expectok
                             	; else error
d8e2 :                       df_tk_num_err
d8e2 :                       df_tk_char_err
d8e2 : 38               [ 2] 	sec
d8e3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* Tokenises the character as well
                             ;* CC = found, CS = Error
                             ;****************************************
d8e4 :                       df_tk_expect_tok
d8e4 : 20d6d8           [ 6] 	jsr df_tk_expect
d8e7 : b0d0             [ 3] 	bcs df_tk_rts1
d8e9 : 2064d8           [ 6] 	jsr df_tk_get_buf
d8ec : 4c6fd8           [ 3] 	jmp df_tk_put_tok
                             
                             ;****************************************
                             ;* Find a character expected ignoring ws
                             ;* Input A = expected char
                             ;* Tokenises the character as well
                             ;* FATAL IF NOT FOUND
                             ;****************************************
d8ef :                       df_tk_expect_tok_err
d8ef : 20e4d8           [ 6] 	jsr df_tk_expect_tok
d8f2 : 90c5             [ 3] 	bcc df_tk_rts1
d8f4 :                       df_tk_expect_tok_fatal
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Tokenise a constant number
                             ;****************************************
d8f6 :                       df_tk_num
                             	; X,A = address, linbuff must be on page boundar
d8f6 : 18               [ 2] 	clc
d8f7 : a900             [ 2] 	lda #lo(df_linbuff)
d8f9 : 657d             [ 3] 	adc df_linoff
d8fb : aa               [ 2] 	tax
d8fc : a904             [ 2] 	lda #hi(df_linbuff)
d8fe : 6900             [ 2] 	adc #0
d900 : a000             [ 2] 	ldy #0				; any numeric format
d902 : 20d1c1           [ 6] 	jsr con_n_to_a
d905 : b0db             [ 4] 	bcs df_tk_num_err
                             	; A = format
                             	; X = how many digits processed
                             	; Jump over that many chars
d907 : a8               [ 2] 	tay
d908 : 18               [ 2] 	clc
d909 : 8a               [ 2] 	txa
d90a : 657d             [ 3] 	adc df_linoff
d90c : 857d             [ 3] 	sta df_linoff
                             	; Now tokenise an integer (always 2 bytes, but t
AS65 Assembler for R6502 [1.42].                                     Page  160
---------------------------------- bank0.s -----------------------------------

d90e : 98               [ 2] 	tya
d90f : c901             [ 2] 	cmp #NUM_DEC
d911 : d004             [ 3] 	bne df_tk_num_hexbin
d913 : a909             [ 2] 	lda #DFTK_INTDEC	; decimal always an int
d915 : d016             [ 3] 	bne df_tk_num_put
d917 :                       df_tk_num_hexbin
d917 : c902             [ 2] 	cmp #NUM_HEX
d919 : d00a             [ 3] 	bne df_tk_num_bin
d91b : a906             [ 2] 	lda #DFTK_BYTHEX	; Assume BYT
d91d : e005             [ 2] 	cpx #5				; If >4 chars then INT
d91f : 900c             [ 3] 	bcc df_tk_num_put
d921 : a90a             [ 2] 	lda #DFTK_INTHEX
d923 : d008             [ 3] 	bne df_tk_num_put
d925 :                       df_tk_num_bin
d925 : a907             [ 2] 	lda #DFTK_BYTBIN	; Assume BYT
d927 : e00b             [ 2] 	cpx #11				; If >10 chars then INT
d929 : 9002             [ 3] 	bcc df_tk_num_put
d92b : a90b             [ 2] 	lda #DFTK_INTBIN
d92d :                       df_tk_num_put
d92d : 206fd8           [ 6] 	jsr df_tk_put_tok	; Save number type (DEC,HEX,BI
d930 : a53d             [ 3] 	lda num_a
d932 : 206fd8           [ 6] 	jsr df_tk_put_tok
d935 : a53e             [ 3] 	lda num_a+1
d937 : 4c6fd8           [ 3] 	jmp df_tk_put_tok
                             
                             ;****************************************
                             ;* Tokenise a constant char
                             ;****************************************
d93a :                       df_tk_char
                             	; skip the first quote
d93a : 2064d8           [ 6] 	jsr df_tk_get_buf
                             	; put in the token
d93d : a900             [ 2] 	lda #DFTK_CHR
d93f : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	; get the char value and save
d942 : 2064d8           [ 6] 	jsr df_tk_get_buf
d945 : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	; always put two bytes in, even for a BYTE type
d948 : a900             [ 2] 	lda #0
d94a : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	; next byte must be single quote
d94d : 2064d8           [ 6] 	jsr df_tk_get_buf
d950 : c927             [ 2] 	cmp #0x27
d952 : d08e             [ 4] 	bne df_tk_char_err
d954 : 18               [ 2] 	clc
d955 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Tokenise a constant string
                             ;****************************************
d956 :                       df_tk_str
                             	; skip the first quote
d956 : 2064d8           [ 6] 	jsr df_tk_get_buf
                             	; put in the token
d959 : a910             [ 2] 	lda #DFTK_STRLIT
d95b : 206fd8           [ 6] 	jsr df_tk_put_tok
d95e :                       df_tk_str_ch
                             	; copy string chars in to token buffer
                             	; until another quote or end of line
d95e : 2064d8           [ 6] 	jsr df_tk_get_buf
d961 : c900             [ 2] 	cmp #0
d963 : f011             [ 3] 	beq df_tk_str_err
AS65 Assembler for R6502 [1.42].                                     Page  161
---------------------------------- bank0.s -----------------------------------

d965 : c922             [ 2] 	cmp #0x22
d967 : f006             [ 3] 	beq df_tk_str_don
d969 : 206fd8           [ 6] 	jsr df_tk_put_tok
d96c : 4c5ed9           [ 3] 	jmp df_tk_str_ch
d96f :                       df_tk_str_don
                             	; zero terminated strings
d96f : a900             [ 2] 	lda #0
d971 : 4c6fd8           [ 3] 	jmp df_tk_put_tok
d974 :                       df_tk_var_noarry
d974 : 18               [ 2] 	clc
d975 : 60               [ 6] 	rts
d976 :                       df_tk_str_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Tokenise a constant (num, string, char)
                             ;****************************************
d978 :                       df_tk_const
d978 : 20c0d8           [ 6] 	jsr df_tk_skip_ws
                             	; Check what constant it is
d97b : 205ed8           [ 6] 	jsr df_tk_peek_buf
                             	; Minus symbol could be start of a number
d97e : c92d             [ 2] 	cmp #'-'
d980 : f005             [ 3] 	beq df_tk_const_try_num
d982 : 207dd8           [ 6] 	jsr df_tk_isdigit
d985 : 9003             [ 3] 	bcc df_tk_const_try_str
d987 :                       df_tk_const_try_num
d987 : 4cf6d8           [ 3] 	jmp df_tk_num
d98a :                       df_tk_const_try_str
                             	; check for double quote
d98a : c922             [ 2] 	cmp #0x22
d98c : d003             [ 3] 	bne df_tk_const_try_char
d98e : 4c56d9           [ 3] 	jmp df_tk_str
d991 :                       df_tk_const_try_char
                             	; check for single apostrophe
d991 : c927             [ 2] 	cmp #0x27
d993 : d003             [ 3] 	bne df_tk_const_err
d995 : 4c3ad9           [ 3] 	jmp df_tk_char
d998 :                       df_tk_const_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Tokenise a variable - A = mask
                             ;* Return : A = variable index
                             ;****************************************
d99a :                       df_tk_var
                             	; Find or create variable, address in X,A
d99a : 20f9d7           [ 6] 	jsr df_var_findcreate
d99d : 9001             [ 3] 	bcc df_tk_var_cont
d99f : 60               [ 6] 	rts
d9a0 :                       df_tk_var_cont
                             	; Save X,A for later
d9a0 : 48               [ 3] 	pha
d9a1 : 8a               [ 2] 	txa
d9a2 : 48               [ 3] 	pha
                             	; Put VAR escape in token buffer
d9a3 : a911             [ 2] 	lda #DFTK_VAR
d9a5 : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	; Get variable address and put in token buffer
d9a8 : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page  162
---------------------------------- bank0.s -----------------------------------

d9a9 : 206fd8           [ 6] 	jsr df_tk_put_tok
d9ac : 68               [ 4] 	pla
d9ad : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	; count of any array indices
d9b0 :                       df_tk_var_ck
                             	; check if array procesing needed
d9b0 : a95b             [ 2] 	lda #'['
d9b2 : 20e4d8           [ 6] 	jsr df_tk_expect_tok
d9b5 : b0bd             [ 3] 	bcs df_tk_var_noarry
                             	; process numeric expression in bracket
d9b7 : 4c61da           [ 3] 	jmp df_tk_narry
                             
                             
                             ;****************************************
                             ;* Tokenise a parameter in proc definition
                             ;* Return : A = variable index
                             ;****************************************
d9ba :                       df_tk_parm
                             	; if preceeding with non-local qualifier DFTK_VA
d9ba : 205ed8           [ 6] 	jsr df_tk_peek_buf
d9bd : c926             [ 2] 	cmp #DFTK_VARPARM
d9bf : d006             [ 3] 	bne df_tk_parm_skip_var
                             	; get the qualifier and put in token buffer
d9c1 : 2064d8           [ 6] 	jsr df_tk_get_buf
d9c4 : 206fd8           [ 6] 	jsr df_tk_put_tok
d9c7 :                       df_tk_parm_skip_var
                             	; don't have a certain type of var
d9c7 : a900             [ 2] 	lda #0
d9c9 : 4c9ad9           [ 3] 	jmp df_tk_var
                             
                             
                             ;****************************************
                             ;* Tokenise a variable to localise
                             ;* Return : A,X = variable index
                             ;****************************************
d9cc :                       df_tk_localvar
                             	; Find or create variable, index in A
d9cc : 20f9d7           [ 6] 	jsr df_var_findcreate
d9cf : 9001             [ 3] 	bcc df_tk_localvar_cont
d9d1 : 60               [ 6] 	rts
d9d2 :                       df_tk_localvar_cont
                             	; Save variable address for later
d9d2 : 48               [ 3] 	pha
d9d3 : 8a               [ 2] 	txa
d9d4 : 48               [ 3] 	pha
                             	; Put VAR escape in token buffer
d9d5 : a911             [ 2] 	lda #DFTK_VAR
d9d7 : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	; Get variable index and put in token buffer
d9da : 68               [ 4] 	pla
d9db : 206fd8           [ 6] 	jsr df_tk_put_tok
d9de : 68               [ 4] 	pla
d9df : 4c6fd8           [ 3] 	jmp df_tk_put_tok
                             
                             ;****************************************
                             ;* Tokenise array variable
                             ;* Return : A = variable index
                             ;****************************************
d9e2 :                       df_tk_arrvar
                             	; Like a local var at first
d9e2 : 20ccd9           [ 6] 	jsr df_tk_localvar
                             	; but must be array
AS65 Assembler for R6502 [1.42].                                     Page  163
---------------------------------- bank0.s -----------------------------------

d9e5 : a95b             [ 2] 	lda #'['
d9e7 : 20efd8           [ 6] 	jsr df_tk_expect_tok_err
                             	; process numeric expression in bracket
d9ea : 4c61da           [ 3] 	jmp df_tk_narry
                             
                             ;****************************************
                             ;* Tokenise call or def of proc
                             ;* Mode : A = 0 means def, else call
                             ;****************************************
d9ed :                       df_tk_proc
d9ed : 858c             [ 3] 	sta df_procmode
d9ef : 20c0d8           [ 6] 	jsr df_tk_skip_ws
                             	; Find or create proc, index in A
d9f2 : a940             [ 2] 	lda #DFVVT_PROC
d9f4 : 20f9d7           [ 6] 	jsr df_var_findcreate
d9f7 : b066             [ 4] 	bcs df_tk_proc_err
                             
                             	; Save variable address for later
d9f9 : 868f             [ 3] 	stx df_procptr
d9fb : 8590             [ 3] 	sta df_procptr+1
                             
                             	; Put PROC escape in token buffer
d9fd : a912             [ 2] 	lda #DFTK_PROC
d9ff : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	; Get variable address and put in token buffer
da02 : a58f             [ 3] 	lda df_procptr
da04 : 206fd8           [ 6] 	jsr df_tk_put_tok
da07 : a590             [ 3] 	lda df_procptr+1
da09 : 206fd8           [ 6] 	jsr df_tk_put_tok
                             
                             	; initially assume no args
da0c : a900             [ 2] 	lda #0
da0e : 858d             [ 3] 	sta df_procargs
                             
                             	; Must have an open bracket
da10 : a928             [ 2] 	lda #'('
da12 : 20efd8           [ 6] 	jsr df_tk_expect_tok_err
                             	; if immediately followed by close bracket then 
da15 : 205ed8           [ 6] 	jsr df_tk_peek_buf
da18 : c929             [ 2] 	cmp #')'
da1a : f030             [ 3] 	beq df_tk_proc_noparm
                             	; else tokenise parm variables
da1c :                       df_tk_proc_parms
da1c : 20c0d8           [ 6] 	jsr df_tk_skip_ws
                             	; call appropriate routine for mode
da1f : a58c             [ 3] 	lda df_procmode
da21 : d006             [ 3] 	bne df_tk_proc_call
                             	; tokenise parameter variable in def mode
da23 : 20bad9           [ 6] 	jsr df_tk_parm
da26 : 4c32da           [ 3] 	jmp df_tk_proc_skip_call
da29 :                       df_tk_proc_call
                             	; tokenise expression in call mode
                             	;**CHECK**
da29 : a58d             [ 3] 	lda df_procargs	; procargs could be impacted ins
da2b : 48               [ 3] 	pha
da2c : 20e1da           [ 6] 	jsr df_tk_expression
da2f : 68               [ 4] 	pla
da30 : 858d             [ 3] 	sta df_procargs
da32 :                       df_tk_proc_skip_call
da32 : b02a             [ 3] 	bcs df_tk_proc_errp
                             	; increment number of args
da34 : e68d             [ 5] 	inc df_procargs
AS65 Assembler for R6502 [1.42].                                     Page  164
---------------------------------- bank0.s -----------------------------------

                             	; what is next non ws char
da36 : 20c0d8           [ 6] 	jsr df_tk_skip_ws
da39 : c92c             [ 2] 	cmp #','
da3b : f006             [ 3] 	beq df_tk_proc_comma
da3d : c929             [ 2] 	cmp #')'
da3f : d01d             [ 3] 	bne df_tk_proc_errp
da41 : f009             [ 3] 	beq df_tk_proc_noparm
                             	; comma found, more parms to process
da43 :                       df_tk_proc_comma
da43 : 2064d8           [ 6] 	jsr df_tk_get_buf
da46 : 206fd8           [ 6] 	jsr df_tk_put_tok
da49 : 4c1cda           [ 3] 	jmp df_tk_proc_parms
da4c :                       df_tk_proc_noparm
                             	; consume the close bracket
da4c : 2064d8           [ 6] 	jsr df_tk_get_buf
da4f : 206fd8           [ 6] 	jsr df_tk_put_tok
                             
                             	; update arg count if def mode
da52 : a68c             [ 3] 	ldx df_procmode
da54 : d006             [ 3] 	bne df_tk_proc_skip_args
                             	; use address of proc
                             	; put arg count in dim2
da56 : a004             [ 2] 	ldy #DFVVT_DIM2
da58 : a58d             [ 3] 	lda df_procargs
da5a : 918f             [ 5] 	sta (df_procptr),y
da5c :                       df_tk_proc_skip_args
da5c : 18               [ 2] 	clc
da5d : 60               [ 6] 	rts
da5e :                       df_tk_proc_errp
da5e : 68               [ 4] 	pla
da5f :                       df_tk_proc_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse array index
                             ;****************************************
da61 :                       df_tk_narry
                             	; if array open bracket encountered
                             	; then tokenise a numeric expression
da61 : 20e1da           [ 6] 	jsr df_tk_expression
                             	; If a comma is next, then another expression
da64 : a92c             [ 2] 	lda #','
da66 : 20e4d8           [ 6] 	jsr df_tk_expect_tok
da69 : b003             [ 3] 	bcs df_tk_narry_end
da6b : 20e1da           [ 6] 	jsr df_tk_expression
da6e :                       df_tk_narry_end
                             	; after the second dimension, must be close sq b
da6e : a95d             [ 2] 	lda #']'
da70 : 4cefd8           [ 3] 	jmp df_tk_expect_tok_err
                             
                             ;****************************************
                             ;* Parse bracket
                             ;****************************************
da73 :                       df_tk_nbrkt
                             	; if  open bracket encountered
                             	; then tokenise a numeric expression
da73 : 20e1da           [ 6] 	jsr df_tk_expression
da76 : a929             [ 2] 	lda #')'
da78 : 4cefd8           [ 3] 	jmp df_tk_expect_tok_err
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  165
---------------------------------- bank0.s -----------------------------------

                             ;* Parse call to numeric proc
                             ;****************************************
da7b :                       df_tk_nterm_proc
                             	; call mode
da7b : a901             [ 2] 	lda #1
da7d : 4cedd9           [ 3] 	jmp df_tk_proc
                             
                             ;****************************************
                             ;* Parse numeric term
                             ;****************************************
da80 :                       df_tk_nterm
                             	; skip any ws first, copying in to tokbuff
                             	; A containts the non-ws char
da80 : 20c0d8           [ 6] 	jsr df_tk_skip_ws
da83 : c900             [ 2] 	cmp #0
da85 : f004             [ 3] 	beq df_tk_nterm_done
da87 : c93a             [ 2] 	cmp #':'
da89 : d002             [ 3] 	bne df_tk_nterm_cont
da8b :                       df_tk_nterm_done
da8b :                       df_tk_nop_false
da8b : 38               [ 2] 	sec
da8c : 60               [ 6] 	rts
da8d :                       df_tk_nterm_cont
                             	; if open bracket then process it
da8d : c928             [ 2] 	cmp #'('
da8f : d009             [ 3] 	bne df_tk_nterm_tryfn
                             	; get the bracket and put in token buffer
da91 : 2064d8           [ 6] 	jsr df_tk_get_buf
da94 : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	; go process the open bracket
da97 : 4c73da           [ 3] 	jmp df_tk_nbrkt
da9a :                       df_tk_nterm_tryfn
da9a : 48               [ 3] 	pha
                             	; try decoding a built-in function
da9b : a902             [ 2] 	lda #DFTK_FN
da9d : 20d4db           [ 6] 	jsr df_tk_matchtok
daa0 : b00e             [ 3] 	bcs df_tk_nterm_try_proc
                             	; pull old A in to Y but don't use
daa2 : 68               [ 4] 	pla
daa3 : a8               [ 2] 	tay
                             	; restore A and put the token with MSB set
daa4 : 8a               [ 2] 	txa
daa5 : 0980             [ 2] 	ora #0x80
daa7 : 206fd8           [ 6] 	jsr df_tk_put_tok
daaa : 20a6db           [ 6] 	jsr df_tk_exec_parser
daad : b01b             [ 3] 	bcs df_tk_nterm_err
daaf : 60               [ 6] 	rts
dab0 :                       df_tk_nterm_try_proc
dab0 : 68               [ 4] 	pla
                             	; if it's not a func then try proc
dab1 : 20bad8           [ 6] 	jsr df_tk_isproc
dab4 : 9006             [ 3] 	bcc df_tk_nterm_try_var
dab6 : 207bda           [ 6] 	jsr df_tk_nterm_proc
dab9 : b00f             [ 3] 	bcs df_tk_nterm_err
dabb : 60               [ 6] 	rts
dabc :                       df_tk_nterm_try_var
                             	; Non-zero mask means var must be this type
dabc : a900             [ 2] 	lda #0
dabe : 209ad9           [ 6] 	jsr df_tk_var
dac1 : b001             [ 3] 	bcs df_tk_nterm_try_const
dac3 : 60               [ 6] 	rts
dac4 :                       df_tk_nterm_try_const
AS65 Assembler for R6502 [1.42].                                     Page  166
---------------------------------- bank0.s -----------------------------------

                             	; Try decoding a constant
dac4 : 2078d9           [ 6] 	jsr df_tk_const
dac7 : b001             [ 3] 	bcs df_tk_nterm_err
dac9 : 60               [ 6] 	rts
daca :                       df_tk_nterm_err
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse numeric operator
                             ;****************************************
dacc :                       df_tk_nop
dacc : 20c0d8           [ 6] 	jsr df_tk_skip_ws
dacf : c900             [ 2] 	cmp #0
dad1 : f0b8             [ 3] 	beq df_tk_nop_false
                             	; must be an operator token for numeric
dad3 : a90c             [ 2] 	lda #DFTK_OP | DFTK_STROP
dad5 : 20d4db           [ 6] 	jsr df_tk_matchtok
dad8 : b0b1             [ 3] 	bcs df_tk_nop_false
                             	; got a token
dada : 0980             [ 2] 	ora #DFTK_TOKEN
dadc : 206fd8           [ 6] 	jsr df_tk_put_tok
dadf : 18               [ 2] 	clc
dae0 : 60               [ 6] 	rts
                             
                             	
                             ;****************************************
                             ;* Parse numeric expression
                             ;****************************************
dae1 :                       df_tk_expression
                             	; Tokenise a numeric term
dae1 : 2080da           [ 6] 	jsr df_tk_nterm
dae4 : b006             [ 3] 	bcs df_tk_expre_err
                             	; Try and tokenise a numeric operator
dae6 : 20ccda           [ 6] 	jsr df_tk_nop
                             	; If an operator was tokenised
                             	; then loop back for another term
dae9 : 90f6             [ 3] 	bcc df_tk_expression
                             	; If no operator was found then
                             	; expression is done
daeb :                       df_tk_not_eos
daeb : 18               [ 2] 	clc
daec :                       df_tk_expre_err
daec : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find expected token and parse expression
                             ;****************************************
daed :                       df_tk_tok_expression
daed : 20efd8           [ 6] 	jsr df_tk_expect_tok_err
daf0 : 4ce1da           [ 3] 	jmp df_tk_expression
                             
                             
                             ;****************************************
                             ;* Check end of statement
                             ;****************************************
daf3 :                       df_tk_isEOS
daf3 : a93a             [ 2] 	lda #':'
daf5 : 20e4d8           [ 6] 	jsr df_tk_expect_tok
daf8 : b0f1             [ 3] 	bcs df_tk_not_eos
                             	; this is the position of the next statement
dafa : a57e             [ 3] 	lda df_tokoff
AS65 Assembler for R6502 [1.42].                                     Page  167
---------------------------------- bank0.s -----------------------------------

                             	; put it in the last statement offset slot
dafc : a480             [ 3] 	ldy df_nxtstidx
dafe : 998004           [ 5] 	sta df_tokbuff,y
db01 : 38               [ 2] 	sec
db02 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* Parse user defined proc
                             ;****************************************
db03 :                       df_tk_parse_user_proc
                             	; put proc token in as a call
db03 : a981             [ 2] 	lda #0x81
db05 : 206fd8           [ 6] 	jsr df_tk_put_tok
db08 : a901             [ 2] 	lda #1
db0a : 4cedd9           [ 3] 	jmp df_tk_proc
                             
                             
                             ;****************************************
                             ;* Parse a command
                             ;* Do not fatal error if this fails
                             ;****************************************
db0d :                       df_tk_parse_command
                             	; only looking for keywords
db0d : a901             [ 2] 	lda #DFTK_KW
db0f : 20d4db           [ 6] 	jsr df_tk_matchtok
                             	; if didn't find regular keywords then try non f
db12 : b010             [ 3] 	bcs df_tk_parse_command_err
                             	; if match then store token in the line buffer
                             	; Set MSB
db14 : 0980             [ 2] 	ora #0x80
db16 : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	; call the parser to do tokenise based on the st
db19 : a584             [ 3] 	lda df_symoff
db1b : 20a6db           [ 6] 	jsr df_tk_exec_parser
db1e : b004             [ 3] 	bcs df_tk_parse_command_err
                             	; [1] ignore white space but keep it
db20 : 20c0d8           [ 6] 	jsr df_tk_skip_ws
                             	; No error in parsing this command
db23 :                       df_tk_parse_command_done
db23 : 18               [ 2] 	clc
db24 :                       df_tk_parse_command_err
db24 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* lexer
                             ;****************************************
db25 :                       df_lexer_line
db25 : a900             [ 2] 	lda #0
                             	; start at the beginning of the line buffer
db27 : 857d             [ 3] 	sta df_linoff
                             	; start at the beginning of the tokenised buffer
db29 : 857e             [ 3] 	sta df_tokoff
                             	; set current line to the token buffer
db2b : a980             [ 2] 	lda #lo(df_tokbuff)
db2d : 8587             [ 3] 	sta df_currlin
db2f : a904             [ 2] 	lda #hi(df_tokbuff)
db31 : 8588             [ 3] 	sta df_currlin+1
                             	; Set the line length to 0
db33 : a900             [ 2] 	lda #0
db35 : 206fd8           [ 6] 	jsr df_tk_put_tok
AS65 Assembler for R6502 [1.42].                                     Page  168
---------------------------------- bank0.s -----------------------------------

                             
                             	; any leading white space, ignore and discard
                             ;	jsr df_tk_strip_ws
                             
                             	; if peek next character is a number then assume
                             	; else assume a statement
db38 : 205ed8           [ 6] 	jsr df_tk_peek_buf
db3b : 207dd8           [ 6] 	jsr df_tk_isdigit
db3e : 9006             [ 3] 	bcc df_lexer_skip_lnum
                             	; if line number then capture the line number an
db40 : 20b5db           [ 6] 	jsr df_tk_linenum
db43 : 4c4edb           [ 3] 	jmp df_tk_body
db46 :                       df_lexer_skip_lnum
                             	; if no line number then zero out the line numbe
                             	; line zero will indicate an immediate mode comm
db46 : a900             [ 2] 	lda #0
db48 : 206fd8           [ 6] 	jsr df_tk_put_tok				; Line num low byte
db4b : 206fd8           [ 6] 	jsr df_tk_put_tok				; Line num high byte
db4e :                       df_tk_body
                             	; Offset for next statement
db4e : a57e             [ 3] 	lda df_tokoff
db50 : 8580             [ 3] 	sta df_nxtstidx
db52 : a900             [ 2] 	lda #0
db54 : 206fd8           [ 6] 	jsr df_tk_put_tok				; Offset to next statement
db57 : 205ed8           [ 6] 	jsr df_tk_peek_buf				; Check for a single space
db5a : 20cfd8           [ 6] 	jsr df_tk_isws					; and first character
db5d : 9002             [ 3] 	bcc df_tk_skip_1_spc
db5f : e67d             [ 5] 	inc df_linoff					; Don't tokenise this single s
db61 :                       df_tk_skip_1_spc
                             	; [1] capture white space from line buffer in to
db61 : 20c0d8           [ 6] 	jsr df_tk_skip_ws
                             	; If next non ws is zero then this is an empty l
                             	; so return with length zero but line number fil
                             	; token buffer
db64 : c900             [ 2] 	cmp #0
db66 : f03a             [ 3] 	beq df_tk_line_empty
                             	; if next char is _ then parse a user defined pr
db68 : 20bad8           [ 6] 	jsr df_tk_isproc
db6b : 9006             [ 3] 	bcc df_tk_try_command
db6d : 2003db           [ 6] 	jsr df_tk_parse_user_proc
db70 : 4c84db           [ 3] 	jmp df_tk_done
db73 :                       df_tk_try_command
                             	; try a keyword
db73 : 200ddb           [ 6] 	jsr df_tk_parse_command
db76 : b002             [ 3] 	bcs	df_tk_try_asm
db78 : 900a             [ 3] 	bcc df_tk_done
db7a :                       df_tk_try_asm
                             	; try an asm keyword
db7a : 2095f9           [ 6] 	jsr df_tk_asm_parse_command
db7d : 9005             [ 3] 	bcc df_tk_done
db7f :                       df_tk_try_assign
                             	; nothing but to try an assignment operation
db7f : 2032df           [ 6] 	jsr df_tk_assign
db82 : b020             [ 3] 	bcs	df_tk_parseerror
db84 :                       df_tk_done
                             	; put statement index stuff here in case of mult
                             	; check for : and if present tokenise plus updat
                             	; then go back to try and process another statem
db84 : 20f3da           [ 6] 	jsr df_tk_isEOS
db87 : b0c5             [ 3] 	bcs df_tk_body
                             	; if not at end of line, then must be error
db89 : 205ed8           [ 6] 	jsr df_tk_peek_buf
AS65 Assembler for R6502 [1.42].                                     Page  169
---------------------------------- bank0.s -----------------------------------

db8c : c900             [ 2] 	cmp #0
db8e : d014             [ 3] 	bne df_tk_parseerror
                             	; this is the position of the next line
db90 : a57e             [ 3] 	lda df_tokoff
                             	; put it in the last statement offset slot
db92 : a480             [ 3] 	ldy df_nxtstidx
db94 : 998004           [ 5] 	sta df_tokbuff,y
                             	; Get line length
db97 : a47e             [ 3] 	ldy df_tokoff
                             	; ensure there is always a zero after the last t
                             	; A is already zero
db99 : a900             [ 2] 	lda #0
db9b : 998004           [ 5] 	sta df_tokbuff,y
                             	; save the line length
db9e : 98               [ 2] 	tya
db9f : 8d8004           [ 4] 	sta df_tokbuff
dba2 :                       df_tk_line_empty
dba2 : 18               [ 2] 	clc
dba3 : 60               [ 6] 	rts
dba4 :                       df_tk_parseerror
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* df_tk_parsestatement
                             ;* Execute parse routine for this statement
                             ;* Input: df_tokoff is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
dba6 :                       df_tk_exec_parser
dba6 : 0a               [ 2] 	asl a
dba7 : aa               [ 2] 	tax
dba8 : bde9dd           [ 4] 	lda df_tk_tokenjmp,x
dbab : 85a2             [ 3] 	sta df_tmpptra
dbad : bdeadd           [ 4] 	lda df_tk_tokenjmp+1,x
dbb0 : 85a3             [ 3] 	sta df_tmpptra+1
dbb2 : 6ca200           [ 6] 	jmp (df_tmpptra)
                             
                             
                             ;****************************************
                             ;* df_tk_linenum
                             ;* Tokenise line number
                             ;****************************************
dbb5 :                       df_tk_linenum
                             	; Convert line number to 16 bit number
                             	; Save the line number
                             	; Increment the buffer pointer
dbb5 : 18               [ 2] 	clc
dbb6 : a900             [ 2] 	lda #lo(df_linbuff)
dbb8 : 657d             [ 3] 	adc df_linoff
dbba : aa               [ 2] 	tax
dbbb : a904             [ 2] 	lda #hi(df_linbuff)
dbbd : 6900             [ 2] 	adc #0
dbbf : a001             [ 2] 	ldy #1			; Decimal format only
dbc1 : 20d1c1           [ 6] 	jsr con_n_to_a
dbc4 : 18               [ 2] 	clc
dbc5 : 8a               [ 2] 	txa
dbc6 : 657d             [ 3] 	adc df_linoff
dbc8 : 857d             [ 3] 	sta df_linoff
                             	; Now save line number
dbca : a53d             [ 3] 	lda num_a
dbcc : 206fd8           [ 6] 	jsr df_tk_put_tok
AS65 Assembler for R6502 [1.42].                                     Page  170
---------------------------------- bank0.s -----------------------------------

dbcf : a53e             [ 3] 	lda num_a+1
dbd1 : 4c6fd8           [ 3] 	jmp df_tk_put_tok
                             
                             ;****************************************
                             ;* df_tk_matchtok
                             ;* Try and find a token match against the table d
                             ;* Input:
                             ;*			Current df_linbuff and df_linoff
                             ;* Return: 	CC = No Error, CS = Error
                             ;*			df_linoff points to next char if CC else unc
                             ;*			df_symoff is the symbol table index
                             ;****************************************
dbd4 :                       df_tk_matchtok
                             	; save the mask to check types against
dbd4 : 48               [ 3] 	pha
                             	; Start at token symbols beginning
dbd5 : a956             [ 2] 	lda #lo(df_tokensyms)
dbd7 : 8582             [ 3] 	sta df_symtab
dbd9 : a9dc             [ 2] 	lda #hi(df_tokensyms)
dbdb : 8583             [ 3] 	sta df_symtab+1
dbdd : a900             [ 2] 	lda #0
dbdf : 8584             [ 3] 	sta df_symoff
dbe1 :                       df_tk_checknexttok
                             	; check this token type first
dbe1 : 68               [ 4] 	pla
dbe2 : 48               [ 3] 	pha
dbe3 : a684             [ 3] 	ldx df_symoff
dbe5 : 3dafde           [ 4] 	and df_tk_tokentype,x
dbe8 : f032             [ 4] 	beq df_tk_symnomatch
                             	; Special check for operator token
                             	; because of order of precedence fudge
                             	; ******FIX THIS ONE DAY!!!!!!******
                             	; if parm and token type = DFTK_OP then ok
                             	; if parm and token type <> DFTK_OP then not ok
dbea : bdafde           [ 4] 	lda df_tk_tokentype,x
dbed : 2908             [ 2] 	and #DFTK_OP
dbef : f009             [ 3] 	beq df_tk_matchtok_skip_op
dbf1 : 68               [ 4] 	pla
dbf2 : 48               [ 3] 	pha
dbf3 : 2908             [ 2] 	and #DFTK_OP
dbf5 : 3dafde           [ 4] 	and df_tk_tokentype,x
dbf8 : f022             [ 4] 	beq df_tk_symnomatch
dbfa :                       df_tk_matchtok_skip_op
                             	; From the line buffer current pointer
                             	; Check for a token match
dbfa : a47d             [ 3] 	ldy df_linoff
dbfc : a200             [ 2] 	ldx #0
dbfe :                       df_tk_checktokch
                             	; Get symtable char
                             	; and mask off MSB
dbfe : a182             [ 6] 	lda (df_symtab,x)
                             	; Save the value and mask off MSB
dc00 : 48               [ 3] 	pha
dc01 : 297f             [ 2] 	and #0x7f
                             	; Compare with current line buffer char
dc03 : d90004           [ 4] 	cmp df_linbuff,y
                             	; If chars not match then this symbol fails
dc06 : d013             [ 3] 	bne df_tk_symnomatchp
                             	; If match and symbol has MSB then
                             	; all of the symbol matched
dc08 : 68               [ 4] 	pla
dc09 : 3033             [ 3] 	bmi df_tk_symfound
AS65 Assembler for R6502 [1.42].                                     Page  171
---------------------------------- bank0.s -----------------------------------

                             	; else more chars to match
                             	; so increment line buffer pointers
                             	_incZPWord df_symtab
                             
dc11 : c8               [ 2] 	iny
                             	; If buffer is '.' then let this be a match
dc12 : b90004           [ 4] 	lda df_linbuff,y
dc15 : c92e             [ 2] 	cmp #'.'
dc17 : f025             [ 3] 	beq df_tk_symfound
dc19 : d0e3             [ 4] 	bne df_tk_checktokch	; branch always
dc1b :                       df_tk_symnomatchp
dc1b : 68               [ 4] 	pla
dc1c :                       df_tk_symnomatch
                             	; Increment symbol counter to next symbol
dc1c : e684             [ 5] 	inc df_symoff
dc1e :                       df_tk_symnextentry
dc1e : a200             [ 2] 	ldx #0
dc20 : a182             [ 6] 	lda (df_symtab,x)
                             	; End of symbol is MSB
dc22 : 3009             [ 3] 	bmi  df_tk_foundsymend
                             	_incZPWord df_symtab
                             
dc2a : 4c1edc           [ 3] 	jmp df_tk_symnextentry
dc2d :                       df_tk_foundsymend
                             	; Increment char to point to new symbol
                             	; for matching with line buffer
                             	_incZPWord df_symtab
                             
                             	; If next char is not zero then
                             	; try and match with line buffer
dc33 : a182             [ 6] 	lda (df_symtab,x)
dc35 : d0aa             [ 4] 	bne df_tk_checknexttok
                             	; else symbol table exhausted
                             	; so no match found
                             	; pop mask off stack
dc37 : 68               [ 4] 	pla
                             	; Zero symbol counter
dc38 : a900             [ 2] 	lda #0
dc3a : 8584             [ 3] 	sta df_symoff
                             	; Set C to indicate error (no match)
dc3c : 38               [ 2] 	sec
dc3d : 60               [ 6] 	rts
dc3e :                       df_tk_symfound
                             	; Full match with keyword in symtable but
                             	; if matching with something that ended in alpha
                             	; then check the next buffer char is not alphanu
                             	; as this could be part of a variable name
                             	; Point to next buffer char in any case
dc3e : c8               [ 2] 	iny
                             	; First mask off MSB
dc3f : 297f             [ 2] 	and #0x7f
                             	; Then check if alpha
dc41 : 20a7d8           [ 6] 	jsr df_tk_isalpha
                             	; if not alpha then we're definitely done
dc44 : 9008             [ 3] 	bcc df_tk_symfound_final
                             	; else check buffer
dc46 : b90004           [ 4] 	lda df_linbuff,y
                             	; if it is an alphanum then
dc49 : 20b4d8           [ 6] 	jsr df_tk_isalphanum
                             	; do not count as a match
dc4c : b0ce             [ 3] 	bcs df_tk_symnomatch
dc4e :                       df_tk_symfound_final
AS65 Assembler for R6502 [1.42].                                     Page  172
---------------------------------- bank0.s -----------------------------------

                             	; pop mask off stack
dc4e : 68               [ 4] 	pla
                             	; Save line buffer pointer (points to next char)
                             	; Clear C to indicate success (match)
dc4f : 847d             [ 3] 	sty df_linoff
dc51 : a584             [ 3] 	lda df_symoff
dc53 : aa               [ 2] 	tax
dc54 : 18               [ 2] 	clc
dc55 : 60               [ 6] 	rts
                             
                             	include "dflat/tksymtab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TKSYMTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Statement Token table
                             ; keywords
dc56 :                       df_tokensyms
dc56 : 80                    	db	0x80						; Implicit numeric assign
dc57 : 80                    	db	0x80						; Implicit call procedure
dc58 : bb                    	db	";"+0x80					; Comment
dc59 : 7072696e746cee        	db	"printl",'n'+0x80			; println exprlist
dc60 : 7072696e7461f4        	db	"printa",'t'+0x80			; printat x,y,exprlist
dc67 : 7072696ef4            	db	"prin",'t'+0x80				; print exprlist
dc6c : 6465e6                	db	"de",'f'+0x80				; def_subname
dc6f : 656e646465e6          	db	"endde",'f'+0x80			; enddef
dc75 : 7265747572ee          	db	"retur",'n'+0x80			; return
dc7b : 61626f72f4            	db	"abor",'t'+0x80				; abort
dc80 : 6c6f6361ec            	db	"loca",'l'+0x80				; local varlist
dc85 : 6469ed                	db	"di",'m'+0x80				; dim varlist
dc88 : 7265706561f4          	db	"repea",'t'+0x80			; repeat
dc8e : 756e7469ec            	db	"unti", 'l'+0x80			; until condition
dc93 : 666ff2                	db	"fo",'r'+0x80				; for var=start,end,incremen
dc96 : 6e6578f4              	db	"nex",'t'+0x80				; next
dc9a : 7768696ce5            	db	"whil",'e'+0x80				; while condition
dc9f : 77656ee4              	db	"wen",'d'+0x80				; wend
dca3 : 69e6                  	db	"i",'f'+0x80				; if condition
dca5 : 656c73e5              	db	"els",'e'+0x80				; else
dca9 : 656e6469e6            	db	"endi",'f'+0x80				; endif
dcae : 656c69e6              	db	"eli",'f'+0x80				; elif condition
AS65 Assembler for R6502 [1.42].                                     Page  173
---------------------------------- bank0.s -----------------------------------

dcb2 : 646174e1              	db	"dat",'a'+0x80				; data
dcb6 : ff                    	db	0xff						; assembler command (non standard p
dcb7 : 7275ee                	db	"ru",'n'+0x80				; run
dcba : 6c6973f4              	db	"lis",'t'+0x80				; list _proc-|*|line,line
dcbe : 696e7075f4            	db	"inpu",'t'+0x80				; input var
dcc3 : 746578f4              	db	"tex",'t'+0x80				; text
dcc7 : 706c6ff4              	db	"plo",'t'+0x80				; plot x,y,char|string
dccb : 637572736ff2          	db	"curso",'r'+0x80			; cursor n
dcd1 : 636cf3                	db	"cl",'s'+0x80				; cls
dcd4 : 706f6be5              	db	"pok",'e'+0x80				; poke a,v
dcd8 : 646f6be5              	db	"dok",'e'+0x80				; doke a,v
dcdc : 736f756ee4            	db	"soun",'d'+0x80				; sound
dce1 : 6d757369e3            	db	"musi",'c'+0x80				; music
dce6 : 706c61f9              	db	"pla",'y'+0x80				; play
dcea : 726561e4              	db	"rea",'d'+0x80				; read
dcee : 6e65f7                	db	"ne",'w'+0x80				; new
                             ;	db	"renu",'m'+0x80				; renum start,offset,incr
dcf1 : 776169f4              	db	"wai",'t'+0x80				; wait delay
dcf5 : 72657365f4            	db	"rese",'t'+0x80				; reset var
dcfa : 68697265f3            	db	"hire",'s'+0x80				; hires col
dcff : 706f696ef4            	db	"poin",'t'+0x80				; point x,y
dd04 : 6c696ee5              	db	"lin",'e'+0x80				; line x0,y0,x1,y1
dd08 : 6c696e6574ef          	db	"linet",'o'+0x80			; lineto x1,y1
dd0e : 7069786d6f64e5        	db	"pixmod",'e'+0x80			; pixmode n
dd15 : 696eeb                	db	"in",'k'+0x80				; ink n
dd18 : 70617065f2            	db	"pape",'r'+0x80				; paper n
dd1d : 636972636ce5          	db	"circl",'e'+0x80			; circle x,y,r
                             ;	db	"hime",'m'+0x80				; himem addr
dd23 : 636de4                	db	"cm",'d'+0x80				; cmd [the monitor]
dd26 : 737072636861f2        	db	"sprcha",'r'+0x80			; sprchar sp,ch
dd2d : 737072706ff3          	db	"sprpo",'s'+0x80			; sprpos sp,x,y
dd33 : 7370727570e4          	db	"sprup",'d'+0x80			; sprupd
dd39 : 737072696e69f4        	db	"sprini",'t'+0x80			; sprinit
dd40 : 7370726d756c74e9      	db	"sprmult",'i'+0x80			; sprmulti x[],y[]
                             ;	db	"sav",'e'+0x80				; save "fname"
                             ;	db	"loa",'d'+0x80				; load "fname"
dd48 : 62736176e5            	db	"bsav",'e'+0x80				; bsave addr,len,"fname"
dd4d : 626c6f61e4            	db	"bloa",'d'+0x80				; bload addr,"fname"
dd52 : 74736176e5            	db	"tsav",'e'+0x80				; tsave "fname"
dd57 : 746c6f61e4            	db	"tloa",'d'+0x80				; tload "fname"
dd5c : 6465ec                	db 	"de",'l'+0x80				; del "fname"
dd5f : 6469f2                	db	"di",'r'+0x80				; dir
dd62 : 72656469ed            	db	"redi",'m'+0x80				; redim varlist
                             ; Functions
dd67 : 7065656ba8            	db	"peek",'('+0x80				; peek(x)
dd6c : 6465656ba8            	db	"deek",'('+0x80				; peek(x)
dd71 : 737469636ba8          	db	"stick",'('+0x80			; stick(x)
dd77 : 676574a8              	db	"get",'('+0x80				; get(x)
dd7b : 636872a8              	db	"chr",'('+0x80				; chr(x)
dd7f : 6c656674a8            	db	"left",'('+0x80				; left(x$,y)
dd84 : 7269676874a8          	db	"right",'('+0x80			; right(x$,y)
dd8a : 6d6964a8              	db	"mid",'('+0x80				; mid(x$,y)
dd8e : 6c656ea8              	db	"len",'('+0x80				; len(x$)
dd92 : 6d656da8              	db	"mem",'('+0x80				; mem(x)
dd96 : 7363726ea8            	db	"scrn",'('+0x80				; scrn(x,y)
dd9b : 726e64a8              	db	"rnd",'('+0x80				; rnd(x)
dd9f : 656c6170736564a8      	db	"elapsed",'('+0x80			; elapsed(var)
dda7 : 63616c6ca8            	db	"call",'('+0x80				; call(addr,A,X,Y)
ddac : 686578a8              	db	"hex",'('+0x80				; hex(x)
ddb0 : 646563a8              	db	"dec",'('+0x80				; dec(x)
ddb4 : 617363a8              	db	"asc",'('+0x80				; asc(x$)
ddb8 : 76616ca8              	db	"val",'('+0x80				; val(x$)
AS65 Assembler for R6502 [1.42].                                     Page  174
---------------------------------- bank0.s -----------------------------------

ddbc : 706978656ca8          	db	"pixel",'('+0x80			; pixel(x,y)
ddc2 : 737072686974a8        	db	"sprhit",'('+0x80			; sprhit(sp)
ddc9 : 73676ea8              	db	"sgn",'('+0x80				; sgn(x)
ddcd : 61646472a8            	db	"addr",'('+0x80				; addr(var)
                             ; Numeric operators, in priority
ddd2 : aa                    	db	'*'+0x80					; Multiply
ddd3 : af                    	db 	'/'+0x80					; Divide
ddd4 : dc                    	db 	'\\'+0x80					; Modulus
ddd5 : 3cbc                  	db	'<','<'+0x80				; Shift left
ddd7 : 3ebe                  	db	'>','>'+0x80				; Shift right
ddd9 : ab                    	db 	'+'+0x80					; Add
ddda : ad                    	db	'-'+0x80					; Subtract
                             ; Bool and conditional operators, in priority
dddb : a6                    	db '&'+0x80						; AND
dddc : fc                    	db '|'+0x80						; OR
dddd : de                    	db '^'+0x80						; EOR
ddde : 3cbd                  	db "<",'='+0x80					; Less than or equal
dde0 : 3ebd                  	db ">",'='+0x80					; Greater than or equal
dde2 : 3cbe                  	db "<",'>'+0x80					; Not equal
dde4 : bc                    	db '<'+0x80						; Less than
dde5 : be                    	db '>'+0x80						; Greater than
dde6 : 3dbd                  	db "=",'='+0x80					; Equality (always last)
                             
dde8 : 00                    	db  0
                             
                             
                             	
                             	
                             	include "dflat/tkjmptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TKJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; In token order of df_tokensyms
dde9 :                       df_tk_tokenjmp
dde9 : 32df                  	dw	df_tk_assign
ddeb : e9df                  	dw	df_tk_callproc
dded : 3bdf                  	dw	df_tk_comment
ddef : 82df                  	dw	df_tk_println
AS65 Assembler for R6502 [1.42].                                     Page  175
---------------------------------- bank0.s -----------------------------------

ddf1 : 7cdf                  	dw	df_tk_printat
ddf3 : 82df                  	dw	df_tk_print
ddf5 : cddf                  	dw	df_tk_def
ddf7 : 22e0                  	dw	df_tk_enddef
ddf9 : 24e0                  	dw	df_tk_return
ddfb : 22e0                  	dw	df_tk_abort
ddfd : bedf                  	dw	df_tk_local
ddff : afdf                  	dw	df_tk_dim
de01 : 22e0                  	dw	df_tk_repeat
de03 : 27e0                  	dw	df_tk_until
de05 : d2df                  	dw	df_tk_for
de07 : 22e0                  	dw	df_tk_next
de09 : 27e0                  	dw	df_tk_while
de0b : 22e0                  	dw	df_tk_wend
de0d : 27e0                  	dw	df_tk_if
de0f : 22e0                  	dw	df_tk_else
de11 : 22e0                  	dw	df_tk_endif
de13 : 27e0                  	dw	df_tk_elseif
de15 : 89df                  	dw	df_tk_data
de17 : 41f9                  	dw	df_trap_monitor
de19 : 22e0                  	dw	df_tk_run
de1b : 6bdf                  	dw	df_tk_list
de1d : 97df                  	dw	df_tk_input
de1f : 22e0                  	dw	df_tk_text
de21 : 37e0                  	dw	df_tk_plot
de23 : 27e0                  	dw	df_tk_cursor
de25 : 22e0                  	dw	df_tk_cls
de27 : 2de0                  	dw	df_tk_poke
de29 : 2de0                  	dw	df_tk_doke
de2b : 37e0                  	dw	df_tk_sound
de2d : 3fe0                  	dw	df_tk_music
de2f : 3fe0                  	dw	df_tk_play
de31 : a0df                  	dw	df_tk_read
de33 : 22e0                  	dw	df_tk_new
                             ;	dw	df_tk_renum
de35 : 27e0                  	dw	df_tk_wait
de37 : ebdf                  	dw	df_tk_reset
de39 : 22e0                  	dw	df_tk_hires
de3b : 2de0                  	dw	df_tk_point
de3d : 3fe0                  	dw	df_tk_line
de3f : 2de0                  	dw	df_tk_lineto
de41 : 27e0                  	dw	df_tk_pixmode
de43 : 27e0                  	dw	df_tk_ink
de45 : 27e0                  	dw	df_tk_paper
de47 : 37e0                  	dw	df_tk_circle
                             ;	dw	df_tk_himem
de49 : 22e0                  	dw	df_tk_monitor
de4b : 2de0                  	dw	df_tk_sprchar
de4d : 37e0                  	dw	df_tk_sprpos
de4f : 22e0                  	dw	df_tk_sprupd
de51 : 22e0                  	dw	df_tk_sprinit
de53 : 2de0                  	dw	df_tk_sprmulti
                             ;	dw	df_tk_save
                             ;	dw	df_tk_load
de55 : 37e0                  	dw	df_tk_bsave
de57 : 2de0                  	dw	df_tk_bload
de59 : 27e0                  	dw	df_tk_tsave
de5b : 27e0                  	dw	df_tk_tload
de5d : 27e0                  	dw	df_tk_delete
de5f : 22e0                  	dw	df_tk_dir
de61 : afdf                  	dw	df_tk_redim
                             	
AS65 Assembler for R6502 [1.42].                                     Page  176
---------------------------------- bank0.s -----------------------------------

de63 : f5df                  	dw	df_tk_peek
de65 : f5df                  	dw	df_tk_deek
de67 : fadf                  	dw	df_tk_stick
de69 : f5df                  	dw	df_tk_get
de6b : f5df                  	dw	df_tk_chr
de6d : 08e0                  	dw	df_tk_left
de6f : 08e0                  	dw	df_tk_right
de71 : 0ee0                  	dw	df_tk_mid
de73 : f5df                  	dw	df_tk_len
de75 : f5df                  	dw	df_tk_mem
de77 : 08e0                  	dw	df_tk_scrn
de79 : f5df                  	dw	df_tk_rnd
de7b : ffdf                  	dw	df_tk_elapsed
de7d : 14e0                  	dw	df_tk_call
de7f : f5df                  	dw	df_tk_hex
de81 : f5df                  	dw	df_tk_dec
de83 : f5df                  	dw	df_tk_asc
de85 : f5df                  	dw	df_tk_val
de87 : 08e0                  	dw	df_tk_pixel
de89 : f5df                  	dw	df_tk_sprhit
de8b : f5df                  	dw	df_tk_sgn
de8d : ffdf                  	dw	df_tk_addr
                             	
de8f : 22e0                  	dw	df_tk_mult
de91 : 22e0                  	dw	df_tk_div
de93 : 22e0                  	dw	df_tk_mod
de95 : 22e0                  	dw	df_tk_asl
de97 : 22e0                  	dw	df_tk_lsr
de99 : 22e0                  	dw	df_tk_add
de9b : 22e0                  	dw	df_tk_sub
                             	
de9d : 22e0                  	dw	df_tk_and
de9f : 22e0                  	dw	df_tk_or
dea1 : 22e0                  	dw	df_tk_eor
dea3 : 22e0                  	dw	df_tk_lte
dea5 : 22e0                  	dw	df_tk_gte
dea7 : 22e0                  	dw	df_tk_ne
dea9 : 22e0                  	dw	df_tk_lt
deab : 22e0                  	dw	df_tk_gt
dead : 22e0                  	dw	df_tk_eq
                             
                             
                             	
                             	
                             	
                             	
                             	
                             	include "dflat/tktyptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
AS65 Assembler for R6502 [1.42].                                     Page  177
---------------------------------- bank0.s -----------------------------------

                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser type table (is it a keyword, function
                             ; In token order of df_tokensyms
deaf :                       df_tk_tokentype
deaf : 01                    	db	DFTK_KW
deb0 : 01                    	db	DFTK_KW
deb1 : 01                    	db	DFTK_KW
deb2 : 01                    	db	DFTK_KW
deb3 : 01                    	db	DFTK_KW
deb4 : 01                    	db	DFTK_KW
deb5 : 01                    	db	DFTK_KW
deb6 : 01                    	db	DFTK_KW
deb7 : 01                    	db	DFTK_KW
deb8 : 01                    	db	DFTK_KW
deb9 : 01                    	db	DFTK_KW
deba : 01                    	db	DFTK_KW
debb : 01                    	db	DFTK_KW
debc : 01                    	db	DFTK_KW
debd : 01                    	db	DFTK_KW
debe : 01                    	db	DFTK_KW
debf : 01                    	db	DFTK_KW
dec0 : 01                    	db	DFTK_KW
dec1 : 01                    	db	DFTK_KW
dec2 : 01                    	db	DFTK_KW
dec3 : 01                    	db	DFTK_KW
dec4 : 01                    	db	DFTK_KW
dec5 : 01                    	db	DFTK_KW
dec6 : 01                    	db	DFTK_KW
dec7 : 01                    	db	DFTK_KW
dec8 : 01                    	db	DFTK_KW
dec9 : 01                    	db	DFTK_KW
deca : 01                    	db	DFTK_KW
decb : 01                    	db	DFTK_KW
decc : 01                    	db	DFTK_KW
decd : 01                    	db	DFTK_KW
dece : 01                    	db	DFTK_KW
decf : 01                    	db	DFTK_KW
ded0 : 01                    	db	DFTK_KW
ded1 : 01                    	db	DFTK_KW
ded2 : 01                    	db	DFTK_KW
ded3 : 01                    	db	DFTK_KW
ded4 : 01                    	db	DFTK_KW
                             ;	db	DFTK_KW
ded5 : 01                    	db	DFTK_KW
ded6 : 01                    	db	DFTK_KW
ded7 : 01                    	db	DFTK_KW
ded8 : 01                    	db	DFTK_KW
ded9 : 01                    	db	DFTK_KW
deda : 01                    	db	DFTK_KW
dedb : 01                    	db	DFTK_KW
dedc : 01                    	db	DFTK_KW
AS65 Assembler for R6502 [1.42].                                     Page  178
---------------------------------- bank0.s -----------------------------------

dedd : 01                    	db	DFTK_KW
dede : 01                    	db	DFTK_KW
                             ;	db	DFTK_KW
dedf : 01                    	db	DFTK_KW
dee0 : 01                    	db	DFTK_KW
dee1 : 01                    	db	DFTK_KW
dee2 : 01                    	db	DFTK_KW
dee3 : 01                    	db	DFTK_KW
dee4 : 01                    	db	DFTK_KW
                             ;	db	DFTK_KW
                             ;	db	DFTK_KW
dee5 : 01                    	db	DFTK_KW
dee6 : 01                    	db	DFTK_KW
dee7 : 01                    	db	DFTK_KW
dee8 : 01                    	db	DFTK_KW
dee9 : 01                    	db	DFTK_KW
deea : 01                    	db	DFTK_KW
deeb : 01                    	db	DFTK_KW
                             
deec : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
deed : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
deee : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
deef : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
def0 : 42                    	db 	DFTK_FN | DFTK_STR
def1 : 42                    	db 	DFTK_FN | DFTK_STR
def2 : 42                    	db 	DFTK_FN | DFTK_STR
def3 : 42                    	db 	DFTK_FN | DFTK_STR
def4 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
def5 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
def6 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
def7 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
def8 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
def9 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
defa : 42                    	db 	DFTK_FN | DFTK_STR
defb : 42                    	db 	DFTK_FN | DFTK_STR
defc : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
defd : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
defe : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
deff : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
df00 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
df01 : 32                    	db 	DFTK_FN | DFTK_INT | DFTK_BYT
                             	;* Operators add the order of precedence (0=high
df02 : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
df03 : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
df04 : 38                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 0
df05 : 39                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
df06 : 39                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 1
df07 : 3e                    	db 	DFTK_OP | DFTK_STROP | DFTK_INT | DFTK_BYT +
df08 : 3a                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 2
                             
df09 : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
df0a : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
df0b : 3d                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 5
df0c : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
df0d : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
df0e : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
df0f : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
df10 : 3c                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 4
df11 : 3f                    	db 	DFTK_OP | DFTK_INT | DFTK_BYT + 7
                             
                             
                             	
AS65 Assembler for R6502 [1.42].                                     Page  179
---------------------------------- bank0.s -----------------------------------

                             	
                             	
                             	
                             
                             	include "dflat/toksubs.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  TOKSUBS.S
                             ;*  Module that implements the tokenisation of ke
                             ;*  When a line is being parsed, the index of the
                             ;*  found in the symbol table is used to call a r
                             ;*  here.  The job of a routine here is then to f
                             ;*  parse the raw input e.g. a command that takes
                             ;*  parameters, need to do what it needs to ident
                             ;*  Despite the number of keywords in dflat, this
                             ;*  anywhere near the size of rtsubs.s (the runti
                             ;*  equivalent of this) because there is so much 
                             ;*  synactically.
                             ;*  The tokenised output is put in to its own buf
                             ;*  if the whole input was tokenised successfully
                             ;*  dflat will either try and execute (if in imme
                             ;*  mode), or save it to program memory in line n
                             ;*  order.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
df12 :                       mod_sz_toksubs_s
                             
                             ;* General routine to tokenise a mandatory variab
df12 :                       df_tk_variable
df12 : 20c0d8           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
df15 : 205ed8           [ 6] 	jsr df_tk_peek_buf
df18 : 20a7d8           [ 6] 	jsr df_tk_isalpha
df1b : 9013             [ 3] 	bcc df_tk_error
df1d : a900             [ 2] 	lda #0
df1f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Parse assignment preamble
                             ;****************************************
df20 :                       df_tk_preassign
                             	; Put assignment token
                             	; assume its a numeric int for now
df20 : a980             [ 2] 	lda #0x80
df22 : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	
                             	; first find or create a variable
df25 : 2012df           [ 6] 	jsr df_tk_variable
df28 : 209ad9           [ 6] 	jsr df_tk_var
                             	; next char should be '='
df2b : a93d             [ 2] 	lda #'='
df2d : 4cefd8           [ 3] 	jmp df_tk_expect_tok_err
AS65 Assembler for R6502 [1.42].                                     Page  180
---------------------------------- bank0.s -----------------------------------

                             
df30 :                       df_tk_error
                             	SWBRK DFERR_SYNTAX
                             
                             
                             ;****************************************
                             ;* Parse numeric assignment
                             ;****************************************
df32 :                       df_tk_assign
df32 : 2020df           [ 6] 	jsr df_tk_preassign
                             	; tokenise an expression (int or byte)
df35 : 20e1da           [ 6] 	jsr df_tk_expression
df38 : b0f6             [ 3] 	bcs df_tk_error
df3a : 60               [ 6] 	rts
                             
df3b :                       df_tk_comment
                             	; copy all subsequent chars to token
df3b : 2064d8           [ 6] 	jsr df_tk_get_buf
df3e : f006             [ 3] 	beq df_tk_comment_done
df40 : 206fd8           [ 6] 	jsr df_tk_put_tok
df43 : 4c3bdf           [ 3] 	jmp df_tk_comment
df46 :                       df_tk_comment_done
df46 : 18               [ 2] 	clc
df47 : 60               [ 6] 	rts
                             
                             ; Utility to get procedure name with _
df48 :                       df_tk_listp_procname
                             	; try and find the first proc
df48 : a95f             [ 2] 	lda #'_'
df4a : 20e4d8           [ 6] 	jsr df_tk_expect_tok
df4d : b01a             [ 3] 	bcs df_tk_listp_procname_err
                             	; now get first alpha then all alphanum
df4f : 205ed8           [ 6] 	jsr df_tk_peek_buf
df52 : 20a7d8           [ 6] 	jsr df_tk_isalpha
df55 : 9012             [ 3] 	bcc df_tk_listp_procname_err
df57 :                       df_tk_listp_procname_ch
df57 : 205ed8           [ 6] 	jsr df_tk_peek_buf
df5a : 20b4d8           [ 6] 	jsr df_tk_isalphanum
df5d : 9009             [ 3] 	bcc df_tk_listp_procname_ok
df5f : 2064d8           [ 6] 	jsr df_tk_get_buf
df62 : 206fd8           [ 6] 	jsr df_tk_put_tok
df65 : 4c57df           [ 3] 	jmp df_tk_listp_procname_ch
df68 :                       df_tk_listp_procname_ok
df68 : 60               [ 6] 	rts		; C=0
df69 :                       df_tk_listp_procname_err
df69 : 38               [ 2] 	sec
df6a : 60               [ 6] 	rts
                             
                             ; list		: list whole program
                             ; list n	: list line n to end
                             ; list *	: list all procedures
                             ; list _proc: list _proc lines
df6b :                       df_tk_list
df6b : 2048df           [ 6] 	jsr df_tk_listp_procname
df6e : 900b             [ 3] 	bcc df_tk_list_done
                             	; if not found try '*' or normal list
df70 :                       df_tk_list_procs
                             	; first try for list symbol
df70 : a92a             [ 2] 	lda #'*'
df72 : 20e4d8           [ 6] 	jsr df_tk_expect_tok
df75 : 9004             [ 3] 	bcc df_tk_list_done
                             	; else normal line number or nothing
AS65 Assembler for R6502 [1.42].                                     Page  181
---------------------------------- bank0.s -----------------------------------

df77 :                       df_tk_list_line
                             	; tokenise an expression, nothing is ok
df77 : 20e1da           [ 6] 	jsr df_tk_expression
df7a : 18               [ 2] 	clc
df7b :                       df_tk_list_done
df7b : 60               [ 6] 	rts
                             
                             ; printat,print,println can have 0,1 or many expr
df7c :                       df_tk_printat
                             	; Must get 2 parms for x,y
df7c : 202de0           [ 6] 	jsr df_tk_2parms
                             	; try getting more parms
df7f : 4c8edf           [ 3] 	jmp df_tk_expr_more
df82 :                       df_tk_println
df82 :                       df_tk_print
                             	; tokenise an expression ok if null
df82 : 20e1da           [ 6] 	jsr df_tk_expression
df85 : 9007             [ 3] 	bcc df_tk_expr_more
df87 :                       df_tk_print_done
df87 :                       df_tk_data_done
df87 : 18               [ 2] 	clc
df88 : 60               [ 6] 	rts
                             
                             ; these must have 1 or more expressions
df89 :                       df_tk_data
df89 :                       df_tk_asm_db
df89 :                       df_tk_asm_dw
df89 :                       df_tk_next_expr
                             	; tokenise an expression
df89 : 20e1da           [ 6] 	jsr df_tk_expression
df8c : b065             [ 3] 	bcs df_tk_error2
                             ; this loop keeps processing comma seprated exore
df8e :                       df_tk_expr_more
                             	; is there more to come?
df8e : a92c             [ 2] 	lda #','
df90 : 20e4d8           [ 6] 	jsr df_tk_expect_tok
df93 : b0f2             [ 3] 	bcs df_tk_data_done
df95 : 90f2             [ 3] 	bcc df_tk_next_expr
                             
df97 :                       df_tk_input
df97 : 20c0d8           [ 6] 	jsr df_tk_skip_ws
                             	; tokenise a variable
df9a : 2012df           [ 6] 	jsr df_tk_variable
df9d : 4c9ad9           [ 3] 	jmp df_tk_var
                             	
dfa0 :                       df_tk_read
                             	; tokenise a variable
dfa0 : 2012df           [ 6] 	jsr df_tk_variable
dfa3 : 209ad9           [ 6] 	jsr df_tk_var
                             	; if not at the end then keep going
dfa6 : a92c             [ 2] 	lda #','
dfa8 : 20e4d8           [ 6] 	jsr df_tk_expect_tok
dfab : 90f3             [ 3] 	bcc df_tk_read
dfad : 18               [ 2] 	clc
dfae : 60               [ 6] 	rts
                             
dfaf :                       df_tk_dim
dfaf :                       df_tk_redim
                             	; tokenise a variable
dfaf : 2012df           [ 6] 	jsr df_tk_variable
dfb2 : 20e2d9           [ 6] 	jsr df_tk_arrvar
                             	; if not at the end then keep going
AS65 Assembler for R6502 [1.42].                                     Page  182
---------------------------------- bank0.s -----------------------------------

dfb5 : a92c             [ 2] 	lda #','
dfb7 : 20e4d8           [ 6] 	jsr df_tk_expect_tok
dfba : 90f3             [ 3] 	bcc df_tk_dim
dfbc : 18               [ 2] 	clc
dfbd : 60               [ 6] 	rts
                             
dfbe :                       df_tk_local
                             	; tokenise a variable
dfbe : 2012df           [ 6] 	jsr df_tk_variable
dfc1 : 20ccd9           [ 6] 	jsr df_tk_localvar
                             	; if not at the end then keep going
dfc4 : a92c             [ 2] 	lda #','
dfc6 : 20e4d8           [ 6] 	jsr df_tk_expect_tok
dfc9 : 90f3             [ 3] 	bcc df_tk_local
dfcb : 18               [ 2] 	clc
dfcc : 60               [ 6] 	rts
                             
                             ; A = 0 : Def
                             ; A = 1 : Call
dfcd :                       df_tk_def
dfcd : a900             [ 2] 	lda #0
dfcf : 4cedd9           [ 3] 	jmp df_tk_proc
                             
                             ; syntax : for a=1,10,1
dfd2 :                       df_tk_for
dfd2 : 20c0d8           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise the for variable
dfd5 : a901             [ 2] 	lda #DFVVT_INT
dfd7 : 209ad9           [ 6] 	jsr df_tk_var
                             
                             	; always expect '='
                             	; then starting value
dfda : a93d             [ 2] 	lda #'='
dfdc : 20edda           [ 6] 	jsr df_tk_tok_expression
                             	
                             	; always expect ',' separator
                             	; then ending value
dfdf : a92c             [ 2] 	lda #','
dfe1 : 20edda           [ 6] 	jsr df_tk_tok_expression
                             
                             	; always expect ',' separator
                             	; then step value
dfe4 : a92c             [ 2] 	lda #','
dfe6 : 4cedda           [ 3] 	jmp df_tk_tok_expression
                             
                             	
                             ; call to proc should not occur by itself
dfe9 :                       df_tk_callproc
dfe9 : 38               [ 2] 	sec
dfea : 60               [ 6] 	rts
                             
                             ; timer reset expects an int variable only
dfeb :                       df_tk_reset
dfeb : 20c0d8           [ 6] 	jsr df_tk_skip_ws
                             
                             	; tokenise a variable
dfee : a901             [ 2] 	lda #DFVVT_INT
dff0 : 4c9ad9           [ 3] 	jmp df_tk_var
                             
dff3 :                       df_tk_error2
                             	SWBRK DFERR_SYNTAX
AS65 Assembler for R6502 [1.42].                                     Page  183
---------------------------------- bank0.s -----------------------------------

                             
                             
                             ; These functions expect 1 parmeter
dff5 :                       df_tk_len
dff5 :                       df_tk_chr
dff5 :                       df_tk_get
dff5 :                       df_tk_deek
dff5 :                       df_tk_vpeek
dff5 :                       df_tk_peek
dff5 :                       df_tk_mem
dff5 :                       df_tk_rnd
dff5 :                       df_tk_hex
dff5 :                       df_tk_dec
dff5 :                       df_tk_asc
dff5 :                       df_tk_val
dff5 :                       df_tk_sprhit
dff5 :                       df_tk_sgn
dff5 : 20e1da           [ 6] 	jsr df_tk_expression
dff8 : b0f9             [ 3] 	bcs df_tk_error2
dffa :                       df_tk_closebrkt
dffa :                       df_tk_stick				; This function needs no parms
dffa : a929             [ 2] 	lda #')'
dffc : 4cefd8           [ 3] 	jmp df_tk_expect_tok_err
                             
                             ; These function expect a variable only
dfff :                       df_tk_addr
dfff :                       df_tk_elapsed
dfff : 2012df           [ 6] 	jsr df_tk_variable
e002 : 209ad9           [ 6] 	jsr df_tk_var
                             	; must have close braket
e005 : 4cfadf           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 2 parameters
e008 :                       df_tk_left
e008 :                       df_tk_right
e008 :                       df_tk_scrn
e008 :                       df_tk_pixel
e008 : 202de0           [ 6] 	jsr df_tk_2parms
e00b : 4cfadf           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 3 parameters
e00e :                       df_tk_mid
e00e : 2037e0           [ 6] 	jsr df_tk_3parms
e011 : 4cfadf           [ 3] 	jmp df_tk_closebrkt
                             
                             ; These functions expect 4 parameters
e014 :                       df_tk_call
e014 : 202de0           [ 6] 	jsr df_tk_2parms
e017 : a92c             [ 2] 	lda #','
e019 : 20efd8           [ 6] 	jsr df_tk_expect_tok_err
e01c : 202de0           [ 6] 	jsr df_tk_2parms
e01f : 4cfadf           [ 3] 	jmp df_tk_closebrkt
                             
                             ;all these commands require no parameters
e022 :                       df_tk_else
e022 :                       df_tk_endif
e022 :                       df_tk_enddef
e022 :                       df_tk_abort
e022 :                       df_tk_repeat
e022 :                       df_tk_next
e022 :                       df_tk_wend
e022 :                       df_tk_run
AS65 Assembler for R6502 [1.42].                                     Page  184
---------------------------------- bank0.s -----------------------------------

e022 :                       df_tk_cls
e022 :                       df_tk_new
e022 :                       df_tk_mult
e022 :                       df_tk_div
e022 :                       df_tk_mod
e022 :                       df_tk_asl
e022 :                       df_tk_lsr
e022 :                       df_tk_add
e022 :                       df_tk_sub
e022 :                       df_tk_and
e022 :                       df_tk_or
e022 :                       df_tk_eor
e022 :                       df_tk_lte
e022 :                       df_tk_lt
e022 :                       df_tk_gte
e022 :                       df_tk_gt
e022 :                       df_tk_ne
e022 :                       df_tk_eq
e022 :                       df_tk_monitor
e022 :                       df_tk_sprupd
e022 :                       df_tk_sprinit
e022 :                       df_tk_text
e022 :                       df_tk_hires
e022 :                       df_tk_dir
e022 : 18               [ 2] 	clc
e023 : 60               [ 6] 	rts
                             
                             ; 0 or 1 parameter special!
e024 :                       df_tk_return
e024 : 4ce1da           [ 3] 	jmp df_tk_expression
                             
                             
                             ; These commands expect 1 parameter	
e027 :                       df_tk_while
e027 :                       df_tk_until
e027 :                       df_tk_if
e027 :                       df_tk_elseif
e027 :                       df_tk_wait
e027 :                       df_tk_cursor
e027 :                       df_tk_del
e027 :                       df_tk_chdir
e027 :                       df_tk_pixmode
e027 :                       df_tk_ink
e027 :                       df_tk_paper
                             ;df_tk_himem
e027 :                       df_tk_tload
e027 :                       df_tk_tsave
e027 :                       df_tk_delete
e027 :                       df_tk_asm_org
e027 :                       df_tk_asm_opt
e027 :                       df_tk_asm_ds
                             
                             	; first parm
e027 : 20e1da           [ 6] 	jsr df_tk_expression
e02a : b0c7             [ 4] 	bcs df_tk_error2
e02c : 60               [ 6] 	rts
                             
                             ; These commands expect 2 numeric parameters
e02d :                       df_tk_poke
e02d :                       df_tk_doke
e02d :                       df_tk_point
e02d :                       df_tk_sprchar
AS65 Assembler for R6502 [1.42].                                     Page  185
---------------------------------- bank0.s -----------------------------------

e02d :                       df_tk_sprmulti
                             ;df_tk_load
                             ;df_tk_save
e02d :                       df_tk_bload
e02d :                       df_tk_lineto
e02d :                       df_tk_2parms
                             	; first parm
e02d : 20e1da           [ 6] 	jsr df_tk_expression
e030 : b0c1             [ 4] 	bcs df_tk_error2
                             	; tokenise second parm
e032 : a92c             [ 2] 	lda #','
e034 : 4cedda           [ 3] 	jmp df_tk_tok_expression
                             
                             ; these commands expect 3 numeric parameters
e037 :                       df_tk_hchar
e037 :                       df_tk_plot
e037 :                       df_tk_circle
e037 :                       df_tk_sound
e037 :                       df_tk_colour
e037 :                       df_tk_spritepos
                             ;df_tk_renum
e037 :                       df_tk_sprpos
e037 :                       df_tk_bsave
e037 :                       df_tk_3parms
e037 : 202de0           [ 6] 	jsr df_tk_2parms
                             	; tokenise third parm
e03a : a92c             [ 2] 	lda #','
e03c : 4cedda           [ 3] 	jmp df_tk_tok_expression
                             
                             ; these commands expect 4 numeric parameters
e03f :                       df_tk_play
e03f :                       df_tk_music
e03f :                       df_tk_line
e03f :                       df_tk_4parms
e03f : 202de0           [ 6] 	jsr df_tk_2parms
e042 : a92c             [ 2] 	lda #','
e044 : 20efd8           [ 6] 	jsr df_tk_expect_tok_err
e047 : 4c2de0           [ 3] 	jmp df_tk_2parms
                             
                             ;df_tk_fill
                             ;df_tk_5parms
                             ;	jsr df_tk_3parms
                             ;	lda #','
                             ;	jsr df_tk_expect_tok_err
                             ;	jmp df_tk_2parms
                             
e04a :                       mod_sz_toksubs_e
                             
                             
e04a :                       mod_sz_tokenise_e
                             
                             
                             
                             	include "dflat/progedit.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page  186
---------------------------------- bank0.s -----------------------------------

                             ;*  PROGEDIT.S
                             ;*  dflat module to enable editing of a dflat pro
                             ;*  dflat bascially starts here - waiting for use
                             ;*  when a line is entered, if it is not preceede
                             ;*  line number it is tokenised and attempted to 
                             ;*  immediatly.  If it is preceeded by a line num
                             ;*  number is used to save the tokenised line in 
                             ;*  position in memory.
                             ;*  So this is just like a good old editing sessi
                             ;*  nearly any common flavour of 80s basic. Howev
                             ;*  tokenises everything except whitespace and st
                             ;*  constants - even when saving.  Unlike my trus
                             ;*  where I could type in any garbage and it woul
                             ;*  saved with the line number, dflat needs to be
                             ;*  tokenise the line.  So it's actually a bit mo
                             ;*  Atari 8 bit BASIC.
                             ;*
                             ;************************************************
                             
e04a :                       mod_sz_progedit_s
                             
                             ;****************************************
                             ;* df_pg_find_line
                             ;* Find a line number in X(L), A(H)
                             ;* Return X(L), A(H) of line, Y = Length
                             ;* C=1 Exact match not found, C=0 Exact Found
                             ;* If not exact match then next highest line addr
                             ;* Will be in X and A
                             ;****************************************
e04a :                       df_pg_find_line
e04a : 863d             [ 3] 	stx num_a
e04c : 853e             [ 3] 	sta num_a+1
e04e : a566             [ 3] 	lda df_prgstrt
e050 : 8549             [ 3] 	sta num_tmp
e052 : a567             [ 3] 	lda df_prgstrt+1
e054 : 854a             [ 3] 	sta num_tmp+1
e056 :                       df_pg_check_next_line
e056 : a549             [ 3] 	lda num_tmp
e058 : c568             [ 3] 	cmp df_prgend
e05a : d011             [ 3] 	bne df_pg_check_line
e05c : a54a             [ 3] 	lda num_tmp+1
e05e : c569             [ 3] 	cmp df_prgend+1
e060 : d00b             [ 3] 	bne df_pg_check_line
e062 :                       df_pr_line_gt_target	
                             	; End of program or line > target
                             	; X,A = address of finish
                             	; Load Y with the length
e062 : a200             [ 2] 	ldx #0
e064 : a149             [ 6] 	lda (num_tmp,x)
e066 : a8               [ 2] 	tay
e067 : a649             [ 3] 	ldx num_tmp
e069 : a54a             [ 3] 	lda num_tmp+1
e06b : 38               [ 2] 	sec
e06c : 60               [ 6] 	rts
e06d :                       df_pg_check_line
e06d : 38               [ 2] 	sec					; Do a trial subtract of
e06e : a001             [ 2] 	ldy #DFTK_LINNUM	; target - line
e070 : a53d             [ 3] 	lda num_a
e072 : f149             [ 5] 	sbc (num_tmp),y
e074 : 854b             [ 3] 	sta num_tmp+2		; Partial result of sbc
e076 : c8               [ 2] 	iny
e077 : a53e             [ 3] 	lda num_a+1
AS65 Assembler for R6502 [1.42].                                     Page  187
---------------------------------- bank0.s -----------------------------------

e079 : f149             [ 5] 	sbc (num_tmp),y
e07b : 054b             [ 3] 	ora num_tmp+2		; or with partial result for z ch
                             	; If C=0 then line > target (done)
e07d : 90e3             [ 3] 	bcc df_pr_line_gt_target
                             	; If partial result Z=0 then got an exact match
e07f : f00f             [ 3] 	beq df_pr_line_match
                             	; Else we go to next line
e081 : a200             [ 2] 	ldx #0
e083 : 18               [ 2] 	clc
e084 : a549             [ 3] 	lda num_tmp
e086 : 6149             [ 6] 	adc (num_tmp,x)
e088 : 8549             [ 3] 	sta num_tmp
e08a : 90ca             [ 3] 	bcc df_pg_check_next_line
e08c : e64a             [ 5] 	inc num_tmp+1
e08e : d0c6             [ 3] 	bne df_pg_check_next_line	; Always
e090 :                       df_pr_line_match
e090 : a200             [ 2] 	ldx #0
e092 : a149             [ 6] 	lda (num_tmp,x)
e094 : a8               [ 2] 	tay
e095 : a649             [ 3] 	ldx num_tmp
e097 : a54a             [ 3] 	lda num_tmp+1
e099 : 18               [ 2] 	clc
e09a : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* df_pg_insert_block
                             ;* Insert a block at adr (X, A) of size Y
                             ;* df_prgend updated
                             ;* C=1 Error, C=0 Ok
                             ;****************************************
e09b :                       df_pg_insert_block
                             	; Inserting requires a block copy from
                             	; end of program space to the insert address
                             	
                             	; Save address as this is the lowest address
e09b : 863d             [ 3] 	stx num_a
e09d : 853e             [ 3] 	sta num_a+1
                             	; End of program space is the first byte to move
e09f : a568             [ 3] 	lda df_prgend
e0a1 : 8545             [ 3] 	sta num_x
e0a3 : a569             [ 3] 	lda df_prgend+1
e0a5 : 8546             [ 3] 	sta num_x+1	
e0a7 :                       df_pg_insert_byte
                             	; Move a byte from the current top
e0a7 : a200             [ 2] 	ldx #0
e0a9 : a145             [ 6] 	lda (num_x,x)
                             	; To the new top (+Y)
e0ab : 9145             [ 5] 	sta (num_x),y
                             	; Compare current address with lowest
e0ad : a545             [ 3] 	lda num_x
e0af : c53d             [ 3] 	cmp num_a
e0b1 : d012             [ 3] 	bne df_pg_insert_next_byte
e0b3 : a546             [ 3] 	lda num_x+1
e0b5 : c53e             [ 3] 	cmp num_a+1
e0b7 : d00c             [ 3] 	bne df_pg_insert_next_byte
                             	; Finished, update program end pointer
e0b9 : 18               [ 2] 	clc
e0ba : 98               [ 2] 	tya
e0bb : 6568             [ 3] 	adc df_prgend
e0bd : 8568             [ 3] 	sta df_prgend
                             	_bcc 2
                             
AS65 Assembler for R6502 [1.42].                                     Page  188
---------------------------------- bank0.s -----------------------------------

e0c1 : e669             [ 5] 	inc df_prgend+1
e0c3 : 18               [ 2] 	clc
e0c4 : 60               [ 6] 	rts	; C=0
e0c5 :                       df_pg_insert_next_byte
                             	; Decrement current address (trashes A)
                             	_decZPWordA num_x
                             
e0cd : 4ca7e0           [ 3] 	jmp df_pg_insert_byte
                             
                             ;****************************************
                             ;* df_pg_delete_block
                             ;* Delete a block at adr (X, A) of size Y
                             ;* df_prgend updated
                             ;* C=1 Error, C=0 Ok
                             ;****************************************
e0d0 :                       df_pg_delete_block
                             	; Deleting requires a block copy from
                             	; deletion address to end of program
                             	
                             	; Save address as this is the start address
e0d0 : 863d             [ 3] 	stx num_a
e0d2 : 853e             [ 3] 	sta num_a+1
e0d4 : a200             [ 2] 	ldx #0	; No indirect indexing
e0d6 :                       df_pg_delete_byte
                             	; Move a byte from current+Y
e0d6 : b13d             [ 5] 	lda (num_a),y
                             	; Down to current (x=0)
e0d8 : 813d             [ 6] 	sta (num_a,x)
                             	; Compare current address with lowest
e0da : a53d             [ 3] 	lda num_a
e0dc : c568             [ 3] 	cmp df_prgend
e0de : d017             [ 3] 	bne df_pg_delete_next_byte
e0e0 : a53e             [ 3] 	lda num_a+1
e0e2 : c569             [ 3] 	cmp df_prgend+1
e0e4 : d011             [ 3] 	bne df_pg_delete_next_byte
                             	; Finished, update program end pointer
e0e6 : 843d             [ 3] 	sty num_a
e0e8 : 38               [ 2] 	sec
e0e9 : a568             [ 3] 	lda df_prgend
e0eb : e53d             [ 3] 	sbc num_a
e0ed : 8568             [ 3] 	sta df_prgend
e0ef : a569             [ 3] 	lda df_prgend+1
e0f1 : e900             [ 2] 	sbc #0
e0f3 : 8569             [ 3] 	sta df_prgend+1
e0f5 : 18               [ 2] 	clc
e0f6 : 60               [ 6] 	rts
e0f7 :                       df_pg_delete_next_byte
                             	; Increment current address
                             	_incZPWord num_a
                             
e0fd : 4cd6e0           [ 3] 	jmp df_pg_delete_byte
                             
                             
                             ;****************************************
                             ;* Get a line of input
                             ;* Input: C=1 for echo, 0 for no echo
                             ;* Output: C=0 means linbuff is valid
                             ;****************************************
e100 :                       df_pg_inputline
                             	; C is set on input for echo or not
                             	; Read a line of input
e100 : 2045c4           [ 6] 	jsr io_read_line
AS65 Assembler for R6502 [1.42].                                     Page  189
---------------------------------- bank0.s -----------------------------------

                             	
                             	; If nothing entered then sec
e103 : 98               [ 2] 	tya
e104 : d002             [ 3] 	bne df_pg_inputline_ok
e106 : 38               [ 2] 	sec
e107 : 60               [ 6] 	rts
e108 :                       df_pg_inputline_ok
                             	; Copy input bytes to line buffer
                             	; for lexical analysis
e108 :                       df_pg_copyinputtolinbuff
e108 : b139             [ 5] 	lda (buf_lo),y
e10a : 990004           [ 5] 	sta df_linbuff,y
e10d : 88               [ 2] 	dey
e10e : 10f8             [ 3] 	bpl df_pg_copyinputtolinbuff
e110 : 18               [ 2] 	clc
e111 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* df_pg_dflat
                             ;* Start a dflat editing session
                             ;****************************************
e112 :                       df_pg_dflat
                             	; reset stack pointer
e112 : a2ff             [ 2] 	ldx #255
e114 : 9a               [ 2] 	txs
                             
                             	; error handler address
e115 : a9b3             [ 2] 	lda #lo(df_trap_error)
e117 : 8561             [ 3] 	sta df_pc
e119 : a9f8             [ 2] 	lda #hi(df_trap_error)
e11b : 8562             [ 3] 	sta df_pc+1
                             	
                             	; make sure normal I/O is resumed
                             	;jsr io_init_default
e11d : a2b2             [ 2] 	ldx #lo(df_pg_prompt_msg)
e11f : a9e1             [ 2] 	lda #hi(df_pg_prompt_msg)
e121 : 207ec4           [ 6] 	jsr io_print_line
e124 : a900             [ 2] 	lda #0
e126 : 855f             [ 3] 	sta df_immed
e128 :                       df_pg_getcommand
                             	; current line is the token buffer when editing
e128 : a980             [ 2] 	lda #lo(df_tokbuff)
e12a : 8587             [ 3] 	sta df_currlin
e12c : a904             [ 2] 	lda #hi(df_tokbuff)
e12e : 8588             [ 3] 	sta df_currlin+1
e130 : 38               [ 2] 	sec
e131 : 2000e1           [ 6] 	jsr df_pg_inputline
e134 : b0f2             [ 3] 	bcs df_pg_getcommand	;If no input then try again
e136 : 2051e1           [ 6] 	jsr df_pg_tokenise
e139 : a55f             [ 3] 	lda df_immed
e13b : f0eb             [ 3] 	beq df_pg_getcommand
e13d :                       df_pg_runcommand
                             	; clear variables ready to run the statement
e13d : 20b9e1           [ 6] 	jsr df_initrun
                             	; run from tokbuff
e140 : a280             [ 2] 	ldx #lo(df_tokbuff)
e142 : a904             [ 2] 	lda #hi(df_tokbuff)
                             	; always skip length and line number
e144 : a003             [ 2] 	ldy #3
e146 : 8489             [ 3] 	sty df_exeoff
                             	; init currlin
AS65 Assembler for R6502 [1.42].                                     Page  190
---------------------------------- bank0.s -----------------------------------

e148 : 202be5           [ 6] 	jsr df_rt_init_stat_ptr
                             	; start execution
e14b : 203ee5           [ 6] 	jsr df_rt_exec_stat
                             	; Go and get another line of input
e14e : 4c12e1           [ 3] 	jmp df_pg_dflat
                             
                             	; tokenise the line
e151 :                       df_pg_tokenise
e151 : a900             [ 2] 	lda #0
e153 : 855e             [ 3] 	sta errno
e155 : 2025db           [ 6] 	jsr df_lexer_line
                             	; check if line number == 0
e158 : ad8104           [ 4] 	lda df_tokbuff+DFTK_LINNUM
e15b : 0d8204           [ 4] 	ora df_tokbuff+DFTK_LINNUM+1
e15e : d00a             [ 3] 	bne df_pg_line_number
                             	; check if line empty
e160 : ad8004           [ 4] 	lda df_tokbuff
e163 : f004             [ 3] 	beq df_pg_nothing
                             	
                             	; line number == 0 so in immediate mode from tok
                             	; don't zero out the line length as some routine
                             	; run the line in immediate mode
e165 : a901             [ 2] 	lda #1
e167 : 855f             [ 3] 	sta df_immed
e169 :                       df_pg_nothing
e169 : 60               [ 6] 	rts
                             
                             	; put the numbered line in to the right bit of m
e16a :                       df_pg_line_number
                             	; Check if this line exists
e16a : ad8104           [ 4] 	lda df_tokbuff+DFTK_LINNUM
e16d : aa               [ 2] 	tax
e16e : ad8204           [ 4] 	lda df_tokbuff+DFTK_LINNUM+1
e171 : 204ae0           [ 6] 	jsr df_pg_find_line
                             	; Save line address for later X then A
e174 : 8538             [ 3] 	sta tmp_d
e176 : 8a               [ 2] 	txa
e177 : 48               [ 3] 	pha
e178 : a538             [ 3] 	lda tmp_d
e17a : 48               [ 3] 	pha
                             	; If line exists then it needs deleting
e17b : b003             [ 3] 	bcs df_pg_skip_del_line
                             
                             	; delete line from program
e17d : 20d0e0           [ 6] 	jsr df_pg_delete_block
e180 :                       df_pg_skip_del_line
                             	; If line length is zero
                             	; then nothing else to do (i.e. line was deleted
e180 : ad8004           [ 4] 	lda df_tokbuff+DFTK_LINLEN
                             	; save the tokenised line length
e183 : 48               [ 3] 	pha
e184 : d004             [ 3] 	bne df_pg_insertline
                             	; Length was zero, so get temp stuff off stack
e186 : 68               [ 4] 	pla
e187 : 68               [ 4] 	pla
e188 : 68               [ 4] 	pla
e189 : 60               [ 6] 	rts
                             
                             	; insert a program line unless it is immediate
e18a :                       df_pg_insertline
                             	; Restore previously saved length
e18a : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page  191
---------------------------------- bank0.s -----------------------------------

e18b : a8               [ 2] 	tay
                             	; Restore previously saved address to reinsert t
e18c : 68               [ 4] 	pla
e18d : 8538             [ 3] 	sta tmp_d
e18f : 68               [ 4] 	pla
e190 : aa               [ 2] 	tax
e191 : a538             [ 3] 	lda tmp_d
                             	; And save it all back to stack again A,X,Y
                             	_pushAXY
                             
                             	; We now have insert address and length
e19c : 209be0           [ 6] 	jsr df_pg_insert_block
                             	; Restore length and sub 1 to get index in to th
e19f : 68               [ 4] 	pla
e1a0 : a8               [ 2] 	tay
e1a1 : 88               [ 2] 	dey
                             	; Restore address to a pointer, X is pulled firs
e1a2 : 68               [ 4] 	pla
e1a3 : aa               [ 2] 	tax
e1a4 : 863d             [ 3] 	stx num_a
e1a6 : 68               [ 4] 	pla
e1a7 : 853e             [ 3] 	sta num_a+1
                             	; num_a is destination, tokbuff is source, Y is 
e1a9 :                       df_pg_insertlinbyte
e1a9 : b98004           [ 4] 	lda df_tokbuff,y
e1ac : 913d             [ 5] 	sta (num_a),y
e1ae : 88               [ 2] 	dey
e1af : 10f8             [ 3] 	bpl df_pg_insertlinbyte
e1b1 : 60               [ 6] 	rts
                             	
e1b2 :                       df_pg_prompt_msg
e1b2 : 52656164790d00        	db "Ready",UTF_CR,0
                             
e1b9 :                       mod_sz_progedit_e
                             
                             	include "dflat/runtime.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RUNTIME.S
                             ;*  This module is the runtime coordinator.  When
                             ;*  wants to run a program, execution of statemen
                             ;*  required procedure starts and proceeds from t
                             ;*  according to normal program flow.
                             ;*  This module also contains critical routines f
                             ;*  evaluation of expressions (numeric and string
                             ;*  Whilst the code to implement a specific comma
                             ;*  rtsubs.s, this is the key module that control
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
e1b9 :                       mod_sz_runtime_s
                             
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  192
---------------------------------- bank0.s -----------------------------------

                             ;* df_initrun
                             ;* Initialise program space for runtime
                             ;****************************************
e1b9 :                       df_initrun
                             	; Set the key mask to check every 16 instruction
e1b9 : a910             [ 2] 	lda #0x10
e1bb : 855d             [ 3] 	sta df_checkmsk
e1bd : 855c             [ 3] 	sta df_checkkey
                             
                             	; String and array heap initialisation
                             	; Grows up from end of prog space PLUS 1
                             	; Initially empty (dim will allocate)
                             	_cpyZPWord df_prgend,df_starstrt
                             
                             	_incZPWord df_starstrt
                             
                             	_cpyZPWord df_starstrt,df_starend
                             
                             
e1d5 : a2ff             [ 2] 	ldx #0xff
                             	; Reset runtime stack (grows down)
e1d7 : 8677             [ 3] 	stx df_rtstop
                             	; make X=0
e1d9 : e8               [ 2] 	inx
                             	; Reset parameter stack (grows up)
e1da : 8678             [ 3] 	stx df_parmtop
                             	; Reset data pointer high byte
e1dc : 8696             [ 3] 	stx df_currdat+1
                             	; if nest counter zeroed
e1de : 8694             [ 3] 	stx df_ifnest
                             
                             	; clear proc addresses
e1e0 : 20e4e1           [ 6] 	jsr df_rt_init_vvt
                             
                             ;	clc
e1e3 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Initialise vvt
                             ;****************************************
e1e4 :                       df_rt_init_vvt
                             	; starting at beginning of vvt
                             	_cpyZPWord df_vvtend,df_tmpptra
                             
e1ec : a200             [ 2] 	ldx #0
e1ee :                       df_rt_init_vvt_slot
e1ee : a5a2             [ 3] 	lda df_tmpptra
e1f0 : c56e             [ 3] 	cmp df_vvtstrt
e1f2 : d006             [ 3] 	bne df_rt_init_vvt_slot_undim
e1f4 : a5a3             [ 3] 	lda df_tmpptra+1
e1f6 : c56f             [ 3] 	cmp df_vvtstrt+1
e1f8 : f025             [ 4] 	beq df_rt_init_done
e1fa :                       df_rt_init_vvt_slot_undim
                             	; Only zero out proc and array pointers
                             	; Scalar variables are not initialised
e1fa : a000             [ 2] 	ldy #0
e1fc : b1a2             [ 5] 	lda (df_tmpptra),y
e1fe : 29c0             [ 2] 	and #DFVVT_PROC|DFVVT_PTR
e200 : f00f             [ 3] 	beq df_rt_init_vvt_skip
e202 : a204             [ 2] 	ldx #4			; Number of bytes to clear for array
e204 : 2940             [ 2] 	and #DFVVT_PROC	; But if proc, then 3 bytes
e206 : f001             [ 3] 	beq df_rt_init_vvt_skip_proc
AS65 Assembler for R6502 [1.42].                                     Page  193
---------------------------------- bank0.s -----------------------------------

e208 : ca               [ 2] 	dex
e209 :                       df_rt_init_vvt_skip_proc
e209 : 98               [ 2] 	tya				; Set A to 0 (Y already zero)
                             	; skip over the first byte which is variable typ
e20a : c8               [ 2] 	iny
                             	; zero out bytes for proc and arrays
e20b :                       df_rt_init_vvt_z_loop
e20b : 91a2             [ 5] 	sta (df_tmpptra),y
e20d : c8               [ 2] 	iny
e20e : ca               [ 2] 	dex
e20f : d0fa             [ 3] 	bne df_rt_init_vvt_z_loop
e211 :                       df_rt_init_vvt_skip
                             	; increment pointer to next slot
                             	_adcZPByte df_tmpptra,#8
                             
e21c : 4ceee1           [ 3] 	jmp df_rt_init_vvt_slot 	; Don't rely on bcc
e21f :                       df_rt_init_done
e21f : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Evaluate a numeric expression
                             ;* pop  X,A result from operator stack
                             ;****************************************
e220 :                       df_rt_getnval
                             	; evaluate the expression
e220 : 2026e2           [ 6] 	jsr df_rt_neval
                             	; get X,A off operator stack
e223 : 4c9bf7           [ 3] 	jmp df_ost_popInt
                             
                             
                             ;****************************************
                             ;* Evaluate a numeric expression
                             ;* Push result to operator stack
                             ;****************************************
e226 :                       df_rt_neval
                             	; push terminator on cpu stack
                             	; so we know where we are
e226 : a900             [ 2] 	lda #0
e228 : 48               [ 3] 	pha
                             
                             	; find escape token or keyword token
                             	; if escape token push on to operand stack
                             	; if keyword token push on to operator stack
e229 :                       df_rt_neval_optk
e229 : a489             [ 3] 	ldy df_exeoff
                             	; check end of line
                             
                             ;	cpy df_eolidx
                             ;	beq df_rt_neval_process
e22b : c480             [ 3] 	cpy df_nxtstidx
e22d : f03a             [ 3] 	beq df_rt_neval_process
e22f : b187             [ 5] 	lda (df_currlin),y		; Get the byte which could b
e231 : 3024             [ 3] 	bmi df_rt_neval_tk		; N=1 means it's a keyword t
e233 : c920             [ 2] 	cmp #DFTK_ESCVAL		; <=32 means it's an escape to
e235 : 9019             [ 3] 	bcc df_rt_neval_esc
                             	; check for evaluation terminators
                             	; specifically ',' and ']'
e237 : c92c             [ 2] 	cmp #','
e239 : f02e             [ 3] 	beq df_rt_neval_process
e23b : c95d             [ 2] 	cmp #']'
e23d : f02a             [ 3] 	beq df_rt_neval_process
                             	; check for brackets
AS65 Assembler for R6502 [1.42].                                     Page  194
---------------------------------- bank0.s -----------------------------------

                             	; if close bracket then process
e23f : c929             [ 2] 	cmp #')'
e241 : f026             [ 3] 	beq df_rt_neval_process
                             	; Nothing of interest matched or it's open brack
                             	; so move to next byte either way
e243 : e689             [ 5] 	inc df_exeoff				; Next byte 
                             	; if bracket then evaluate expression recursivel
e245 : c928             [ 2] 	cmp #'('
e247 : d0e0             [ 3] 	bne df_rt_neval_optk
                             	; call evaluation function recursively
e249 : 2026e2           [ 6] 	jsr df_rt_neval
                             	; move to next byte
e24c : e689             [ 5] 	inc df_exeoff
e24e : d0d9             [ 3] 	bne df_rt_neval_optk		; ALWAYS as exeoff != 0
e250 :                       df_rt_neval_esc
e250 : 20abe2           [ 6] 	jsr df_rt_eval_esc
                             	; move to next byte
e253 : e689             [ 5] 	inc df_exeoff
e255 : d0d2             [ 3] 	bne df_rt_neval_optk		; ALWAYS as exeoff != 0
                             	; if a token then push on operator stack
e257 :                       df_rt_neval_tk
e257 : 297f             [ 2] 	and #0x7f
                             	; check if op (look up type using X as index)
                             	; X contains the current operator index
                             
e259 : aa               [ 2] 	tax
e25a : bdafde           [ 4] 	lda df_tk_tokentype,x
                             	; A contains token type
e25d : 48               [ 3] 	pha
e25e : 2908             [ 2] 	and #DFTK_OP
e260 : d01c             [ 3] 	bne df_rt_neval_tk_opp
                             	; check if fn
e262 : 68               [ 4] 	pla
e263 : 2902             [ 2] 	and #DFTK_FN
e265 : d00c             [ 3] 	bne df_rt_neval_tk_fn
                             
                             	; If got here then something wrong
                             	SWBRK DFERR_OK
                             
                             
e269 :                       df_rt_neval_process
                             	; pop operator off stack and execute
                             	; keep popping until reached the terminator
e269 : 68               [ 4] 	pla
e26a : f006             [ 3] 	beq df_rt_neval_done
                             	; run the token code
e26c : 209ee5           [ 6] 	jsr df_rt_run_token
                             	; top two bytes on ost stack is the result
e26f : 4c69e2           [ 3] 	jmp df_rt_neval_process
e272 :                       df_rt_neval_done
e272 : 60               [ 6] 	rts
                             
e273 :                       df_rt_neval_tk_fn
e273 : 18               [ 2] 	clc
e274 : 8a               [ 2] 	txa
                             	; run a fn token - returns a value on stack
e275 : e689             [ 5] 	inc df_exeoff
e277 : 209ee5           [ 6] 	jsr df_rt_run_token
                             	; move to next byte
e27a :                       df_rt_neval_nextbyte
e27a : e689             [ 5] 	inc df_exeoff
e27c : d0ab             [ 3] 	bne df_rt_neval_optk		; ALWAYS as exeoff != 0
AS65 Assembler for R6502 [1.42].                                     Page  195
---------------------------------- bank0.s -----------------------------------

                             
e27e :                       df_rt_neval_tk_opp
e27e : 68               [ 4] 	pla				; Get A off stack which is the type
e27f :                       df_rt_neval_tk_op
                             	; X=Op, A=Type
                             	; if this op < current top of op stack
                             	; then do the op as it is higher priority so sho
                             	; not be pushed
                             	; what is top of the op stack?
                             	; save current op token value
                             	; C=0 means process the op now, else don't
                             	; save current operator index
e27f : 86a2             [ 3] 	stx df_tmpptra				; Index in to token table not 
                             	; mask off to keep priority
e281 : 2907             [ 2] 	and #DFTK_OPMSK
e283 : 85a4             [ 3] 	sta df_tmpptrb
                             	; peek top of op stack - pull and push X
e285 : 68               [ 4] 	pla
e286 : 48               [ 3] 	pha
e287 : aa               [ 2] 	tax
                             	; if 0 then nothing so push op
e288 : f01c             [ 3] 	beq df_rt_neval_pushOp
                             	; use it to index in to type table
e28a : bdafde           [ 4] 	lda df_tk_tokentype,x
                             	; mask off to keep priority
e28d : 2907             [ 2] 	and #DFTK_OPMSK
                             	; compare with the saved token type which includ
e28f : c5a4             [ 3] 	cmp df_tmpptrb
                             	; if top of stack >= current then C=1
                             	; else C=0
                             	; what is the state of C?
                             	; if 1 then just pushOp
e291 : f002             [ 3] 	beq df_rt_neval_donow
e293 : b011             [ 3] 	bcs df_rt_neval_pushOp
e295 :                       df_rt_neval_donow
                             	; was C=0 so process now before pushing the new 
                             	; get operator off cpu stack
e295 : 68               [ 4] 	pla
e296 : a8               [ 2] 	tay		; Save whilst need to push other things
                             	; save the current op on cpu stack
e297 : a5a2             [ 3] 	lda df_tmpptra
e299 : 48               [ 3] 	pha
e29a : aa               [ 2] 	tax		; X = current op
e29b : 98               [ 2] 	tya		; Get A back from Y (new op)
                             	; now run the token in A that came off the stack
e29c : 209ee5           [ 6] 	jsr df_rt_run_token
                             	; get current op off cpu stack in to X
e29f : 68               [ 4] 	pla
e2a0 : aa               [ 2] 	tax
                             	; get the token type in to A
e2a1 : bdafde           [ 4] 	lda df_tk_tokentype,x
                             	; now go back around again to check whether to p
e2a4 : d0d9             [ 3] 	bne df_rt_neval_tk_op		; ALWAYS as type never ze
e2a6 :                       df_rt_neval_pushOp
                             	; push the operator
e2a6 : a5a2             [ 3] 	lda df_tmpptra
e2a8 : 48               [ 3] 	pha
                             	; move to next byte
e2a9 : d0cf             [ 3] 	bne df_rt_neval_nextbyte	; ALWAYS as token index
                             
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page  196
---------------------------------- bank0.s -----------------------------------

                             
                             ; jump to escape evaluation routine
e2ab :                       df_rt_eval_esc
e2ab : 0a               [ 2] 	asl a
e2ac : aa               [ 2] 	tax
e2ad : bdbae2           [ 4] 	lda df_rt_eval_esc_tab,x
e2b0 : 85a2             [ 3] 	sta df_tmpptra
e2b2 : bdbbe2           [ 4] 	lda df_rt_eval_esc_tab+1,x
e2b5 : 85a3             [ 3] 	sta df_tmpptra+1
e2b7 : 6ca200           [ 6] 	jmp (df_tmpptra)
                             
e2ba :                       df_rt_eval_esc_tab
e2ba : 77e3                  	dw df_rt_eval_chr
e2bc : 83e3                  	dw df_rt_eval_reserved
e2be : 83e3                  	dw df_rt_eval_reserved
e2c0 : 83e3                  	dw df_rt_eval_reserved
e2c2 : 83e3                  	dw df_rt_eval_reserved
e2c4 : 83e3                  	dw df_rt_eval_reserved	; no such thing as bytdec
e2c6 : 77e3                  	dw df_rt_eval_bythex
e2c8 : 77e3                  	dw df_rt_eval_bytbin
e2ca : 83e3                  	dw df_rt_eval_reserved
e2cc : 77e3                  	dw df_rt_eval_intdec
e2ce : 77e3                  	dw df_rt_eval_inthex
e2d0 : 77e3                  	dw df_rt_eval_intbin
e2d2 : 83e3                  	dw df_rt_eval_reserved
e2d4 : 83e3                  	dw df_rt_eval_reserved
e2d6 : 83e3                  	dw df_rt_eval_reserved
e2d8 : 83e3                  	dw df_rt_eval_reserved
e2da : 85e3                  	dw df_rt_eval_strlit
e2dc : cae3                  	dw df_rt_eval_var
e2de : c0e4                  	dw df_rt_eval_proc
                             
                             
                             ;****************************************
                             ;* Evaluate a string expression
                             ;* X, A = Destination is string accumulator
                             ;****************************************
e2e0 :                       df_rt_seval
e2e0 : a67b             [ 3] 	ldx df_sevalptr
e2e2 : a57c             [ 3] 	lda df_sevalptr+1
                             ;****************************************
                             ;* Evaluate a string expression
                             ;* X, A = Destination buffer / space
                             ;****************************************
e2e4 :                       df_rt_sval
                             	; keep X,A on the stack - will be modified
e2e4 : 8538             [ 3] 	sta tmp_d
e2e6 : 48               [ 3] 	pha
e2e7 : 8a               [ 2] 	txa
e2e8 : 48               [ 3] 	pha
e2e9 : a538             [ 3] 	lda tmp_d
                             	; push original destination
e2eb : 2076f7           [ 6] 	jsr df_ost_pushStr
                             	; Push the destination to the 6502 stack
                             	; hi byte first then lo
                             	; push string idx so we know our starting positi
                             	; in the string buffer
                             	; this limits all evaluations to 255 bytes
                             ;	lda df_stridx
                             ;	jsr df_st_pushOp
                             
                             	; find escape token or keyword token
AS65 Assembler for R6502 [1.42].                                     Page  197
---------------------------------- bank0.s -----------------------------------

                             	; if escape token push on to operand stack
                             	; if keyword operator token push on to operator 
                             	; if keyword function token run it
                             
e2ee :                       df_rt_seval_optk
e2ee : a489             [ 3] 	ldy df_exeoff
                             	; check end of line
                             ;	cpy df_eolidx
                             ;	beq df_rt_seval_done
e2f0 : c480             [ 3] 	cpy df_nxtstidx
e2f2 : f069             [ 4] 	beq df_rt_seval_done
                             
e2f4 : b187             [ 5] 	lda (df_currlin),y
e2f6 : 301c             [ 4] 	bmi df_rt_seval_tk
                             
e2f8 : c920             [ 2] 	cmp #DFTK_ESCVAL
e2fa : 900a             [ 4] 	bcc df_rt_seval_esc
                             	; check for evaluation terminators
                             	; specifically ',' and ')'
e2fc : c92c             [ 2] 	cmp #','
e2fe : f05d             [ 4] 	beq df_rt_seval_done
e300 : c929             [ 2] 	cmp #')'
e302 : f059             [ 3] 	beq df_rt_seval_done
e304 : d04a             [ 3] 	bne df_rt_seval_nextbyte
e306 :                       df_rt_seval_esc
                             	; the only escape char is STRLIT, VAR or PROC
e306 : c910             [ 2] 	cmp #DFTK_STRLIT
e308 : f04b             [ 3] 	beq	df_rt_seval_esc_strlit
e30a : c911             [ 2] 	cmp #DFTK_VAR
e30c : f028             [ 3] 	beq	df_rt_seval_esc_var
e30e : c912             [ 2] 	cmp #DFTK_PROC
e310 : f049             [ 3] 	beq	df_rt_seval_esc_proc
                             
                             	; error if got here
                             	SWBRK DFERR_SYNTAX
                             
                             
                             	; if a token then push on operator stack
e314 :                       df_rt_seval_tk
e314 : 8489             [ 3] 	sty df_exeoff
e316 : 297f             [ 2] 	and #0x7f
                             	; check if op
e318 : aa               [ 2] 	tax
e319 : bdafde           [ 4] 	lda df_tk_tokentype,x
e31c : 2904             [ 2] 	and #DFTK_STROP
e31e : d009             [ 3] 	bne df_rt_seval_tk_op
                             	; check if fn
e320 : bdafde           [ 4] 	lda df_tk_tokentype,x
e323 : 2902             [ 2] 	and #DFTK_FN
e325 : d006             [ 3] 	bne df_rt_seval_tk_fn
                             
                             	; token type mismatch if got here
                             	SWBRK DFERR_TYPEMISM
                             
                             
e329 :                       df_rt_seval_tk_op
                             	; the only op is $+
                             	; so just ignore!
e329 : 8a               [ 2] 	txa
e32a : 4c50e3           [ 3] 	jmp df_rt_seval_nextbyte
                             
e32d :                       df_rt_seval_tk_fn
AS65 Assembler for R6502 [1.42].                                     Page  198
---------------------------------- bank0.s -----------------------------------

e32d : 8a               [ 2] 	txa
e32e : e689             [ 5] 	inc df_exeoff
e330 : 209ee5           [ 6] 	jsr df_rt_run_token
e333 : 4c3ae3           [ 3] 	jmp df_rt_seval_copy
                             
e336 :                       df_rt_seval_esc_var
                             	; go process the variable as a normal RVAL
e336 : 18               [ 2] 	clc
e337 : 20cae3           [ 6] 	jsr df_rt_eval_var
                             	; copy source off rt stack to destination
e33a :                       df_rt_seval_copy
                             	; pull destination pointer
e33a : 68               [ 4] 	pla
e33b : 85a2             [ 3] 	sta df_tmpptra
e33d : 68               [ 4] 	pla
e33e : 85a3             [ 3] 	sta df_tmpptra+1
                             	; pop source string pointer off stack
e340 : 209ff7           [ 6] 	jsr df_ost_popStr
e343 : 86a4             [ 3] 	stx df_tmpptrb
e345 : 85a5             [ 3] 	sta df_tmpptrb+1
                             	; go and copy the string
e347 : 2061e3           [ 6] 	jsr df_rt_copyStr
                             	; now save the destination
e34a : a5a3             [ 3] 	lda df_tmpptra+1
e34c : 48               [ 3] 	pha
e34d : a5a2             [ 3] 	lda df_tmpptra
e34f : 48               [ 3] 	pha
                             
                             ;	jmp df_rt_seval_nextbyte
e350 :                       df_rt_seval_nextbyte
e350 : e689             [ 5] 	inc df_exeoff
e352 : 4ceee2           [ 3] 	jmp df_rt_seval_optk
                             
e355 :                       df_rt_seval_esc_strlit
                             	; evaluate string literal
e355 : 2085e3           [ 6] 	jsr df_rt_eval_strlit
e358 : 4c3ae3           [ 3] 	jmp df_rt_seval_copy
                             
e35b :                       df_rt_seval_esc_proc
                             	; not yet suported *******
                             	SWBRK DFERR_OK
                             
                             
                             	; keep going until non-ws char found or end of l
e35d :                       df_rt_seval_done
                             	;
e35d : 68               [ 4] 	pla
e35e : 68               [ 4] 	pla
                             
e35f : 18               [ 2] 	clc
e360 : 60               [ 6] 	rts
                             
                             
                             ; Copy string from ptrb to ptra
e361 :                       df_rt_copyStr
e361 : a000             [ 2] 	ldy #0
e363 :                       df_rt_copyStr_ch
e363 : b1a4             [ 5] 	lda (df_tmpptrb),y
e365 : 91a2             [ 5] 	sta (df_tmpptra),y
e367 : f003             [ 3] 	beq df_rt_copyStr_done
e369 : c8               [ 2] 	iny
e36a : d0f7             [ 3] 	bne df_rt_copyStr_ch	; Always relying in Y never
AS65 Assembler for R6502 [1.42].                                     Page  199
---------------------------------- bank0.s -----------------------------------

e36c :                       df_rt_copyStr_done
e36c : 98               [ 2] 	tya
e36d : 18               [ 2] 	clc
e36e : 65a2             [ 3] 	adc df_tmpptra
e370 : 85a2             [ 3] 	sta df_tmpptra
                             	_bcc 2
                             
e374 : e6a3             [ 5] 	inc df_tmpptra+1
e376 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Evaluate and push numeric value
                             ;****************************************
e377 :                       df_rt_eval_intdec
e377 :                       df_rt_eval_bytdec
e377 :                       df_rt_eval_inthex
e377 :                       df_rt_eval_bythex
e377 :                       df_rt_eval_intbin
e377 :                       df_rt_eval_bytbin
e377 :                       df_rt_eval_chr
                             	; numeric constant
e377 : c8               [ 2] 	iny
e378 : b187             [ 5] 	lda (df_currlin),y
e37a : aa               [ 2] 	tax
e37b : c8               [ 2] 	iny
e37c : b187             [ 5] 	lda (df_currlin),y
                             	; save offset before calling any routine
e37e : 8489             [ 3] 	sty df_exeoff
                             	; push number on to stack
e380 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
e383 :                       df_rt_eval_reserved
                             	; should not get here
                             	SWBRK DFERR_OK
                             
                             
                             ;****************************************
                             ;* Evaluate and push string constant
                             ;****************************************
e385 :                       df_rt_eval_strlit
e385 : 8489             [ 3] 	sty df_exeoff
                             	; calculate the effective address in to AX
                             	; y + currlin
e387 : 98               [ 2] 	tya
                             	; set carry to add one extra
e388 : 38               [ 2] 	sec
e389 : 6587             [ 3] 	adc df_currlin
e38b : aa               [ 2] 	tax
e38c : a588             [ 3] 	lda df_currlin+1
e38e : 6900             [ 2] 	adc #0
                             
                             	; push string on to stack
e390 : 2076f7           [ 6] 	jsr df_ost_pushStr
                             	; now proceed until end of string found
e393 : a489             [ 3] 	ldy df_exeoff
e395 :                       df_rt_eval_strlit_ch
e395 : b187             [ 5] 	lda (df_currlin),y
e397 : f003             [ 3] 	beq df_rt_eval_strlit_done
e399 : c8               [ 2] 	iny
e39a : d0f9             [ 3] 	bne df_rt_eval_strlit_ch
e39c :                       df_rt_eval_strlit_done	; Always relying on Y neve
e39c : 8489             [ 3] 	sty df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  200
---------------------------------- bank0.s -----------------------------------

e39e : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Return array parameter
                             ;* A has parm
                             ;****************************************
e39f :                       df_rt_arry_parm
                             	; move past open bracket or comma
e39f : e689             [ 5] 	inc df_exeoff
                             	; evaluate expression inside bracket
e3a1 : 2020e2           [ 6] 	jsr df_rt_getnval
e3a4 : 8a               [ 2] 	txa
                             ;	clc
e3a5 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Return double array parameter
                             ;* X = dim1, Y = dim2
                             ;****************************************
e3a6 :                       df_rt_arry_parm2
                             	; go get array parm 1
e3a6 : 209fe3           [ 6] 	jsr df_rt_arry_parm
e3a9 : 48               [ 3] 	pha
e3aa : a200             [ 2] 	ldx #0
e3ac : a489             [ 3] 	ldy df_exeoff
e3ae :                       df_rt_arry_parm2_term
e3ae : b187             [ 5] 	lda (df_currlin),y
e3b0 : c95d             [ 2] 	cmp #']'
e3b2 : f011             [ 3] 	beq df_rt_arry_parm2_skiparry2
e3b4 : c92c             [ 2] 	cmp #','
e3b6 : f006             [ 3] 	beq df_rt_arry_parm2_arry2
e3b8 : 8489             [ 3] 	sty df_exeoff
e3ba : c8               [ 2] 	iny
e3bb : 4caee3           [ 3] 	jmp df_rt_arry_parm2_term
e3be :                       df_rt_arry_parm2_arry2
                             	; get second dimension and put in Y
e3be : 209fe3           [ 6] 	jsr df_rt_arry_parm
e3c1 : a8               [ 2] 	tay
e3c2 : 68               [ 4] 	pla
e3c3 : aa               [ 2] 	tax
                             ;	clc
e3c4 : 60               [ 6] 	rts
e3c5 :                       df_rt_arry_parm2_skiparry2
e3c5 : a000             [ 2] 	ldy #0
e3c7 : 68               [ 4] 	pla
e3c8 : aa               [ 2] 	tax
                             ;	clc
e3c9 : 60               [ 6] 	rts
                             
                             
                             ;****************************************
                             ;* Evaluate and push variable
                             ;* The actual value is pushed if numeric
                             ;* The pointer is pushed if string
                             ;* Carry Set = LVAR else normal RVAR
                             ;* LVAR : Y = line index, A=vvt type, tmpptra = v
                             ;****************************************
e3ca :                       df_rt_eval_var
                             	; save carry bit
e3ca : 08               [ 3] 	php
                             	; if lvar mode then already passed escape token
e3cb : b010             [ 3] 	bcs df_rt_eval_lvskip
AS65 Assembler for R6502 [1.42].                                     Page  201
---------------------------------- bank0.s -----------------------------------

                             	; move past var escape token
e3cd : c8               [ 2] 	iny
                             	; get var vvt address
e3ce : b187             [ 5] 	lda (df_currlin),y
e3d0 : 85a2             [ 3] 	sta df_tmpptra
e3d2 : c8               [ 2] 	iny
e3d3 : 8489             [ 3] 	sty df_exeoff
e3d5 : b187             [ 5] 	lda (df_currlin),y
e3d7 : 85a3             [ 3] 	sta df_tmpptra+1
                             	; push vvt type first as this is the last thing 
e3d9 : a200             [ 2] 	ldx #0
e3db : a1a2             [ 6] 	lda (df_tmpptra,x)
e3dd :                       df_rt_eval_lvskip
e3dd : 48               [ 3] 	pha
                             	; Test A for array or string
e3de : 2984             [ 2] 	and #DFVVT_PTR|DFVVT_STR
                             	; simple variable
e3e0 : f00e             [ 3] 	beq df_rt_eval_var_notarry
                             	; even if an array if no dimensions then return 
                             	; if at end of statement or line then simple cop
e3e2 : c480             [ 3] 	cpy df_nxtstidx
e3e4 : f027             [ 4] 	beq df_rt_eval_var_simple
                             	; if next ch is not [ then simple copy
e3e6 : c8               [ 2] 	iny
e3e7 : b187             [ 5] 	lda (df_currlin),y
e3e9 : 88               [ 2] 	dey
e3ea : c95b             [ 2] 	cmp #'['
e3ec : d01f             [ 4] 	bne df_rt_eval_var_simple
                             	; go do array handling
e3ee : f02d             [ 4] 	beq df_rt_eval_var_do_arry
e3f0 :                       df_rt_eval_var_notarry
                             	; pull the type, not needed here
e3f0 : 68               [ 4] 	pla
                             	; pull C and check if lvar wanted rather than rv
e3f1 : 28               [ 4] 	plp
e3f2 : b00c             [ 4] 	bcs df_rt_eval_lvar
                             	; just push the vvt lo,hi value
e3f4 : a001             [ 2] 	ldy #DFVVT_LO
e3f6 : b1a2             [ 5] 	lda (df_tmpptra),y
e3f8 : aa               [ 2] 	tax
e3f9 : a002             [ 2] 	ldy #DFVVT_HI
e3fb : b1a2             [ 5] 	lda (df_tmpptra),y
                             
e3fd : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
e400 :                       df_rt_eval_lvar
                             	; it's not an array, push the address of DFVVT_L
                             	; add DFVVT_LO offset to slot address in X,A
e400 : 18               [ 2] 	clc
e401 : a901             [ 2] 	lda #DFVVT_LO
e403 : 65a2             [ 3] 	adc df_tmpptra
e405 : aa               [ 2] 	tax
e406 : a5a3             [ 3] 	lda df_tmpptra+1
e408 : 6900             [ 2] 	adc #0
                             
                             	; push pointer to lo,hi
e40a : 4c7af7           [ 3] 	jmp df_ost_pushPtr
                             
                             	; Simple push of pointer, needs to be valid
e40d :                       df_rt_eval_var_simple
                             	; clean up stack
e40d : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page  202
---------------------------------- bank0.s -----------------------------------

e40e : 68               [ 4] 	pla
                             	; simply get lo,hi and push ptr on stack
e40f : a001             [ 2] 	ldy #DFVVT_LO
e411 : b1a2             [ 5] 	lda (df_tmpptra),y
e413 : aa               [ 2] 	tax
e414 : a002             [ 2] 	ldy #DFVVT_HI
e416 : b1a2             [ 5] 	lda (df_tmpptra),y
e418 : f078             [ 3] 	beq df_rt_not_dimed
e41a : 4c7af7           [ 3] 	jmp df_ost_pushPtr
                             
e41d :                       df_rt_eval_var_do_arry
                             	; move past var index
e41d : e689             [ 5] 	inc df_exeoff
                             	; zero out x,y as they have dimension info
e41f : a200             [ 2] 	ldx #0
e421 : a000             [ 2] 	ldy #0
                             
                             	; ** Array handling routine **
                             	; A on stack = type
                             	; save vvt address
e423 : a5a3             [ 3] 	lda df_tmpptra+1
e425 : 48               [ 3] 	pha
e426 : a5a2             [ 3] 	lda df_tmpptra
e428 : 48               [ 3] 	pha
                             
                             	; get array parms in X,Y
e429 : 20a6e3           [ 6] 	jsr df_rt_arry_parm2
                             	; restore vvt address
e42c : 68               [ 4] 	pla
e42d : 85a2             [ 3] 	sta df_tmpptra
e42f : 68               [ 4] 	pla
e430 : 85a3             [ 3] 	sta df_tmpptra+1
                             	; save dimension indices for later
e432 : 86a4             [ 3] 	stx df_tmpptrb
e434 : 84a5             [ 3] 	sty df_tmpptrb+1
                             	; if y is zero then need to decide some stuff
e436 : c000             [ 2] 	cpy #0
e438 : d00e             [ 3] 	bne df_rt_eval_var_dim2adj
                             	; if dim2 > 0 then swap x,y
e43a : a004             [ 2] 	ldy #DFVVT_DIM2
e43c : b1a2             [ 5] 	lda (df_tmpptra),y
e43e : f008             [ 3] 	beq df_rt_eval_var_dim2adj
                             	; swap x,y
e440 : a6a4             [ 3] 	ldx df_tmpptrb
e442 : a4a5             [ 3] 	ldy df_tmpptrb+1
e444 : 86a5             [ 3] 	stx df_tmpptrb+1
e446 : 84a4             [ 3] 	sty df_tmpptrb
                             
e448 :                       df_rt_eval_var_dim2adj
e448 : a6a4             [ 3] 	ldx df_tmpptrb
e44a : a4a5             [ 3] 	ldy df_tmpptrb+1
                             	; don't let y=0
e44c : d001             [ 3] 	bne df_rt_eval_var_dim2adjy
e44e : c8               [ 2] 	iny
e44f :                       df_rt_eval_var_dim2adjy
                             	; don't let x=0
e44f : e000             [ 2] 	cpx #0
e451 : d001             [ 3] 	bne df_rt_eval_var_dim2adjx
e453 : e8               [ 2] 	inx
e454 :                       df_rt_eval_var_dim2adjx
                             	;calculate offset
                             	;(y-1)*dim1 + (x-1)
AS65 Assembler for R6502 [1.42].                                     Page  203
---------------------------------- bank0.s -----------------------------------

e454 : ca               [ 2] 	dex
e455 : a900             [ 2] 	lda #0
e457 : 853e             [ 3] 	sta num_a+1
e459 : 88               [ 2] 	dey
                             	; (y-1)
e45a : 843d             [ 3] 	sty num_a
                             	; if y is 0 then no need to multiply
e45c : f00d             [ 3] 	beq df_rt_eval_var_nomult
                             	; (dim1)
e45e : a003             [ 2] 	ldy #DFVVT_DIM1
e460 : a900             [ 2] 	lda #0
e462 : 8542             [ 3] 	sta num_b+1
e464 : b1a2             [ 5] 	lda (df_tmpptra),y
e466 : 8541             [ 3] 	sta num_b
                             	; (y-1)*dim1 num_a has result
e468 : 201fd6           [ 6] 	jsr int_fast_mult
e46b :                       df_rt_eval_var_nomult
                             	; move x to a
e46b : 8a               [ 2] 	txa
                             	; add x to num_a
e46c : 18               [ 2] 	clc
e46d : 653d             [ 3] 	adc num_a
e46f : 853d             [ 3] 	sta num_a
                             	_bcc 2
                             
e473 : e63e             [ 5] 	inc num_a+1
                             	; now have element offset in num_a
                             	; dimensions in x and y
e475 : a6a4             [ 3] 	ldx df_tmpptrb
e477 : a4a5             [ 3] 	ldy df_tmpptrb+1
                             	; get type of variable originally found
e479 : 68               [ 4] 	pla
e47a : 48               [ 3] 	pha
e47b : 2901             [ 2] 	and #DFVVT_INT
e47d : f004             [ 3] 	beq df_rt_eval_var_push
                             	; if it is int then multiply offset by 2
e47f : 063d             [ 5] 	asl num_a
e481 : 263e             [ 5] 	rol num_a+1
e483 :                       df_rt_eval_var_push
                             	; add pointer in lo,hi to num_a
e483 : 18               [ 2] 	clc
e484 : a001             [ 2] 	ldy #DFVVT_LO
e486 : b1a2             [ 5] 	lda (df_tmpptra),y
e488 : 653d             [ 3] 	adc num_a
e48a : 853d             [ 3] 	sta num_a
e48c : a002             [ 2] 	ldy #DFVVT_HI
e48e : b1a2             [ 5] 	lda (df_tmpptra),y
e490 : d002             [ 3] 	bne df_rt_array_exists
                             	; if vvt address hi is zero then array not dimen
e492 :                       df_rt_not_dimed
                             	SWBRK DFERR_DIM
                             
e494 :                       df_rt_array_exists
e494 : 653e             [ 3] 	adc num_a+1
e496 : 853e             [ 3] 	sta num_a+1
                             	; get the type
e498 : 68               [ 4] 	pla
                             	; if not int or byte then push string
e499 : 2903             [ 2] 	and #DFVVT_INT|DFVVT_BYT
e49b : f01b             [ 3] 	beq df_rt_eval_var_str
                             	; get LVAR preference
e49d : 28               [ 4] 	plp
AS65 Assembler for R6502 [1.42].                                     Page  204
---------------------------------- bank0.s -----------------------------------

e49e : b019             [ 3] 	bcs df_rt_eval_ptr
                             	; need to load lo and hi for int
                             	; but only lo for byt
e4a0 : 2901             [ 2] 	and #DFVVT_INT
e4a2 : f00b             [ 3] 	beq df_rt_eval_byt
                             	; push the contents pointed to by num_a
e4a4 : a000             [ 2] 	ldy #0
e4a6 : b13d             [ 5] 	lda (num_a),y
e4a8 : aa               [ 2] 	tax
e4a9 : c8               [ 2] 	iny
e4aa : b13d             [ 5] 	lda (num_a),y
e4ac : 4c6bf7           [ 3] 	jmp df_ost_pushInt
e4af :                       df_rt_eval_byt
e4af : a000             [ 2] 	ldy #0
e4b1 : b13d             [ 5] 	lda (num_a),y
e4b3 : aa               [ 2] 	tax
e4b4 : 98               [ 2] 	tya			; Make A=0
e4b5 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
e4b8 :                       df_rt_eval_var_str
e4b8 : 28               [ 4] 	plp
e4b9 :                       df_rt_eval_ptr
                             ;	clc
                             	; put num_a not contents
e4b9 : a63d             [ 3] 	ldx num_a
e4bb : a53e             [ 3] 	lda num_a+1
e4bd : 4c7af7           [ 3] 	jmp df_ost_pushPtr
                             
e4c0 :                       df_rt_eval_proc
e4c0 : a578             [ 3] 	lda df_parmtop				; Save current position of par
e4c2 : 48               [ 3] 	pha
e4c3 : 20ccf5           [ 6] 	jsr df_rt_proc				; Go and call the user functio
e4c6 : 68               [ 4] 	pla							; Get back the original parameter stac
e4c7 : c578             [ 3] 	cmp df_parmtop				; if it is the same, then no r
e4c9 : f002             [ 3] 	beq df_rt_eval_proc_err
e4cb : 18               [ 2] 	clc
e4cc : 60               [ 6] 	rts
e4cd :                       df_rt_eval_proc_err
                             	; if no return value then report an errror
                             	SWBRK DFERR_RETURN
                             
                             
                             
                             
                             ;****************************************
                             ;* get two ints off the runtime stack
                             ;* first parm in ptrb, second in ptra
                             ;****************************************
e4cf :                       df_rt_get2Ints
                             	; the first int popped is actually the second pa
e4cf : 209bf7           [ 6] 	jsr df_ost_popInt
e4d2 : 86a4             [ 3] 	stx df_tmpptrb
e4d4 : 85a5             [ 3] 	sta df_tmpptrb+1
                             
e4d6 : 209bf7           [ 6] 	jsr df_ost_popInt
e4d9 : 86a2             [ 3] 	stx df_tmpptra
e4db : 85a3             [ 3] 	sta df_tmpptra+1
e4dd : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* get two strings off the runtime stack
                             ;* first parm in ptrb, second in ptra
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  205
---------------------------------- bank0.s -----------------------------------

e4de :                       df_rt_get2Strs
                             	; the first int popped is actually the second pa
e4de : 209ff7           [ 6] 	jsr df_ost_popStr
e4e1 : 86a4             [ 3] 	stx df_tmpptrb
e4e3 : 85a5             [ 3] 	sta df_tmpptrb+1
                             
e4e5 : 209ff7           [ 6] 	jsr df_ost_popStr
e4e8 : 86a2             [ 3] 	stx df_tmpptra
e4ea : 85a3             [ 3] 	sta df_tmpptra+1
e4ec : 60               [ 6] 	rts
                             
                             ;****************************************
                             ; common code for 2 ints runtime parsing
                             ;****************************************
e4ed :                       df_rt_parm_2ints
                             	; evaluate 1st parm
e4ed : 2026e2           [ 6] 	jsr df_rt_neval
                             	; jump over comma
e4f0 : e689             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
e4f2 : 2026e2           [ 6] 	jsr df_rt_neval
                             	
e4f5 : 4ccfe4           [ 3] 	jmp df_rt_get2Ints
                             	; pop 2nd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             	; pop 1st parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;	rts
                             
                             ;****************************************
                             ; common code for 3 ints runtime parsing
                             ;****************************************
e4f8 :                       df_rt_parm_3ints
                             	; evaluate 1st parm
e4f8 : 2026e2           [ 6] 	jsr df_rt_neval
e4fb : e689             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
e4fd : 2026e2           [ 6] 	jsr df_rt_neval
e500 : e689             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
e502 : 2026e2           [ 6] 	jsr df_rt_neval
                             
                             	; pop 3rd parm
e505 :                       df_rt_parm_pop3
e505 : 209bf7           [ 6] 	jsr df_ost_popInt
e508 : 86a6             [ 3] 	stx df_tmpptrc
e50a : 85a7             [ 3] 	sta df_tmpptrc+1
                             	; pop 2nd and 1st
e50c : 4ccfe4           [ 3] 	jmp df_rt_get2Ints
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             	; pop 1st parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  206
---------------------------------- bank0.s -----------------------------------

                             ;****************************************
                             ; common code for 4 ints runtime parsing
                             ;****************************************
e50f :                       df_rt_parm_4ints
                             	; evaluate 1st parm
e50f : 2026e2           [ 6] 	jsr df_rt_neval
e512 : e689             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
e514 : 2026e2           [ 6] 	jsr df_rt_neval
e517 : e689             [ 5] 	inc df_exeoff
                             	; evaluate the 3rd parm
e519 : 2026e2           [ 6] 	jsr df_rt_neval
e51c : e689             [ 5] 	inc df_exeoff
                             	; evaluate the 4th parm
e51e : 2026e2           [ 6] 	jsr df_rt_neval
                             
                             	; pop 4th parm
e521 : 209bf7           [ 6] 	jsr df_ost_popInt
e524 : 86a8             [ 3] 	stx df_tmpptrd
e526 : 85a9             [ 3] 	sta df_tmpptrd+1
                             
                             	; pop 3,2,1 parms
e528 : 4c05e5           [ 3] 	jmp df_rt_parm_pop3
                             
                             	; pop 3rd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrc
                             ;	sta df_tmpptrc+1
                             	; pop 2nd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             	; pop 1st parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;	rts
                             
                             ;****************************************
                             ; common code for 5 ints runtime parsing
                             ;****************************************
                             ;df_rt_parm_5ints
                             ;	; evaluate 1st parm
                             ;	jsr df_rt_neval
                             ;	inc df_exeoff
                             ;	; evaluate the 2nd parm
                             ;	jsr df_rt_neval
                             ;	inc df_exeoff
                             ;	; evaluate the 3rd parm
                             ;	jsr df_rt_neval
                             ;	inc df_exeoff
                             ;	; evaluate the 4th parm
                             ;	jsr df_rt_neval
                             ;	inc df_exeoff
                             ;	; evaluate the 5th parm
                             ;	jsr df_rt_neval
                             ;
                             ;	; pop 5th parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptre
                             ;	sta df_tmpptre+1
                             ;	; pop 4th parm
AS65 Assembler for R6502 [1.42].                                     Page  207
---------------------------------- bank0.s -----------------------------------

                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrd
                             ;	sta df_tmpptrd+1
                             ;	; pop 3rd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrc
                             ;	sta df_tmpptrc+1
                             ;	; pop 2nd parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptrb
                             ;	sta df_tmpptrb+1
                             ;	; pop 1st parm
                             ;	jsr df_ost_popInt
                             ;	stx df_tmpptra
                             ;	sta df_tmpptra+1
                             ;
                             ;	rts
                             
                             ;****************************************
                             ;* initialise statement to be executed
                             ;* X,A = line pointer, Y=statement offset
                             ;****************************************
e52b :                       df_rt_init_stat_ptr
                             	; save current line
e52b : 8687             [ 3] 	stx df_currlin
e52d : 8588             [ 3] 	sta df_currlin+1
e52f : 8481             [ 3] 	sty df_curstidx
e531 : 8489             [ 3] 	sty df_exeoff
e533 : b187             [ 5] 	lda (df_currlin),y
e535 : 8580             [ 3] 	sta df_nxtstidx
e537 : a200             [ 2] 	ldx #0
e539 : a187             [ 6] 	lda (df_currlin,x)
e53b : 857f             [ 3] 	sta df_eolidx
                             ;	ldy df_curstidx
                             ;	lda (df_currlin),y
                             ;	sta df_nxtstidx
e53d : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Execute from a statement pointed to
                             ;* by currlin and exeoff
                             ;****************************************
e53e :                       df_rt_exec_stat
e53e : a687             [ 3] 	ldx df_currlin
e540 : a588             [ 3] 	lda df_currlin+1
e542 : a489             [ 3] 	ldy df_exeoff
e544 :                       df_rt_exec_init_ptr
e544 : 202be5           [ 6] 	jsr df_rt_init_stat_ptr
                             	; assume normal flow of control if next line hi 
                             	; this means no line can execute below page 1, n
e547 : a900             [ 2] 	lda #0
e549 : 858b             [ 3] 	sta df_nextlin+1
                             
                             	; find first token in statement
e54b :                       df_rt_exec_find_tok
e54b : c8               [ 2] 	iny
e54c : b187             [ 5] 	lda (df_currlin),y
e54e : 10fb             [ 3] 	bpl df_rt_exec_find_tok
e550 :                       df_rt_exec_found_tok
                             	; skip past token to next byte in readiness
e550 : c8               [ 2] 	iny
e551 : 8489             [ 3] 	sty df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  208
---------------------------------- bank0.s -----------------------------------

                             	; Run that statement - if end of return will pul
                             	; and effectively do an rts from this routine.
e553 : 209ee5           [ 6] 	jsr df_rt_run_token
                             
                             	; check for break, asynch get
e556 : c65c             [ 5] 	dec df_checkkey
e558 : d00a             [ 3] 	bne df_rt_exec_no_key
e55a : a55d             [ 3] 	lda df_checkmsk
e55c : 855c             [ 3] 	sta df_checkkey
e55e : 18               [ 2] 	clc
e55f : 202dc4           [ 6] 	jsr io_get_ch
e562 : 9025             [ 3] 	bcc df_rt_exec_check_key
e564 :                       df_rt_exec_no_key
                             	; check if normal flow of control
e564 : a58b             [ 3] 	lda df_nextlin+1
e566 : d02d             [ 3] 	bne df_rt_exec_jump
                             	; try and execute another statement until end of
e568 : a480             [ 3] 	ldy df_nxtstidx
e56a : c47f             [ 3] 	cpy df_eolidx
e56c : 8489             [ 3] 	sty df_exeoff
e56e : d0ce             [ 3] 	bne df_rt_exec_stat
                             	
                             	; reached end of line, move to next
e570 : a200             [ 2] 	ldx #0
e572 : 18               [ 2] 	clc
e573 : a187             [ 6] 	lda (df_currlin,x)
e575 : 6587             [ 3] 	adc df_currlin
e577 : 8587             [ 3] 	sta df_currlin
                             	_bcc 2
                             
e57b : e688             [ 5] 	inc df_currlin+1
                             
                             	; start from first statement in new line
e57d : a003             [ 2] 	ldy #3
e57f : 8489             [ 3] 	sty df_exeoff
                             
                             	; check if this line has any content (length >0)
e581 : a187             [ 6] 	lda (df_currlin,x)
e583 : 857f             [ 3] 	sta df_eolidx
                             	; no more lines (len = 0), program done
e585 : d0b7             [ 3] 	bne df_rt_exec_stat
                             	; else done
                             	; normally wouldn't get here except immediate mo
                             	; if line number <> 0 then error
                             ;	lda df_immed
                             ;	beq df_rt_unexpected_end
e587 :                       df_rt_exec_end
e587 : 18               [ 2] 	clc
e588 : 60               [ 6] 	rts
e589 :                       df_rt_exec_check_key
e589 : c91a             [ 2] 	cmp #UTF_BRK					; CTRK-Z?
e58b : f006             [ 3] 	beq df_rt_exec_ctrl_z
e58d : c903             [ 2] 	cmp #UTF_ETX					; CTRL-C?
e58f : d0d3             [ 3] 	bne df_rt_exec_no_key			; None relevant keys, go
e591 :                       df_rt_exec_ctrl_c
                             	SWBRK DFERR_BREAK
                             
e593 :                       df_rt_exec_ctrl_z
                             	; Force a break with zero error number
                             	; this will drop in to the monitor
                             	SWBRK 0
                             
AS65 Assembler for R6502 [1.42].                                     Page  209
---------------------------------- bank0.s -----------------------------------

                             
                             ;df_rt_unexpected_end
                             ;	SWBRK DFERR_IMMEDIATE
                             
                             	; if hi byte of nextline is not zero then
                             	; current line = next line
e595 :                       df_rt_exec_jump
                             	; initialise statement pointer from nextlin,toks
e595 : a68a             [ 3] 	ldx df_nextlin
e597 : a58b             [ 3] 	lda df_nextlin+1
e599 : a480             [ 3] 	ldy df_nxtstidx
e59b : 4c44e5           [ 3] 	jmp df_rt_exec_init_ptr
                             
                             
                             ;****************************************
                             ;* Run statement in A
                             ;****************************************
e59e :                       df_rt_run_token
                             	; mask off MSB
                             ;	and #0x7f
                             	; multiply by 2
e59e : 0a               [ 2] 	asl a
e59f : aa               [ 2] 	tax
e5a0 : bd89e6           [ 4] 	lda df_rt_tokenjmp,x
e5a3 : 85a2             [ 3] 	sta df_tmpptra
e5a5 : bd8ae6           [ 4] 	lda df_rt_tokenjmp+1,x
e5a8 : 85a3             [ 3] 	sta df_tmpptra+1
                             	; execution code finishes with rts
e5aa : 6ca200           [ 6] 	jmp (df_tmpptra)
                             
                             
                             ;****************************************
                             ;* X,A : Line Address, Y = Index
                             ;* C=0 Found next statement
                             ;* C=1 No statement found
                             ;****************************************
e5ad :                       df_rt_nextstat
                             	; save pointer
e5ad : 8691             [ 3] 	stx df_lineptr
e5af : 8592             [ 3] 	sta df_lineptr+1
                             	; if end of program then err
e5b1 : a200             [ 2] 	ldx #0
e5b3 : a191             [ 6] 	lda (df_lineptr,x)
e5b5 : f022             [ 3] 	beq df_rt_nextstat_err
                             	; if next statement idx == line length
                             ;	lda (df_lineptr),y
                             ;	beq df_rt_nextstat_ln
e5b7 : b191             [ 5] 	lda (df_lineptr),y
e5b9 : c191             [ 6] 	cmp (df_lineptr,x)
e5bb : f007             [ 3] 	beq df_rt_nextstat_ln
                             	; then go to next line
                             	; else make this Y
e5bd : a8               [ 2] 	tay
                             	; X = line low
e5be : a691             [ 3] 	ldx df_lineptr
                             	; A = line high
e5c0 : a592             [ 3] 	lda df_lineptr+1
e5c2 : 18               [ 2] 	clc
e5c3 : 60               [ 6] 	rts
e5c4 :                       df_rt_nextstat_ln
                             	; for next line, add line length to ptr
e5c4 : 18               [ 2] 	clc
AS65 Assembler for R6502 [1.42].                                     Page  210
---------------------------------- bank0.s -----------------------------------

                             ;	lda (df_lineptr,x)
e5c5 : 6591             [ 3] 	adc df_lineptr
e5c7 : 8591             [ 3] 	sta df_lineptr
                             	_bcc 2
                             
e5cb : e692             [ 5] 	inc df_lineptr+1
                             	; if end of program set C as error
e5cd : a191             [ 6] 	lda (df_lineptr,x)
e5cf : f008             [ 3] 	beq df_rt_nextstat_err
e5d1 : a691             [ 3] 	ldx df_lineptr
e5d3 : a592             [ 3] 	lda df_lineptr+1
                             	; always skip line number and length for start o
e5d5 : a003             [ 2] 	ldy #3
e5d7 : 18               [ 2] 	clc
e5d8 : 60               [ 6] 	rts
e5d9 :                       df_rt_nextstat_err
e5d9 : a000             [ 2] 	ldy #0
e5db : 38               [ 2] 	sec
e5dc : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push current line and statement to runtime sta
                             ;****************************************
e5dd :                       df_rt_push_stat
e5dd : a581             [ 3] 	lda df_curstidx
e5df : 2022f7           [ 6] 	jsr df_rst_pushByte
e5e2 : a588             [ 3] 	lda df_currlin+1
e5e4 : a687             [ 3] 	ldx df_currlin
e5e6 : 4c3af7           [ 3] 	jmp df_rst_pushWord
                             ;	clc
                             ;	rts
                             
                             ;****************************************
                             ;* Pop line and statement from runtime stack
                             ;* And transfer control to next statement
                             ;****************************************
e5e9 :                       df_rt_pop_stat
e5e9 : 2048f7           [ 6] 	jsr df_rst_popWord
e5ec : 868a             [ 3] 	stx	df_nextlin
e5ee : 858b             [ 3] 	sta df_nextlin+1
e5f0 : 202bf7           [ 6] 	jsr df_rst_popByte
e5f3 : a8               [ 2] 	tay
e5f4 : a68a             [ 3] 	ldx df_nextlin
e5f6 : a58b             [ 3] 	lda df_nextlin+1
e5f8 : 20ade5           [ 6] 	jsr df_rt_nextstat
e5fb : 868a             [ 3] 	stx df_nextlin
e5fd : 858b             [ 3] 	sta df_nextlin+1
e5ff : 8480             [ 3] 	sty df_nxtstidx
                             ;	clc
e601 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Find proc definition in procptr
                             ;* Only call if proc not found before
                             ;****************************************
e602 :                       df_rt_findproc
                             	; start at program beginning
                             	_cpyZPWord df_prgstrt,df_lineptr
                             
e60a : a003             [ 2] 	ldy #3
e60c : 8493             [ 3] 	sty df_lineidx
e60e : a200             [ 2] 	ldx #0
AS65 Assembler for R6502 [1.42].                                     Page  211
---------------------------------- bank0.s -----------------------------------

e610 : a191             [ 6] 	lda (df_lineptr,x)
e612 : f034             [ 3] 	beq df_rt_findproc_err
e614 :                       df_rt_findproc_cmd
e614 : c8               [ 2] 	iny
e615 : b191             [ 5] 	lda (df_lineptr),y
e617 : 10fb             [ 3] 	bpl df_rt_findproc_cmd
e619 : c986             [ 2] 	cmp #DFRT_DEF
e61b : d017             [ 3] 	bne df_rt_findproc_nextstat
                             	; skip def token
e61d : c8               [ 2] 	iny
                             	; skip proc escape token
e61e : c8               [ 2] 	iny
                             	; now check the proc address against procptr
e61f : b191             [ 5] 	lda (df_lineptr),y
e621 : c58f             [ 3] 	cmp df_procptr
e623 : d00f             [ 3] 	bne df_rt_findproc_nextstat
e625 : c8               [ 2] 	iny
e626 : b191             [ 5] 	lda (df_lineptr),y
e628 : c590             [ 3] 	cmp df_procptr+1
e62a : d008             [ 3] 	bne df_rt_findproc_nextstat
                             
                             	; found it, return AXY with line details
e62c : a691             [ 3] 	ldx df_lineptr
e62e : a592             [ 3] 	lda df_lineptr+1
e630 : a493             [ 3] 	ldy df_lineidx
e632 : 18               [ 2] 	clc
e633 : 60               [ 6] 	rts
e634 :                       df_rt_findproc_nextstat
                             	; restore AXY line details and find next stateme
e634 : a691             [ 3] 	ldx df_lineptr
e636 : a592             [ 3] 	lda df_lineptr+1
e638 : a493             [ 3] 	ldy df_lineidx
e63a : 20ade5           [ 6] 	jsr df_rt_nextstat
e63d : b009             [ 3] 	bcs df_rt_findproc_err
e63f : 8691             [ 3] 	stx df_lineptr
e641 : 8592             [ 3] 	sta df_lineptr+1
e643 : 8493             [ 3] 	sty df_lineidx
e645 : 4c14e6           [ 3] 	jmp df_rt_findproc_cmd
                             	; error
e648 :                       df_rt_findproc_err
                             	SWBRK DFERR_NOPROC
                             
                             
                             ;****************************************
                             ;* Find an escape value
                             ;* Does not check for end of line or statement
                             ;****************************************
e64a :                       df_rt_findescval
e64a : a489             [ 3] 	ldy df_exeoff
e64c : 88               [ 2] 	dey
e64d :                       df_rt_findescval_loop
e64d : c8               [ 2] 	iny
e64e : b187             [ 5] 	lda (df_currlin),y
e650 : c920             [ 2] 	cmp #DFTK_ESCVAL
e652 : b0f9             [ 3] 	bcs df_rt_findescval_loop
e654 : 8489             [ 3] 	sty df_exeoff
e656 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Skip white space
                             ;* Does not check for end of line or statement
                             ;* A contains non-ws char, df_exeoff updated
AS65 Assembler for R6502 [1.42].                                     Page  212
---------------------------------- bank0.s -----------------------------------

                             ;****************************************
e657 :                       df_rt_skip_ws
e657 : a489             [ 3] 	ldy df_exeoff
e659 : 88               [ 2] 	dey
e65a :                       df_rt_skip_ws_loop
e65a : c8               [ 2] 	iny
e65b : b187             [ 5] 	lda (df_currlin),y
e65d : c920             [ 2] 	cmp #' '
e65f : f0f9             [ 3] 	beq df_rt_skip_ws_loop
e661 : 8489             [ 3] 	sty df_exeoff
e663 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Get an lvar
                             ;* Assumes next token will be escape DFTK_VAR
                             ;* tmpptra contains vvt slot address
                             ;* X,A is the lvar pointer
                             ;****************************************
e664 :                       df_rt_getlvar
e664 : 204ae6           [ 6] 	jsr df_rt_findescval
                             	; move past the escape value
e667 : c8               [ 2] 	iny
                             
                             	; get variable address
e668 : b187             [ 5] 	lda (df_currlin),y
e66a : 85a2             [ 3] 	sta df_tmpptra
e66c : c8               [ 2] 	iny
e66d : b187             [ 5] 	lda (df_currlin),y
e66f : 85a3             [ 3] 	sta df_tmpptra+1
                             
e671 : 8489             [ 3] 	sty df_exeoff
                             	; get the type
e673 : a000             [ 2] 	ldy #0
e675 : b1a2             [ 5] 	lda (df_tmpptra),y
                             	; set carry flag to return pointer (lvar)
e677 : 38               [ 2] 	sec
e678 : a489             [ 3] 	ldy df_exeoff
e67a : 20cae3           [ 6] 	jsr df_rt_eval_var
e67d : 4ca3f7           [ 3] 	jmp df_ost_popPtr
                             ;	rts
                             
                             ;****************************************
                             ;* Pop stat from rt stack and continue
                             ;* Y MUST BE ON THE CPU STACK AS IT GETS PLYed HE
                             ;****************************************
e680 :                       df_rt_pop_stat_go
e680 : 20e9e5           [ 6] 	jsr df_rt_pop_stat
                             	; restore stack pointer so we don't lose this en
e683 : 68               [ 4] 	pla
e684 : a8               [ 2] 	tay
e685 : 8477             [ 3] 	sty df_rtstop
e687 : 18               [ 2] 	clc
e688 : 60               [ 6] 	rts
                             
                             	include "dflat/rtjmptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
AS65 Assembler for R6502 [1.42].                                     Page  213
---------------------------------- bank0.s -----------------------------------

                             ;*
                             ;*  RTJUMPTAB.S
                             ;*  Runtime token jump table.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime token an
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; In token order of df_tokensyms
e689 :                       df_rt_tokenjmp
e689 : 69ee                  	dw	df_rt_assign
e68b : ccf5                  	dw	df_rt_proc
e68d : 7aee                  	dw	df_rt_comment
e68f : 21ee                  	dw	df_rt_println
e691 : e6ed                  	dw	df_rt_printat
e693 : f0ed                  	dw	df_rt_print
e695 : 6cf6                  	dw	df_rt_def			; 0x86
e697 : e4f6                  	dw	df_rt_enddef		; 0x87
e699 : e1f6                  	dw	df_rt_return		; 0x88
e69b : 8ef5                  	dw	df_rt_abort			; 0x89
e69d : 44ec                  	dw	df_rt_local
e69f : 73ec                  	dw	df_rt_dim
e6a1 : 12eb                  	dw	df_rt_repeat		; 0x8c
e6a3 : 1aeb                  	dw	df_rt_until
e6a5 : 79ea                  	dw	df_rt_for			; 0x8e
e6a7 : b7ea                  	dw	df_rt_next			; 0x8f
e6a9 : 52e9                  	dw	df_rt_while			; 0x90
e6ab : b5e9                  	dw	df_rt_wend			; 0x81
e6ad : 38ea                  	dw	df_rt_if			; 0x92
e6af : 26ea                  	dw	df_rt_else			; 0x93
e6b1 : 21ea                  	dw	df_rt_endif			; 0x94
e6b3 : 26ea                  	dw	df_rt_elseif		; 0x95
e6b5 : 7aee                  	dw	df_rt_data			; 0x96
e6b7 : 8ffa                  	dw	df_rt_asm_assemble	; 0x97 df_rt_asm_assemble
e6b9 : 7bee                  	dw	df_rt_run
e6bb : 2def                  	dw	df_rt_list
e6bd : 08ec                  	dw	df_rt_input
e6bf : 79ed                  	dw	df_rt_text
e6c1 : 01ed                  	dw	df_rt_plot
e6c3 : 73ed                  	dw	df_rt_cursor
e6c5 : feec                  	dw	df_rt_cls
e6c7 : 7cf1                  	dw	df_rt_poke
e6c9 : 7af1                  	dw	df_rt_doke
e6cb : bef1                  	dw	df_rt_sound
e6cd : c4f1                  	dw	df_rt_music
e6cf : d9f1                  	dw	df_rt_play
e6d1 : f0eb                  	dw	df_rt_read
e6d3 : 4fe9                  	dw	df_rt_new
                             ;	dw	df_rt_renum
e6d5 : d0ed                  	dw	df_rt_wait
AS65 Assembler for R6502 [1.42].                                     Page  214
---------------------------------- bank0.s -----------------------------------

e6d7 : 59f3                  	dw	df_rt_reset
e6d9 : 7ced                  	dw	df_rt_hires
e6db : 95ed                  	dw	df_rt_point
e6dd : bfed                  	dw	df_rt_line
e6df : b1ed                  	dw	df_rt_lineto
e6e1 : 7fed                  	dw	df_rt_pixmode
e6e3 : 85ed                  	dw	df_rt_ink
e6e5 : 8bed                  	dw	df_rt_paper
e6e7 : 9fed                  	dw	df_rt_circle
                             ;	dw	df_rt_himem
e6e9 : 4ce9                  	dw	df_rt_monitor
e6eb : 90f5                  	dw	df_rt_sprchar
e6ed : 9af5                  	dw	df_rt_sprpos
e6ef : a6f5                  	dw	df_rt_sprupd
e6f1 : aff5                  	dw	df_rt_sprinit
e6f3 : b2f5                  	dw	df_rt_sprmulti
                             ;	dw	df_rt_save
                             ;	dw	df_rt_load
e6f5 : fbf2                  	dw	df_rt_bsave
e6f7 : c8f2                  	dw	df_rt_bload
e6f9 : 76f2                  	dw	df_rt_tsave
e6fb : 90f2                  	dw	df_rt_tload
e6fd : 4af2                  	dw	df_rt_delete
e6ff : 57f2                  	dw	df_rt_dir
e701 : 70ec                  	dw	df_rt_redim
                             
e703 : 70f3                  	dw	df_rt_peek
e705 : 6ef3                  	dw	df_rt_deek
e707 : f9f3                  	dw	df_rt_stick
e709 : fff3                  	dw	df_rt_get
e70b : bff4                  	dw	df_rt_chr
e70d : 11f5                  	dw	df_rt_left
e70f : 22f5                  	dw	df_rt_right
e711 : 3df5                  	dw	df_rt_mid
e713 : 5bf5                  	dw	df_rt_len
e715 : abf3                  	dw	df_rt_mem
e717 : 13f4                  	dw	df_rt_scrn
e719 : 89f3                  	dw	df_rt_rnd
e71b : 2df4                  	dw	df_rt_elapsed
e71d : 48f4                  	dw	df_rt_call
e71f : d3f4                  	dw	df_rt_hex
e721 : 04f5                  	dw	df_rt_dec
e723 : 67f5                  	dw	df_rt_asc
e725 : 78f5                  	dw	df_rt_val
e727 : 20f4                  	dw	df_rt_pixel
e729 : b8f5                  	dw	df_rt_sprhit
e72b : 5af4                  	dw	df_rt_sgn
e72d : 77f4                  	dw	df_rt_addr
                             	
e72f : a2e7                  	dw	df_rt_mult
e731 : c3e7                  	dw	df_rt_div
e733 : e4e7                  	dw	df_rt_mod
e735 : 05e8                  	dw	df_rt_asl
e737 : 18e8                  	dw	df_rt_lsr
e739 : 7ce7                  	dw	df_rt_add
e73b : 8fe7                  	dw	df_rt_sub
                             	
e73d : 2be8                  	dw	df_rt_and
e73f : 3ae8                  	dw	df_rt_or
e741 : 49e8                  	dw	df_rt_eor
e743 : e2e8                  	dw	df_rt_comlte
e745 : ebe8                  	dw	df_rt_comgte
AS65 Assembler for R6502 [1.42].                                     Page  215
---------------------------------- bank0.s -----------------------------------

e747 : f4e8                  	dw	df_rt_comne
e749 : c7e8                  	dw	df_rt_comlt
e74b : d0e8                  	dw	df_rt_comgt
e74d : d9e8                  	dw	df_rt_comeq
                             
                             
                             ; escape sequence handlers
                             ; to do the reverse of tokenising during the list
                             ; command which is also used to save to disk.
e74f :                       df_rt_escjmp
e74f : 00f0                  	dw df_rt_lst_chr
e751 : ffef                  	dw df_rt_lst_reserved
e753 : ffef                  	dw df_rt_lst_reserved
e755 : ffef                  	dw df_rt_lst_reserved
e757 : ffef                  	dw df_rt_lst_reserved	
e759 : ffef                  	dw df_rt_lst_reserved	; no such thing as bytdec
e75b : 1df0                  	dw df_rt_lst_bythex
e75d : 42f0                  	dw df_rt_lst_bytbin
e75f : ffef                  	dw df_rt_lst_reserved	
e761 : 66f0                  	dw df_rt_lst_intdec
e763 : 30f0                  	dw df_rt_lst_inthex
e765 : 4af0                  	dw df_rt_lst_intbin
e767 : ffef                  	dw df_rt_lst_reserved
e769 : ffef                  	dw df_rt_lst_reserved
e76b : ffef                  	dw df_rt_lst_reserved
e76d : ffef                  	dw df_rt_lst_reserved	
e76f : c3f0                  	dw df_rt_lst_strlit
e771 : 71f0                  	dw df_rt_lst_var
e773 : 71f0                  	dw df_rt_lst_proc
                             
                             	include "dflat/rtsubs.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTSUBS.S
                             ;*  Module that implements the runtime execution 
                             ;*  keywords and functions.
                             ;*  So this is where most of the action is for ru
                             ;*  a line is being executed, the dflat runtime c
                             ;*  jumps through the runtime table to routines h
                             ;*  Every dflat statement begins with a token (ig
                             ;*  whitespace), even the implicit assignment and
                             ;*  invocation.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
e775 :                       mod_sz_rtsubs_s
                             
                             	include "dflat/numop.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
AS65 Assembler for R6502 [1.42].                                     Page  216
---------------------------------- bank0.s -----------------------------------

                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  NUMOP.S
                             ;*	Dflat number AND string operators.
                             ;*  Uses the operator stack to get parameters, le
                             ;*  result on the operator stack.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; common pushint code
e775 :                       df_rt_putintres
e775 : a6a2             [ 3] 	ldx df_tmpptra
e777 : a5a3             [ 3] 	lda df_tmpptra+1
e779 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
                             ; add two numbers
e77c :                       df_rt_add
e77c : 20cfe4           [ 6] 	jsr df_rt_get2Ints
                             	_addZPWord df_tmpptra,df_tmpptrb
                             
e78c : 4c75e7           [ 3] 	jmp df_rt_putintres
                             	
                             ; subtract
e78f :                       df_rt_sub
e78f : 20cfe4           [ 6] 	jsr df_rt_get2Ints
                             	_subZPWord df_tmpptra,df_tmpptrb
                             
e79f : 4c75e7           [ 3] 	jmp df_rt_putintres
                             
                             ; multiply
e7a2 :                       df_rt_mult
e7a2 : 20cfe4           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
e7b5 : 2048d6           [ 6] 	jsr int_mult
                             	_cpyZPWord num_a,df_tmpptra
                             
e7c0 : 4c75e7           [ 3] 	jmp df_rt_putintres
                             
                             ; divide
e7c3 :                       df_rt_div
e7c3 : 20cfe4           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
                             	_cpyZPWord df_tmpptrb,num_b
                             
e7d6 : 2073d6           [ 6] 	jsr int_div
                             	_cpyZPWord num_a,df_tmpptra
                             
e7e1 : 4c75e7           [ 3] 	jmp df_rt_putintres
                             
                             ; mod
e7e4 :                       df_rt_mod
e7e4 : 20cfe4           [ 6] 	jsr df_rt_get2Ints
                             	_cpyZPWord df_tmpptra,num_a
                             
AS65 Assembler for R6502 [1.42].                                     Page  217
---------------------------------- bank0.s -----------------------------------

                             	_cpyZPWord df_tmpptrb,num_b
                             
e7f7 : 2073d6           [ 6] 	jsr int_div
                             	_cpyZPWord num_x,df_tmpptra
                             
e802 : 4c75e7           [ 3] 	jmp df_rt_putintres
                             
                             ; shift left
e805 :                       df_rt_asl
e805 : 20cfe4           [ 6] 	jsr df_rt_get2Ints
                             	; use low byte only for # of shifts
e808 : a6a4             [ 3] 	ldx df_tmpptrb
e80a : e8               [ 2] 	inx
e80b :                       df_rt_aslbit
e80b : ca               [ 2] 	dex
e80c : f007             [ 3] 	beq df_rt_asldone
e80e : 06a2             [ 5] 	asl df_tmpptra
e810 : 26a3             [ 5] 	rol df_tmpptra+1
e812 : 4c0be8           [ 3] 	jmp df_rt_aslbit
e815 :                       df_rt_asldone
e815 : 4c75e7           [ 3] 	jmp df_rt_putintres
                             
                             ; shift right
e818 :                       df_rt_lsr
e818 : 20cfe4           [ 6] 	jsr df_rt_get2Ints
                             	; use low byte only for # of shifts
e81b : a6a4             [ 3] 	ldx df_tmpptrb
e81d : e8               [ 2] 	inx
e81e :                       df_rt_lsrbit
e81e : ca               [ 2] 	dex
e81f : f007             [ 3] 	beq df_rt_lsrdone
e821 : 46a3             [ 5] 	lsr df_tmpptra+1
e823 : 66a2             [ 5] 	ror df_tmpptra
e825 : 4c1ee8           [ 3] 	jmp df_rt_lsrbit
e828 :                       df_rt_lsrdone
e828 : 4c75e7           [ 3] 	jmp df_rt_putintres
                             
                             ; logical and
e82b :                       df_rt_and
e82b : 20cfe4           [ 6] 	jsr df_rt_get2Ints
e82e : a5a2             [ 3] 	lda df_tmpptra
e830 : 25a4             [ 3] 	and df_tmpptrb
e832 : aa               [ 2] 	tax
e833 : a5a3             [ 3] 	lda df_tmpptra+1
e835 : 25a5             [ 3] 	and df_tmpptrb+1
e837 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             	
                             ; logical or
e83a :                       df_rt_or
e83a : 20cfe4           [ 6] 	jsr df_rt_get2Ints
e83d : a5a2             [ 3] 	lda df_tmpptra
e83f : 05a4             [ 3] 	ora df_tmpptrb
e841 : aa               [ 2] 	tax
e842 : a5a3             [ 3] 	lda df_tmpptra+1
e844 : 05a5             [ 3] 	ora df_tmpptrb+1
e846 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
                             ; logical eor
e849 :                       df_rt_eor
e849 : 20cfe4           [ 6] 	jsr df_rt_get2Ints
e84c : a5a2             [ 3] 	lda df_tmpptra
e84e : 45a4             [ 3] 	eor df_tmpptrb
AS65 Assembler for R6502 [1.42].                                     Page  218
---------------------------------- bank0.s -----------------------------------

e850 : aa               [ 2] 	tax
e851 : a5a3             [ 3] 	lda df_tmpptra+1
e853 : 45a5             [ 3] 	eor df_tmpptrb+1
e855 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
                             ; a==b common function
e858 :                       df_rt_aequb
e858 : a5a2             [ 3] 	lda df_tmpptra
e85a : c5a4             [ 3] 	cmp df_tmpptrb
e85c : d004             [ 3] 	bne df_rt_aequbFin
e85e : a5a3             [ 3] 	lda df_tmpptra+1
e860 : c5a5             [ 3] 	cmp df_tmpptrb+1
e862 :                       df_rt_aequbFin
e862 : 60               [ 6] 	rts
                             
                             ; a-b common function
e863 :                       df_rt_asubb
e863 : 38               [ 2] 	sec
e864 : a5a2             [ 3] 	lda df_tmpptra
e866 : e5a4             [ 3] 	sbc df_tmpptrb
e868 : a5a3             [ 3] 	lda df_tmpptra+1
e86a : e5a5             [ 3] 	sbc df_tmpptrb+1
e86c : 5002             [ 3] 	bvc df_rt_asubbFin
e86e : 4980             [ 2] 	eor #0x80
e870 :                       df_rt_asubbFin
e870 : 60               [ 6] 	rts
                             
                             ; b-a common function
e871 :                       df_rt_bsuba
e871 : 38               [ 2] 	sec
e872 : a5a4             [ 3] 	lda df_tmpptrb
e874 : e5a2             [ 3] 	sbc df_tmpptra
e876 : a5a5             [ 3] 	lda df_tmpptrb+1
e878 : e5a3             [ 3] 	sbc df_tmpptra+1
e87a : 5002             [ 3] 	bvc df_rt_bsubaFin
e87c : 4980             [ 2] 	eor #0x80
e87e :                       df_rt_bsubaFin
e87e : 60               [ 6] 	rts
                             
                             ; common routine push true
e87f :                       df_rt_true
e87f : a2ff             [ 2] 	ldx #0xff
e881 : 8a               [ 2] 	txa
e882 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
                             ; common routine push false
e885 :                       df_rt_false
e885 : a200             [ 2] 	ldx #0x00
e887 : 8a               [ 2] 	txa
e888 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
                             ; a < b == (a-b) < 0
e88b :                       df_rt_lt
e88b : 20cfe4           [ 6] 	jsr df_rt_get2Ints
e88e : 2063e8           [ 6] 	jsr df_rt_asubb
e891 : 30ec             [ 3] 	bmi df_rt_true
e893 : 10f0             [ 3] 	bpl df_rt_false
                             
                             ; a <=b == !(b-a > 0)
e895 :                       df_rt_lte
e895 : 20cfe4           [ 6] 	jsr df_rt_get2Ints
e898 :                       df_rt_lte_calc
AS65 Assembler for R6502 [1.42].                                     Page  219
---------------------------------- bank0.s -----------------------------------

e898 : 2071e8           [ 6] 	jsr df_rt_bsuba
e89b : 30e8             [ 3] 	bmi df_rt_false
e89d : 10e0             [ 3] 	bpl df_rt_true
                             
                             ; a > b == (b-a) < 0
e89f :                       df_rt_gt
e89f : 20cfe4           [ 6] 	jsr df_rt_get2Ints
e8a2 : 2071e8           [ 6] 	jsr df_rt_bsuba
e8a5 : 30d8             [ 3] 	bmi df_rt_true
e8a7 : 10dc             [ 3] 	bpl df_rt_false
                             
                             ; a >= b == (a-b >=0)
e8a9 :                       df_rt_gte
e8a9 : 20cfe4           [ 6] 	jsr df_rt_get2Ints
e8ac :                       df_rt_gte_calc
e8ac : 2063e8           [ 6] 	jsr df_rt_asubb
e8af : 10ce             [ 3] 	bpl df_rt_true
e8b1 : 30d2             [ 3] 	bmi df_rt_false
                             
                             ; a == b
e8b3 :                       df_rt_eq
e8b3 : 20cfe4           [ 6] 	jsr df_rt_get2Ints
e8b6 : 2058e8           [ 6] 	jsr df_rt_aequb
e8b9 : d0ca             [ 3] 	bne df_rt_false
e8bb : f0c2             [ 3] 	beq df_rt_true
                             
                             ; a <> b
e8bd :                       df_rt_ne
e8bd : 20cfe4           [ 6] 	jsr df_rt_get2Ints
e8c0 : 2058e8           [ 6] 	jsr df_rt_aequb
e8c3 : f0c0             [ 3] 	beq df_rt_false
e8c5 : d0b8             [ 3] 	bne df_rt_true
                             
                             ; Common usage of boolean operators for num and s
                             
e8c7 :                       df_rt_comlt
                             	; First find the data type on the stack
e8c7 : 2095f7           [ 6] 	jsr df_ost_peekType
e8ca : 2904             [ 2] 	and #DFST_STR
e8cc : d04a             [ 4] 	bne df_rt_slt
                             	; If not string then assume number
e8ce : f0bb             [ 3] 	beq df_rt_lt
                             
e8d0 :                       df_rt_comgt
                             	; First find the data type on the stack
e8d0 : 2095f7           [ 6] 	jsr df_ost_peekType
e8d3 : 2904             [ 2] 	and #DFST_STR
e8d5 : d048             [ 4] 	bne df_rt_sgt
                             	; If not string then assume number
e8d7 : f0c6             [ 3] 	beq df_rt_gt
                             
e8d9 :                       df_rt_comeq
                             	; First find the data type on the stack
e8d9 : 2095f7           [ 6] 	jsr df_ost_peekType
e8dc : 2904             [ 2] 	and #DFST_STR
e8de : d048             [ 4] 	bne df_rt_seq
                             	; If not string then assume number
e8e0 : f0d1             [ 3] 	beq df_rt_eq
                             
e8e2 :                       df_rt_comlte
                             	; First find the data type on the stack
e8e2 : 2095f7           [ 6] 	jsr df_ost_peekType
AS65 Assembler for R6502 [1.42].                                     Page  220
---------------------------------- bank0.s -----------------------------------

e8e5 : 2904             [ 2] 	and #DFST_STR
e8e7 : d014             [ 3] 	bne df_rt_slte
                             	; If not string then assume number
e8e9 : f0aa             [ 3] 	beq df_rt_lte
                             	
e8eb :                       df_rt_comgte
                             	; First find the data type on the stack
e8eb : 2095f7           [ 6] 	jsr df_ost_peekType
e8ee : 2904             [ 2] 	and #DFST_STR
e8f0 : d018             [ 4] 	bne df_rt_sgte
                             	; If not string then assume number
e8f2 : f0b5             [ 3] 	beq df_rt_gte
                             
e8f4 :                       df_rt_comne
                             	; First find the data type on the stack
e8f4 : 2095f7           [ 6] 	jsr df_ost_peekType
e8f7 : 2904             [ 2] 	and #DFST_STR
e8f9 : d016             [ 4] 	bne df_rt_sne
                             	; If not string then assume number
e8fb : f0c0             [ 3] 	beq df_rt_ne
                             
                             
                             ;********** STRING OPS **********
                             
                             ; string less than or equal
e8fd :                       df_rt_slte
e8fd : 202fe9           [ 6] 	jsr df_rt_str_comp
e900 : 3005             [ 3] 	bmi df_rt_str_comp_true
e902 : f003             [ 3] 	beq df_rt_str_comp_true
e904 :                       df_rt_str_comp_false
e904 : 4c85e8           [ 3] 	jmp df_rt_false
e907 :                       df_rt_str_comp_true
e907 : 4c7fe8           [ 3] 	jmp df_rt_true	
                             
                             ; string greater then or equal	
e90a :                       df_rt_sgte
e90a : 202fe9           [ 6] 	jsr df_rt_str_comp
e90d : 10f8             [ 3] 	bpl df_rt_str_comp_true
e90f : 30f3             [ 3] 	bmi df_rt_str_comp_false
                             
                             ; string not equal
e911 :                       df_rt_sne
e911 : 202fe9           [ 6] 	jsr df_rt_str_comp
e914 : d0f1             [ 3] 	bne df_rt_str_comp_true
e916 : f0ec             [ 3] 	beq df_rt_str_comp_false
                             
                             ; string less than
e918 :                       df_rt_slt
e918 : 202fe9           [ 6] 	jsr df_rt_str_comp
e91b : 30ea             [ 3] 	bmi df_rt_str_comp_true
e91d : 10e5             [ 3] 	bpl df_rt_str_comp_false
                             
                             ; string greater than
e91f :                       df_rt_sgt
e91f : 202fe9           [ 6] 	jsr df_rt_str_comp
e922 : 30e0             [ 3] 	bmi df_rt_str_comp_false
e924 : f0de             [ 3] 	beq df_rt_str_comp_false
e926 : d0df             [ 3] 	bne df_rt_str_comp_true
                             
                             ; string equal
e928 :                       df_rt_seq
e928 : 202fe9           [ 6] 	jsr df_rt_str_comp
AS65 Assembler for R6502 [1.42].                                     Page  221
---------------------------------- bank0.s -----------------------------------

e92b : f0da             [ 3] 	beq df_rt_str_comp_true
e92d : d0d5             [ 3] 	bne df_rt_str_comp_false
                             
                             ; common string comparator
                             ; N=1 means <
                             ; Z=0 means >
                             ; Z=1 means ==
e92f :                       df_rt_str_comp
e92f : 20dee4           [ 6] 	jsr df_rt_get2Strs
e932 : a000             [ 2] 	ldy #0
e934 :                       df_rt_str_comp_byte
e934 : b1a2             [ 5] 	lda (df_tmpptra),y
e936 : aa               [ 2] 	tax							; Save op1 char in X
e937 : d1a4             [ 5] 	cmp (df_tmpptrb),y
                             	; if c=0 then <
e939 : 9008             [ 3] 	bcc df_rt_str_comp_lt
                             	; if c=1 and nz then >
e93b : d009             [ 3] 	bne df_rt_str_comp_gt
                             	; if here then both strings still the same
e93d : 8a               [ 2] 	txa							; What was op1 char
                             	; if char is zero then end
e93e : f009             [ 3] 	beq df_rt_str_comp_eq
                             	; else do next char
e940 : c8               [ 2] 	iny
e941 : d0f1             [ 3] 	bne df_rt_str_comp_byte ; Always - relying on Y 
e943 :                       df_rt_str_comp_lt
e943 : a9ff             [ 2] 	lda #0xff
e945 : 60               [ 6] 	rts
e946 :                       df_rt_str_comp_gt
e946 : a901             [ 2] 	lda #0x01
e948 : 60               [ 6] 	rts
e949 :                       df_rt_str_comp_eq
e949 : a900             [ 2] 	lda #0x00
e94b : 60               [ 6] 	rts
                             
                             
                             
                             
e94c :                       df_rt_monitor
e94c : 4cc3d4           [ 3] 	jmp command_line
                             
e94f :                       df_rt_new
e94f : 4cccf7           [ 3] 	jmp df_clear
                             
e952 :                       df_rt_while
                             	; push statement address
e952 : 20dde5           [ 6] 	jsr df_rt_push_stat
                             	; DFRT_WHILE token
e955 : a990             [ 2] 	lda #DFRT_WHILE
e957 : 2022f7           [ 6] 	jsr df_rst_pushByte
                             
                             	; get value in A,X
e95a : 2020e2           [ 6] 	jsr df_rt_getnval
                             
                             	; if value<>0 then continue
e95d : e000             [ 2] 	cpx #0
e95f : f001             [ 3] 	beq df_rt_while_done
e961 : 60               [ 6] 	rts
e962 :                       df_rt_while_done
                             	; pop while data off stack as not needed
e962 : 2048f7           [ 6] 	jsr df_rst_popWord
e965 : 2048f7           [ 6] 	jsr df_rst_popWord
AS65 Assembler for R6502 [1.42].                                     Page  222
---------------------------------- bank0.s -----------------------------------

                             	; while evaluated false so find wend
                             	; but check for any nested while/wends
                             	; nest = 1 to start
e968 : a594             [ 3] 	lda df_ifnest
e96a : 48               [ 3] 	pha
e96b : a901             [ 2] 	lda #1
e96d : 8594             [ 3] 	sta df_ifnest
                             	; find the matching else/elseif/endif
                             	; start from current statement
                             	_cpyZPWord df_currlin,df_nextlin
                             
e977 :                       df_rt_findwend
e977 : a68a             [ 3] 	ldx df_nextlin
e979 : a58b             [ 3] 	lda df_nextlin+1
e97b : a481             [ 3] 	ldy df_curstidx
e97d : 20ade5           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e980 : b031             [ 3] 	bcs df_rt_wend_end
e982 : 868a             [ 3] 	stx df_nextlin
e984 : 858b             [ 3] 	sta df_nextlin+1
e986 : 8481             [ 3] 	sty df_curstidx
                             	; find the command token
e988 :                       df_rt_while_cmd
e988 : c8               [ 2] 	iny
e989 : b18a             [ 5] 	lda (df_nextlin),y
e98b : 10fb             [ 3] 	bpl df_rt_while_cmd
                             	; check for wend
e98d : c991             [ 2] 	cmp #DFRT_WEND
e98f : d019             [ 3] 	bne df_rt_check_while
                             	; decrement nest
e991 : c694             [ 5] 	dec df_ifnest
                             	; if not zero then go find more commands
e993 : d0e2             [ 3] 	bne df_rt_findwend
                             	; else found it, restore if nest
                             	; and skip the wend statement
e995 : 68               [ 4] 	pla
e996 : 8594             [ 3] 	sta df_ifnest
e998 : a68a             [ 3] 	ldx df_nextlin
e99a : a58b             [ 3] 	lda df_nextlin+1
e99c : a481             [ 3] 	ldy df_curstidx
e99e : 20ade5           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e9a1 : b010             [ 3] 	bcs df_rt_wend_end
                             	; need to update nxtstidx to transfer control
e9a3 : 868a             [ 3] 	stx df_nextlin
e9a5 : 858b             [ 3] 	sta df_nextlin+1
e9a7 : 8480             [ 3] 	sty df_nxtstidx
e9a9 : 60               [ 6] 	rts
e9aa :                       df_rt_check_while
                             	; check for while
e9aa : c990             [ 2] 	cmp #DFRT_WHILE
e9ac : d0c9             [ 3] 	bne df_rt_findwend
                             	; if while found then increment nest
e9ae : e694             [ 5] 	inc df_ifnest
e9b0 : 4c77e9           [ 3] 	jmp df_rt_findwend
e9b3 :                       df_rt_wend_end
                             	SWBRK DFERR_IMMEDIATE
                             
                             
e9b5 :                       df_rt_wend
e9b5 : 202bf7           [ 6] 	jsr df_rst_popByte
e9b8 : c990             [ 2] 	cmp #DFRT_WHILE
AS65 Assembler for R6502 [1.42].                                     Page  223
---------------------------------- bank0.s -----------------------------------

e9ba : d00d             [ 3] 	bne df_rt_wend_err
                             	; pop the stat and continue
e9bc : 2048f7           [ 6] 	jsr df_rst_popWord
e9bf : 868a             [ 3] 	stx	df_nextlin
e9c1 : 858b             [ 3] 	sta df_nextlin+1
e9c3 : 202bf7           [ 6] 	jsr df_rst_popByte
e9c6 : 8580             [ 3] 	sta df_nxtstidx
e9c8 : 60               [ 6] 	rts
e9c9 :                       df_rt_wend_err
                             	SWBRK DFERR_WEND
                             
                             
                             ;move to next statement during if/else matching
                             ;end of program is an error
e9cb :                       df_rt_if_stat
e9cb : a68a             [ 3] 	ldx df_nextlin
e9cd : a58b             [ 3] 	lda df_nextlin+1
e9cf : a481             [ 3] 	ldy df_curstidx
e9d1 : 20ade5           [ 6] 	jsr df_rt_nextstat
                             	; got to end of program, then a problem
e9d4 : b009             [ 3] 	bcs df_rt_if_stat_err
e9d6 : 868a             [ 3] 	stx df_nextlin
e9d8 : 858b             [ 3] 	sta df_nextlin+1
e9da : 8481             [ 3] 	sty df_curstidx
e9dc : 8480             [ 3] 	sty df_nxtstidx
e9de : 60               [ 6] 	rts
                             ; program ended with no match
e9df :                       df_rt_if_stat_err
                             	SWBRK DFERR_UNCLOSEDIF
                             
                             
                             ; find matching else/elseif/endif
                             ; C = 0 match else/elseif/endif
                             ; C = 1 match endif only
                             ; endif is always matched
                             ; ** MAKE SURE NEXTLIN IS POPULATED! **
e9e1 :                       df_rt_if_match
                             	; save the current if nest level
e9e1 : a594             [ 3] 	lda df_ifnest
e9e3 : 48               [ 3] 	pha
                             	; local if nest level is zero to start with
e9e4 : a900             [ 2] 	lda #0
e9e6 : 8594             [ 3] 	sta df_ifnest
                             	; save match pref
e9e8 : 08               [ 3] 	php
                             	; find the matching else/elseif/endif
                             	; start from df_nextlin, df_curstidx
e9e9 :                       df_rt_findelseendif
e9e9 : 20cbe9           [ 6] 	jsr df_rt_if_stat
                             	; find command
e9ec :                       df_rt_ifcmd
e9ec : c8               [ 2] 	iny
e9ed : b18a             [ 5] 	lda (df_nextlin),y
e9ef : 10fb             [ 3] 	bpl df_rt_ifcmd
                             	; check for endif
e9f1 : c994             [ 2] 	cmp #DFRT_ENDIF
e9f3 : f015             [ 4] 	beq df_rt_ifelse
                             
e9f5 : 28               [ 4] 	plp
e9f6 : 08               [ 3] 	php
                             
e9f7 : b008             [ 4] 	bcs df_rt_ifskipelseif
AS65 Assembler for R6502 [1.42].                                     Page  224
---------------------------------- bank0.s -----------------------------------

e9f9 : c993             [ 2] 	cmp #DFRT_ELSE
e9fb : f00d             [ 4] 	beq df_rt_ifelse
e9fd : c995             [ 2] 	cmp #DFRT_ELSEIF
e9ff : f009             [ 4] 	beq df_rt_ifelse
ea01 :                       df_rt_ifskipelseif
                             	; another if token found - increment lcoal if ne
ea01 : c992             [ 2] 	cmp #DFRT_IF
ea03 : d002             [ 3] 	bne df_rt_skipnestif
ea05 : e694             [ 5] 	inc df_ifnest
ea07 :                       df_rt_skipnestif
                             	; no tokens of interest found, so next statement
ea07 : 4ce9e9           [ 3] 	jmp df_rt_findelseendif
                             
                             	; found else/elseif/endif
                             	; but check if this is nested
ea0a :                       df_rt_ifelse
                             	; nest counter zero then found matching else/els
ea0a : a694             [ 3] 	ldx df_ifnest
ea0c : f009             [ 3] 	beq df_rt_if_found
                             	; endif token found so decrement local nest
ea0e : c994             [ 2] 	cmp #DFRT_ENDIF
ea10 : d002             [ 3] 	bne df_rt_skipnestendif
ea12 : c694             [ 5] 	dec df_ifnest
ea14 :                       df_rt_skipnestendif
                             	; continue to search for else/endif
ea14 : 4ce9e9           [ 3] 	jmp df_rt_findelseendif
                             	; ok got a match
ea17 :                       df_rt_if_found
                             	; remove pref
ea17 : 28               [ 4] 	plp
                             	; restore global if nest
ea18 : 8538             [ 3] 	sta tmp_d			; Using as a temp place!
ea1a : 68               [ 4] 	pla					; Get nest from stack
ea1b : aa               [ 2] 	tax					; And put in X
ea1c : a538             [ 3] 	lda tmp_d			; Get a back from temp!
ea1e : 8694             [ 3] 	stx df_ifnest		; Now restore the nest counter
                             
                             	;A contains the token found, Y is index in to df
                             ;	clc
ea20 : 60               [ 6] 	rts
                             
ea21 :                       df_rt_endif
                             	; decrement if next level
ea21 : c694             [ 5] 	dec df_ifnest
ea23 : 3011             [ 3] 	bmi df_rt_noif_err
ea25 :                       df_rt_if_done
ea25 : 60               [ 6] 	rts
                             
                             	; else and ifelse encountered in a normal sequen
                             	; only happens when the clause has been executed
                             	; so we only now need to find the endif
ea26 :                       df_rt_elseif
ea26 :                       df_rt_else
                             	; not in if mode then error
ea26 : a594             [ 3] 	lda df_ifnest
ea28 : f00c             [ 3] 	beq df_rt_noif_err
                             	; find endif only
                             	; starting from current line and curstidx
                             	_cpyZPWord df_currlin,df_nextlin
                             
ea32 : 38               [ 2] 	sec
ea33 : 4ce1e9           [ 3] 	jmp df_rt_if_match
AS65 Assembler for R6502 [1.42].                                     Page  225
---------------------------------- bank0.s -----------------------------------

                             
                             ; endif/else/elseif encountered outside of an if
ea36 :                       df_rt_noif_err
                             	SWBRK DFERR_NOIF
                             
                             
                             	; when if is encountered, the job of this routin
                             	; to determine which clause to execute, then tra
                             	; program control to that point.  in normal prog
                             	; sequence else/elseif statements will signify t
                             	; of an if construct.
ea38 :                       df_rt_if
                             	; increment global if nest counter
ea38 : e694             [ 5] 	inc df_ifnest
ea3a :                       df_rt_ifeval
                             	; get value
ea3a : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; if X,A<>0 if is successful then continue norma
ea3d : a8               [ 2] 	tay
ea3e : d0e5             [ 3] 	bne df_rt_if_done
ea40 : 8a               [ 2] 	txa
ea41 : d0e2             [ 3] 	bne df_rt_if_done
                             	; got here then if clause evaluated to false
                             	; match with else/elseif/endif
                             	; df_nextlin is used to find the clause to execu
                             	_cpyZPWord df_currlin,df_nextlin
                             
ea4b : 18               [ 2] 	clc
ea4c : 20e1e9           [ 6] 	jsr df_rt_if_match
                             	; A contains the token found, Y is index of this
                             
ea4f : c993             [ 2] 	cmp #DFRT_ELSE
                             	; else: df_nextlin and df_nxtstidx points to the
ea51 : f023             [ 3] 	beq df_rt_do_else
                             
ea53 : c994             [ 2] 	cmp #DFRT_ENDIF
                             	; else: df_nextlin and df_nxtstidx points to the
ea55 : f0ce             [ 3] 	beq df_rt_if_done
                             
                             	; elif detected - increment past the token and e
                             	; make this the current line and token index
                             	_cpyZPWord df_nextlin,df_currlin
                             
                             	; move past the token and save position
ea5f : c8               [ 2] 	iny
ea60 : 98               [ 2] 	tya
ea61 : 48               [ 3] 	pha
                             	; initialise statement pointer
ea62 : a481             [ 3] 	ldy df_curstidx
ea64 : a687             [ 3] 	ldx df_currlin
ea66 : a588             [ 3] 	lda df_currlin+1
ea68 : 202be5           [ 6] 	jsr df_rt_init_stat_ptr
                             	; restore Y (one byte past the token) and save i
ea6b : 68               [ 4] 	pla
ea6c : a8               [ 2] 	tay
ea6d : 8489             [ 3] 	sty df_exeoff
                             	; don't force a jump as we've initalised all var
ea6f : a900             [ 2] 	lda #0
ea71 : 858b             [ 3] 	sta df_nextlin+1
                             	; now everyting is set up to evaluate the elif c
ea73 : 4c3aea           [ 3] 	jmp df_rt_ifeval
                             
AS65 Assembler for R6502 [1.42].                                     Page  226
---------------------------------- bank0.s -----------------------------------

ea76 :                       df_rt_do_else
                             	; we need to point to the next statement not thi
ea76 : 4ccbe9           [ 3] 	jmp df_rt_if_stat
                             
ea79 :                       df_rt_for
                             	; push statement address to rt stack
ea79 : 20dde5           [ 6] 	jsr df_rt_push_stat
                             	; get lvar
ea7c : 2064e6           [ 6] 	jsr df_rt_getlvar
                             	; Save lvar pointer, A is fine to trample
ea7f : 48               [ 3] 	pha
ea80 : 8a               [ 2] 	txa
ea81 : 48               [ 3] 	pha
                             
                             	; find starting value
                             	; evaluate the starting value
                             	; can't use df_rt_getnval as need to use A,X fir
ea82 : e689             [ 5] 	inc df_exeoff
ea84 : 2026e2           [ 6] 	jsr df_rt_neval
                             	; get ready to update the counter using pointer
ea87 : 68               [ 4] 	pla
ea88 : aa               [ 2] 	tax
ea89 : 86a2             [ 3] 	stx df_tmpptra
ea8b : 68               [ 4] 	pla
ea8c : 85a3             [ 3] 	sta df_tmpptra+1
                             	; But remember lvar pointer for later A is ok to
ea8e : 48               [ 3] 	pha
ea8f : 8a               [ 2] 	txa
ea90 : 48               [ 3] 	pha
                             
                             	; get the starting value from op stack
ea91 : 209bf7           [ 6] 	jsr df_ost_popInt
                             	; save it to counter slot
ea94 : a001             [ 2] 	ldy #1
ea96 : 91a2             [ 5] 	sta (df_tmpptra),y
ea98 : 8a               [ 2] 	txa
ea99 : 88               [ 2] 	dey
ea9a : 91a2             [ 5] 	sta (df_tmpptra),y
                             
                             	; find end value
                             	; evaluate the end value
ea9c : e689             [ 5] 	inc df_exeoff
ea9e : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; and put on rt stack
eaa1 : 203af7           [ 6] 	jsr df_rst_pushWord
                             
                             	; find step value
                             	; evaluate the end value
eaa4 : e689             [ 5] 	inc df_exeoff
eaa6 : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; and push on rt stack
eaa9 : 203af7           [ 6] 	jsr df_rst_pushWord
                             	; save the counter lvar pointer
eaac : 68               [ 4] 	pla
eaad : aa               [ 2] 	tax
eaae : 68               [ 4] 	pla
eaaf : 203af7           [ 6] 	jsr df_rst_pushWord
                             	; all done - counter set to start
                             	; stack contains counter slot, step val, end val
                             	; now push for token
eab2 : a98e             [ 2] 	lda #DFRT_FOR
eab4 : 4c22f7           [ 3] 	jmp df_rst_pushByte
AS65 Assembler for R6502 [1.42].                                     Page  227
---------------------------------- bank0.s -----------------------------------

                             
eab7 :                       df_rt_next
                             	; remember stack position
eab7 : a477             [ 3] 	ldy df_rtstop
eab9 : 98               [ 2] 	tya
eaba : 48               [ 3] 	pha
eabb : 202bf7           [ 6] 	jsr df_rst_popByte
eabe : c98e             [ 2] 	cmp #DFRT_FOR
eac0 : d04e             [ 4] 	bne df_rt_next_err
                             	; get the slot address
eac2 : 2048f7           [ 6] 	jsr df_rst_popWord
                             	; save address to ptrd, contents to ptra
eac5 : 86a8             [ 3] 	stx df_tmpptrd
eac7 : 85a9             [ 3] 	sta df_tmpptrd+1
eac9 : a000             [ 2] 	ldy #0
eacb : b1a8             [ 5] 	lda (df_tmpptrd),y
eacd : 85a2             [ 3] 	sta df_tmpptra
eacf : c8               [ 2] 	iny
ead0 : b1a8             [ 5] 	lda (df_tmpptrd),y
ead2 : 85a3             [ 3] 	sta df_tmpptra+1
                             
                             	; get step value, save in ptrb
ead4 : 2048f7           [ 6] 	jsr df_rst_popWord
ead7 : 86a4             [ 3] 	stx df_tmpptrb
ead9 : 85a5             [ 3] 	sta df_tmpptrb+1
eadb : 48               [ 3] 	pha					; Push A to check for -ve step
                             
                             	; add step to counter and save back to counter
                             	_addZPWord df_tmpptra,df_tmpptrb
                             
eae9 : a5a2             [ 3] 	lda df_tmpptra
eaeb : a000             [ 2] 	ldy #0
eaed : 91a8             [ 5] 	sta (df_tmpptrd),y
eaef : a5a3             [ 3] 	lda df_tmpptra+1
eaf1 : c8               [ 2] 	iny
eaf2 : 91a8             [ 5] 	sta (df_tmpptrd),y
                             
                             	; get end value, save in ptrb
eaf4 : 2048f7           [ 6] 	jsr df_rst_popWord
eaf7 : 86a4             [ 3] 	stx df_tmpptrb
eaf9 : 85a5             [ 3] 	sta df_tmpptrb+1
eafb : 68               [ 4] 	pla					; check if if +ve or -ve step
eafc : 1006             [ 4] 	bpl df_rt_check_pos
                             	; call gte operation but no need to get ints
                             	; as already in ptra and ptrb
eafe : 20ace8           [ 6] 	jsr df_rt_gte_calc
eb01 : 4c07eb           [ 3] 	jmp df_rt_next_check
eb04 :                       df_rt_check_pos
                             	; call lte operation but no need to get ints
                             	; as already in ptra and ptrb
eb04 : 2098e8           [ 6] 	jsr df_rt_lte_calc
eb07 :                       df_rt_next_check
                             	; check if true or false
eb07 : 209bf7           [ 6] 	jsr df_ost_popInt
eb0a : 8a               [ 2] 	txa
                             	; if false then next is done
eb0b : f020             [ 3] 	beq df_rt_untilnext_done
                             	; else we continue
eb0d : 4c80e6           [ 3] 	jmp df_rt_pop_stat_go
                             
eb10 :                       df_rt_next_err
                             	SWBRK DFERR_NEXTFOR
AS65 Assembler for R6502 [1.42].                                     Page  228
---------------------------------- bank0.s -----------------------------------

                             
                             
                             
eb12 :                       df_rt_repeat
                             	; push statement address
eb12 : 20dde5           [ 6] 	jsr df_rt_push_stat
                             	; DFRT_REPEAT token
eb15 : a98c             [ 2] 	lda #DFRT_REPEAT
eb17 : 4c22f7           [ 3] 	jmp df_rst_pushByte
                             
eb1a :                       df_rt_until
                             	; remember stack position
eb1a : a577             [ 3] 	lda df_rtstop
eb1c : 48               [ 3] 	pha
eb1d : 202bf7           [ 6] 	jsr df_rst_popByte
eb20 : c98c             [ 2] 	cmp #DFRT_REPEAT
eb22 : d011             [ 3] 	bne df_rt_until_err
                             	; evaluate expression in to A,X
eb24 : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; if value<>0 then continue
eb27 : 8a               [ 2] 	txa
eb28 : d003             [ 3] 	bne df_rt_untilnext_done
                             
                             	; pop the stat and continue
eb2a : 4c80e6           [ 3] 	jmp df_rt_pop_stat_go
                             
eb2d :                       df_rt_untilnext_done
eb2d : 68               [ 4] 	pla
eb2e : a8               [ 2] 	tay
                             	; pop 2 items off stack (line address, index)
                             	; and continue
eb2f : 2048f7           [ 6] 	jsr df_rst_popWord
eb32 : 4c2bf7           [ 3] 	jmp df_rst_popByte
                             
eb35 :                       df_rt_until_err
                             	SWBRK DFERR_UNTIL
                             
                             
eb37 :                       df_rt_sadd
eb37 : 60               [ 6] 	rts
                             
eb38 :                       df_rt_print_num
eb38 : 209bf7           [ 6] 	jsr df_ost_popInt
eb3b : 18               [ 2] 	clc
eb3c : 4ce8c3           [ 3] 	jmp print_a_to_d
                             
eb3f :                       df_rt_print_str
eb3f : 209ff7           [ 6] 	jsr df_ost_popStr
eb42 : 86a2             [ 3] 	stx df_tmpptra
eb44 : 85a3             [ 3] 	sta df_tmpptra+1
eb46 : a000             [ 2] 	ldy #0
eb48 :                       df_rt_print_str_ch
eb48 : b1a2             [ 5] 	lda (df_tmpptra),y
eb4a : f006             [ 3] 	beq df_rt_print_str_done
eb4c : 2030c4           [ 6] 	jsr io_put_ch
eb4f : c8               [ 2] 	iny
eb50 : d0f6             [ 3] 	bne df_rt_print_str_ch		; Rely on y not wrapping
eb52 :                       df_rt_print_str_done
eb52 : 60               [ 6] 	rts
                             
                             ; * Find the position of the next data item to re
eb53 :                       df_rt_nextdatum
AS65 Assembler for R6502 [1.42].                                     Page  229
---------------------------------- bank0.s -----------------------------------

eb53 : a200             [ 2] 	ldx #0
                             	; load data line offset
eb55 : a497             [ 3] 	ldy df_datoff
                             	; if data pointer unitialised (because high byte
eb57 : a596             [ 3] 	lda df_currdat+1
eb59 : d02e             [ 3] 	bne df_rt_skipinitdataptr
                             	; then start at program beginning
                             	_cpyZPWord df_prgstrt,df_currdat
                             
eb63 :                       df_rt_datlinstart
                             	; if end of program then error
eb63 : a195             [ 6] 	lda (df_currdat,x)
eb65 : f032             [ 3] 	beq df_rt_datumerr
                             	; index in to first line byte
eb67 : a003             [ 2] 	ldy #3
eb69 : 8497             [ 3] 	sty df_datoff
                             	; find first 'data' statement
eb6b :                       df_rt_datastatement
eb6b : c8               [ 2] 	iny
eb6c : 98               [ 2] 	tya
                             	; end of line reached?
eb6d : c195             [ 6] 	cmp (df_currdat,x)
                             	; if not find data token
eb6f : d00e             [ 3] 	bne df_rt_getdatatk
eb71 :                       df_rt_datnextlin
                             	; if so then go to next line
eb71 : 18               [ 2] 	clc
eb72 : a595             [ 3] 	lda df_currdat
eb74 : 6195             [ 6] 	adc (df_currdat,x)
eb76 : 8595             [ 3] 	sta df_currdat
                             	_bcc 2
                             
eb7a : e696             [ 5] 	inc df_currdat+1
eb7c : 4c63eb           [ 3] 	jmp df_rt_datlinstart
eb7f :                       df_rt_getdatatk
eb7f : b195             [ 5] 	lda (df_currdat),y
eb81 : 10e8             [ 3] 	bpl df_rt_datastatement
                             	; found data statement?
eb83 : c996             [ 2] 	cmp #DFRT_DATA
                             	; if not then go to next line
eb85 : d0ea             [ 3] 	bne df_rt_datnextlin
eb87 : 8497             [ 3] 	sty df_datoff
eb89 :                       df_rt_skipinitdataptr
eb89 : 98               [ 2] 	tya
                             	; end of line reached?
eb8a : c195             [ 6] 	cmp (df_currdat,x)
                             	; if so go to next line
eb8c : f0e3             [ 3] 	beq df_rt_datnextlin
                             	; else see if escape value
eb8e : b195             [ 5] 	lda (df_currdat),y
eb90 : c920             [ 2] 	cmp #DFTK_ESCVAL
eb92 : c8               [ 2] 	iny
eb93 : b0f4             [ 3] 	bcs df_rt_skipinitdataptr
                             	; ok found an escape value
                             	; save position and return
eb95 : 88               [ 2] 	dey
eb96 : 8497             [ 3] 	sty df_datoff
eb98 : 60               [ 6] 	rts
eb99 :                       df_rt_datumerr
                             	SWBRK DFERR_NODATA
                             
                             
AS65 Assembler for R6502 [1.42].                                     Page  230
---------------------------------- bank0.s -----------------------------------

                             ; read a datum
eb9b :                       df_rt_readdatum
                             	; update data pointer to next data item
eb9b : 2053eb           [ 6] 	jsr df_rt_nextdatum
                             	; now get lvar X,A from current statement
eb9e : 2064e6           [ 6] 	jsr df_rt_getlvar
                             	; save lvar in tmpb, vvt ptr in tmpa
eba1 : 86a4             [ 3] 	stx df_tmpptrb
eba3 : 85a5             [ 3] 	sta df_tmpptrb+1
                             
                             	; first save save current prgoram line and offse
eba5 : a587             [ 3] 	lda df_currlin
eba7 : 48               [ 3] 	pha
eba8 : a588             [ 3] 	lda df_currlin+1
ebaa : 48               [ 3] 	pha
ebab : a589             [ 3] 	lda df_exeoff
ebad : 48               [ 3] 	pha
ebae : a57f             [ 3] 	lda df_eolidx
ebb0 : 48               [ 3] 	pha
ebb1 : a580             [ 3] 	lda df_nxtstidx
ebb3 : 48               [ 3] 	pha
ebb4 : a581             [ 3] 	lda df_curstidx
ebb6 : 48               [ 3] 	pha
                             
                             	; use data pointer as current position for evalu
                             	_cpyZPWord df_currdat,df_currlin
                             
ebbf : a597             [ 3] 	lda df_datoff
ebc1 : 8589             [ 3] 	sta df_exeoff
ebc3 : a200             [ 2] 	ldx #0
ebc5 : a195             [ 6] 	lda (df_currdat,x)
ebc7 : 857f             [ 3] 	sta df_eolidx
ebc9 : 8580             [ 3] 	sta df_nxtstidx
ebcb : a903             [ 2] 	lda #3
ebcd : 8581             [ 3] 	sta df_curstidx
                             
                             	; get type from vvt ptr in tmpa
ebcf : a1a2             [ 6] 	lda (df_tmpptra,x)
ebd1 : a8               [ 2] 	tay
                             	; get lvar point from tmpb
ebd2 : a6a4             [ 3] 	ldx df_tmpptrb
ebd4 : a5a5             [ 3] 	lda df_tmpptrb+1
                             
                             	; X,A and Y set up, now evaluate and perform ass
ebd6 : 206cee           [ 6] 	jsr df_rt_doassign
                             
                             	; update data offset as data has been consumed
ebd9 : a589             [ 3] 	lda df_exeoff
ebdb : 8597             [ 3] 	sta df_datoff
                             	; restore line settings
ebdd : 68               [ 4] 	pla
ebde : 8581             [ 3] 	sta df_curstidx
ebe0 : 68               [ 4] 	pla
ebe1 : 8580             [ 3] 	sta df_nxtstidx
ebe3 : 68               [ 4] 	pla
ebe4 : 857f             [ 3] 	sta df_eolidx
ebe6 : 68               [ 4] 	pla
ebe7 : 8589             [ 3] 	sta df_exeoff
ebe9 : 68               [ 4] 	pla
ebea : 8588             [ 3] 	sta df_currlin+1
ebec : 68               [ 4] 	pla
ebed : 8587             [ 3] 	sta df_currlin
AS65 Assembler for R6502 [1.42].                                     Page  231
---------------------------------- bank0.s -----------------------------------

ebef : 60               [ 6] 	rts
                             
                             
ebf0 :                       df_rt_read
                             	; find variable to read in to from current posit
ebf0 : a489             [ 3] 	ldy df_exeoff
ebf2 :                       df_rt_read_find_var
ebf2 : c8               [ 2] 	iny
                             	; if end of line or statement then done
                             ;	cpy df_eolidx
                             ;	beq df_rt_read_done
ebf3 : c480             [ 3] 	cpy df_nxtstidx
ebf5 : f00e             [ 4] 	beq df_rt_read_done
                             	; if not found escape then next byte
ebf7 : b187             [ 5] 	lda (df_currlin),y
ebf9 : c920             [ 2] 	cmp #DFTK_ESCVAL
ebfb : b0f5             [ 3] 	bcs df_rt_read_find_var
                             	; ok found escape, save position
ebfd : 8489             [ 3] 	sty df_exeoff
                             	; go and read in the value
ebff : 209beb           [ 6] 	jsr df_rt_readdatum
                             	; try find another variable
ec02 : 4cf0eb           [ 3] 	jmp df_rt_read
                             
ec05 :                       df_rt_read_done
                             	; save position
ec05 : 8489             [ 3] 	sty df_exeoff
ec07 : 60               [ 6] 	rts
                             
ec08 :                       df_rt_input
                             	; df_tmpptra has the vvt address, X,A is the lva
ec08 : 2064e6           [ 6] 	jsr df_rt_getlvar
                             	; Save lvar pointer
ec0b : 86a4             [ 3] 	stx df_tmpptrb
ec0d : 85a5             [ 3] 	sta df_tmpptrb+1
                             	; go read a line of input
                             	; buf_lo ptr has the input, Y is size
ec0f : 38               [ 2] 	sec
ec10 : 2045c4           [ 6] 	jsr io_read_line
                             	; check the type
ec13 : a200             [ 2] 	ldx #0
ec15 : a1a2             [ 6] 	lda (df_tmpptra,x)
ec17 : 2904             [ 2] 	and #DFVVT_STR
ec19 : d008             [ 3] 	bne df_rt_input_str
ec1b : a1a2             [ 6] 	lda (df_tmpptra,x)
ec1d : 2903             [ 2] 	and #DFVVT_INT|DFVVT_BYT
ec1f : d00a             [ 3] 	bne df_rt_input_num
                             	; if not int or byte then error
ec21 : f01f             [ 3] 	beq df_rt_input_err
ec23 :                       df_rt_input_str
ec23 : b139             [ 5] 	lda (buf_lo),y
ec25 : 91a4             [ 5] 	sta (df_tmpptrb),y
ec27 : 88               [ 2] 	dey
ec28 : 10f9             [ 3] 	bpl df_rt_input_str
ec2a : 60               [ 6] 	rts
                             
ec2b :                       df_rt_input_num
                             	; X,A = address, linbuff must be on page boundar
ec2b : a53a             [ 3] 	lda buf_lo+1
ec2d : a639             [ 3] 	ldx buf_lo
ec2f : a000             [ 2] 	ldy #0				; any numeric format
ec31 : 20d1c1           [ 6] 	jsr con_n_to_a
AS65 Assembler for R6502 [1.42].                                     Page  232
---------------------------------- bank0.s -----------------------------------

ec34 : b00c             [ 3] 	bcs df_rt_input_err
ec36 : a000             [ 2] 	ldy #0
ec38 : a53d             [ 3] 	lda num_a
ec3a : 91a4             [ 5] 	sta (df_tmpptrb),y
ec3c : c8               [ 2] 	iny
ec3d : a53e             [ 3] 	lda num_a+1
ec3f : 91a4             [ 5] 	sta (df_tmpptrb),y
ec41 : 60               [ 6] 	rts
ec42 :                       df_rt_input_err
                             	SWBRK DFERR_TYPEMISM
                             
                             
ec44 :                       df_rt_local
                             	; get current local count off rt stack
ec44 : 202bf7           [ 6] 	jsr df_rst_popByte
                             	; save on pc stack for incrmenting
ec47 : 48               [ 3] 	pha
ec48 : a489             [ 3] 	ldy df_exeoff
ec4a : 88               [ 2] 	dey
ec4b :                       df_rt_local_findesc
ec4b : c8               [ 2] 	iny
                             	; check end of line
                             ;	cpy df_eolidx
                             ;	beq df_rt_local_done
ec4c : c480             [ 3] 	cpy df_nxtstidx
ec4e : f01c             [ 3] 	beq df_rt_local_done
                             	; find a var
ec50 : b187             [ 5] 	lda (df_currlin),y
ec52 : c911             [ 2] 	cmp #DFTK_VAR
ec54 : d0f5             [ 3] 	bne df_rt_local_findesc
                             	; jump over escape value
ec56 : c8               [ 2] 	iny
                             	; get var slot in A,X
ec57 : b187             [ 5] 	lda (df_currlin),y
ec59 : aa               [ 2] 	tax
ec5a : c8               [ 2] 	iny
ec5b : b187             [ 5] 	lda (df_currlin),y
ec5d : 8489             [ 3] 	sty df_exeoff
                             	; localise this variable
ec5f : 200ef7           [ 6] 	jsr df_rt_proc_local
                             	; increment local counter
ec62 : 68               [ 4] 	pla
ec63 : 18               [ 2] 	clc
ec64 : 6901             [ 2] 	adc #1
ec66 : 48               [ 3] 	pha
ec67 : a489             [ 3] 	ldy df_exeoff
ec69 : 4c4bec           [ 3] 	jmp df_rt_local_findesc
ec6c :                       df_rt_local_done
                             	; get the local counter
                             	; put on to rt stack
ec6c : 68               [ 4] 	pla
ec6d : 4c22f7           [ 3] 	jmp df_rst_pushByte
                             
                             
ec70 :                       df_rt_redim
ec70 : 38               [ 2] 	sec
ec71 : b001             [ 3] 	bcs df_rt_dim_main
ec73 :                       df_rt_dim
ec73 : 18               [ 2] 	clc
ec74 :                       df_rt_dim_main
ec74 : 08               [ 3] 	php
ec75 :                       df_rt_dim_loop
AS65 Assembler for R6502 [1.42].                                     Page  233
---------------------------------- bank0.s -----------------------------------

ec75 : a489             [ 3] 	ldy df_exeoff
ec77 : 88               [ 2] 	dey
ec78 :                       df_rt_dim_findesc
                             	; check end of line
ec78 : c8               [ 2] 	iny
                             ;	cpy df_eolidx
                             ;	beq df_rt_dim_done
ec79 : c480             [ 3] 	cpy df_nxtstidx
ec7b : f07d             [ 3] 	beq df_rt_dim_done
                             	; find a var
ec7d : b187             [ 5] 	lda (df_currlin),y
ec7f : c911             [ 2] 	cmp #DFTK_VAR
ec81 : d0f5             [ 3] 	bne df_rt_dim_findesc
                             	; jump over escape value
ec83 : c8               [ 2] 	iny
                             	; get var address
ec84 : b187             [ 5] 	lda (df_currlin),y
ec86 : 85a2             [ 3] 	sta df_tmpptra
ec88 : c8               [ 2] 	iny
ec89 : b187             [ 5] 	lda (df_currlin),y
ec8b : 85a3             [ 3] 	sta df_tmpptra+1
                             	; move to open bracket
ec8d : c8               [ 2] 	iny
ec8e : 8489             [ 3] 	sty df_exeoff
                             	; If re-dim, don't check for existing dimensions
ec90 : 28               [ 4] 	plp
ec91 : 08               [ 3] 	php
ec92 : b006             [ 3] 	bcs df_rt_skip_dim_chk
                             	; check if already dim'd
ec94 : a003             [ 2] 	ldy #DFVVT_DIM1
ec96 : b1a2             [ 5] 	lda (df_tmpptra),y
ec98 : d062             [ 3] 	bne df_rt_dim_err
ec9a :                       df_rt_skip_dim_chk
                             	; Save slot address found earlier
ec9a : a5a2             [ 3] 	lda df_tmpptra
ec9c : 48               [ 3] 	pha
ec9d : a5a3             [ 3] 	lda df_tmpptra+1
ec9f : 48               [ 3] 	pha
eca0 : 20a6e3           [ 6] 	jsr df_rt_arry_parm2
                             	; Restore slot address
eca3 : 68               [ 4] 	pla
eca4 : 85a3             [ 3] 	sta df_tmpptra+1
eca6 : 68               [ 4] 	pla
eca7 : 85a2             [ 3] 	sta df_tmpptra
                             ;	bcs df_rt_dim_err
                             	; save x,y to dim1,2
eca9 : 98               [ 2] 	tya
ecaa : 48               [ 3] 	pha
ecab : 8a               [ 2] 	txa
ecac : 48               [ 3] 	pha
ecad : a003             [ 2] 	ldy #DFVVT_DIM1
ecaf : 68               [ 4] 	pla
ecb0 : 91a2             [ 5] 	sta (df_tmpptra),y
ecb2 : c8               [ 2] 	iny
ecb3 : 68               [ 4] 	pla
ecb4 : 91a2             [ 5] 	sta (df_tmpptra),y
ecb6 : 28               [ 4] 	plp
ecb7 : 08               [ 3] 	php
ecb8 : b035             [ 3] 	bcs df_rt_dim_set_type
ecba :                       df_rt_dim_alloc
                             	; ok we have up to 2 dimensions
                             	; mult dim 1 and 2 if dim 2 <> 0
AS65 Assembler for R6502 [1.42].                                     Page  234
---------------------------------- bank0.s -----------------------------------

ecba : a003             [ 2] 	ldy #DFVVT_DIM1
ecbc : b1a2             [ 5] 	lda (df_tmpptra),y
ecbe : 853d             [ 3] 	sta num_a
ecc0 : a900             [ 2] 	lda #0
ecc2 : 853e             [ 3] 	sta num_a+1
ecc4 : c8               [ 2] 	iny
ecc5 : b1a2             [ 5] 	lda (df_tmpptra),y
ecc7 : d002             [ 3] 	bne df_rt_dim2_nz
ecc9 : a901             [ 2] 	lda #1
eccb :                       df_rt_dim2_nz
eccb : 8541             [ 3] 	sta num_b
eccd : a900             [ 2] 	lda #0
eccf : 8542             [ 3] 	sta num_b+1
ecd1 : 201fd6           [ 6] 	jsr int_fast_mult
                             	; check the type if int then mult2
ecd4 : a200             [ 2] 	ldx #0
ecd6 : a1a2             [ 6] 	lda (df_tmpptra,x)
ecd8 : 2901             [ 2] 	and #DFVVT_INT
ecda : f004             [ 3] 	beq df_rt_dim2_mul2
ecdc : 063d             [ 5] 	asl num_a
ecde : 263e             [ 5] 	rol num_a+1
ece0 :                       df_rt_dim2_mul2
                             	; finally, we have a size of array
ece0 : a63d             [ 3] 	ldx num_a
ece2 : a53e             [ 3] 	lda num_a+1
                             
                             	; get a block of that size from heap
ece4 : 20a7f7           [ 6] 	jsr df_st_malloc
                             	; save pointer to block in var
ece7 : a002             [ 2] 	ldy #DFVVT_HI
ece9 : 91a2             [ 5] 	sta (df_tmpptra),y
eceb : 8a               [ 2] 	txa
ecec : 88               [ 2] 	dey
eced : 91a2             [ 5] 	sta (df_tmpptra),y
                             	; finally, update the type to indicate array
ecef :                       df_rt_dim_set_type
ecef : a200             [ 2] 	ldx #0
ecf1 : a1a2             [ 6] 	lda (df_tmpptra,x)
ecf3 : 0980             [ 2] 	ora #DFVVT_PTR
ecf5 : 81a2             [ 6] 	sta (df_tmpptra,x)
                             	; don't increment byte again - go check for more
ecf7 : 4c75ec           [ 3] 	jmp df_rt_dim_loop
ecfa :                       df_rt_dim_done
ecfa : 28               [ 4] 	plp
ecfb : 60               [ 6] 	rts
ecfc :                       df_rt_dim_err
                             	SWBRK DFERR_DIM
                             
                             
                             
ecfe :                       df_rt_cls
ecfe : 4c50cf           [ 3] 	jmp gr_cls
                             
                             
ed01 :                       df_rt_plot
                             	; evaluate the expression
ed01 : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; save lo byte
ed04 : 8a               [ 2] 	txa
ed05 : 48               [ 3] 	pha
                             	; jump over comma
ed06 : e689             [ 5] 	inc df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  235
---------------------------------- bank0.s -----------------------------------

                             	; evaluate the expression
ed08 : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; save lo byte
ed0b : 8a               [ 2] 	txa
ed0c : 48               [ 3] 	pha
                             	; jump over comma
ed0d : e689             [ 5] 	inc df_exeoff
                             	; evaluate the expression
ed0f : 2026e2           [ 6] 	jsr df_rt_neval
                             	; check the type on the stack
ed12 : 2095f7           [ 6] 	jsr df_ost_peekType
                             	; if >=0x80 then a pointer / string
ed15 : 2904             [ 2] 	and #DFST_STR
ed17 : d01b             [ 3] 	bne df_rt_plotstr
                             	; else it is int
ed19 : 209bf7           [ 6] 	jsr df_ost_popInt
                             	; save  low byte of pop result in a temp
ed1c : 86a2             [ 3] 	stx df_tmpptra
ed1e : a511             [ 3] 	lda gr_scrngeom+gr_mode			; Check screen mode
ed20 : d009             [ 3] 	bne df_rt_plot_h_int
                             	; get X and Y coord in that order
                             	; but Y coord goes in X register!!!
ed22 : 68               [ 4] 	pla
ed23 : aa               [ 2] 	tax
ed24 : 68               [ 4] 	pla
ed25 : a8               [ 2] 	tay
ed26 : a5a2             [ 3] 	lda df_tmpptra	; Get pop result in to A
ed28 : 4ca4cf           [ 3] 	jmp gr_plot
ed2b :                       df_rt_plot_h_int
ed2b : 68               [ 4] 	pla
ed2c : a8               [ 2] 	tay
ed2d : 68               [ 4] 	pla
ed2e : aa               [ 2] 	tax
ed2f : a5a2             [ 3] 	lda df_tmpptra	; Get pop result in to A
ed31 : 4c65d1           [ 3] 	jmp gr_hchar
                             
                             
ed34 :                       df_rt_plotstr
                             	; pop string pointer
ed34 : 20a3f7           [ 6] 	jsr df_ost_popPtr
                             	; save pointer to tmpa
ed37 : 86a2             [ 3] 	stx df_tmpptra
ed39 : 85a3             [ 3] 	sta df_tmpptra+1
                             	; get y and x in that order
                             	; but X register is Y coord!!
ed3b : 68               [ 4] 	pla
ed3c : 85a6             [ 3] 	sta df_tmpptrc			; Y coord in C
ed3e : 68               [ 4] 	pla
ed3f : 85a4             [ 3] 	sta df_tmpptrb			; X coord in B
                             	; set cursror position
ed41 : a000             [ 2] 	ldy #0
ed43 : 84aa             [ 3] 	sty df_tmpptre
ed45 :                       df_rt_plotstrch
ed45 : a4aa             [ 3] 	ldy df_tmpptre
ed47 : b1a2             [ 5] 	lda (df_tmpptra),y
ed49 : 85a8             [ 3] 	sta df_tmpptrd			; char in D
ed4b : f025             [ 3] 	beq df_rt_plotstrdone
ed4d : e6aa             [ 5] 	inc df_tmpptre
ed4f : a511             [ 3] 	lda gr_scrngeom+gr_mode; Check screen mode
ed51 : d00d             [ 3] 	bne df_rt_plot_h_str
ed53 : a5a8             [ 3] 	lda df_tmpptrd			; Get char to plot
ed55 : a6a6             [ 3] 	ldx df_tmpptrc			; Get Y coord
AS65 Assembler for R6502 [1.42].                                     Page  236
---------------------------------- bank0.s -----------------------------------

ed57 : a4a4             [ 3] 	ldy df_tmpptrb			; Get X coord
ed59 : 20a4cf           [ 6] 	jsr gr_plot
ed5c : e6a4             [ 5] 	inc df_tmpptrb			; Increment X coord
ed5e : d0e5             [ 3] 	bne df_rt_plotstrch		; Always - assume x is neve
ed60 :                       df_rt_plot_h_str
ed60 : a5a8             [ 3] 	lda df_tmpptrd			; Get char to plot
ed62 : a6a4             [ 3] 	ldx df_tmpptrb			; Get X coord
ed64 : a4a6             [ 3] 	ldy df_tmpptrc			; Get Y coord
ed66 : 2065d1           [ 6] 	jsr gr_hchar
ed69 : 18               [ 2] 	clc
ed6a : a5a4             [ 3] 	lda df_tmpptrb
ed6c : 6520             [ 3] 	adc gr_scrngeom+gr_pitch
ed6e : 85a4             [ 3] 	sta df_tmpptrb
ed70 : d0d3             [ 3] 	bne df_rt_plotstrch		; Always - assume adding pi
ed72 :                       df_rt_plotstrdone
ed72 : 60               [ 6] 	rts
                             
ed73 :                       df_rt_cursor
                             	; evaluate the expression
ed73 : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; write low byte of vdp_curoff
                             	; by writing a zero then cursor on else not
ed76 : 860d             [ 3] 	stx vdp_curoff
ed78 : 60               [ 6] 	rts
                             
                             ;df_rt_himem
                             ;	; evaluate the expression
                             ;	jsr df_rt_getnval
                             ;	; write X,A to df_memtop
                             ;	stx df_memtop
                             ;	sta df_memtop+1
                             ;	; now clear everything down
                             ;	jmp df_clear
                             
ed79 :                       df_rt_text
ed79 : 4cbace           [ 3] 	jmp gr_init_screen_txt
                             
ed7c :                       df_rt_hires
ed7c : 4cd3ce           [ 3] 	jmp gr_init_hires
                             
ed7f :                       df_rt_pixmode
                             	; evaluate the expression X = mode
ed7f : 2020e2           [ 6] 	jsr df_rt_getnval
ed82 : 861f             [ 3] 	stx gr_scrngeom+gr_pixmode
ed84 : 60               [ 6] 	rts
                             
ed85 :                       df_rt_ink
                             	; evaluate the expression X = col
ed85 : 2020e2           [ 6] 	jsr df_rt_getnval
ed88 : 8623             [ 3] 	stx gr_scrngeom+gr_ink
ed8a : 60               [ 6] 	rts
                             
ed8b :                       df_rt_paper
                             	; evaluate the expression X = col
ed8b : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; Add 16 to get paper colour
ed8e : 8a               [ 2] 	txa
ed8f : 18               [ 2] 	clc
ed90 : 6910             [ 2] 	adc #16
ed92 : 8524             [ 3] 	sta gr_scrngeom+gr_paper
ed94 : 60               [ 6] 	rts
                             
AS65 Assembler for R6502 [1.42].                                     Page  237
---------------------------------- bank0.s -----------------------------------

ed95 :                       df_rt_point
ed95 : 20ede4           [ 6] 	jsr df_rt_parm_2ints
ed98 : a6a2             [ 3] 	ldx df_tmpptra
ed9a : a4a4             [ 3] 	ldy df_tmpptrb
ed9c : 4c25d2           [ 3] 	jmp gr_point
                             
ed9f :                       df_rt_circle
ed9f : 20f8e4           [ 6] 	jsr df_rt_parm_3ints
eda2 : a5a2             [ 3] 	lda df_tmpptra				; load x0
eda4 : 853d             [ 3] 	sta num_a
eda6 : a5a4             [ 3] 	lda	df_tmpptrb				; load y0
eda8 : 853e             [ 3] 	sta num_a+1
edaa : a5a6             [ 3] 	lda df_tmpptrc				; load r
edac : 853f             [ 3] 	sta num_a+2
edae : 4c56d2           [ 3] 	jmp gr_circle
                             
edb1 :                       df_rt_lineto
edb1 : 20ede4           [ 6] 	jsr df_rt_parm_2ints
edb4 : a6a2             [ 3] 	ldx df_tmpptra				; load x1
edb6 : a4a4             [ 3] 	ldy df_tmpptrb				; load y1
edb8 :                       df_rt_doline
edb8 : 863f             [ 3] 	stx num_a+2
edba : 8440             [ 3] 	sty num_a+3
edbc : 4c0cd3           [ 3] 	jmp gr_line
edbf :                       df_rt_line
edbf : 200fe5           [ 6] 	jsr df_rt_parm_4ints
edc2 : a6a2             [ 3] 	ldx df_tmpptra				; load x0
edc4 : a4a4             [ 3] 	ldy	df_tmpptrb				; load y0
edc6 : 201ad2           [ 6] 	jsr gr_set_hires_cur		; Start from x,y
edc9 : a6a6             [ 3] 	ldx df_tmpptrc				; load x1
edcb : a4a8             [ 3] 	ldy df_tmpptrd				; load y1
edcd : 4cb8ed           [ 3] 	jmp df_rt_doline
                             
edd0 :                       df_rt_wait
                             	; evaluate the expression
edd0 : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; put high byte in to Y (X,Y)=16 bits
edd3 : a8               [ 2] 	tay
edd4 :                       df_rt_wait_counter
                             	; get vdp low byte timer val in A
edd4 : a508             [ 3] 	lda vdp_cnt
edd6 :                       df_rt_wait_tick
                             	; check if a tick has occurred (i.e. val <> A)
edd6 : c508             [ 3] 	cmp vdp_cnt
edd8 : f0fc             [ 3] 	beq df_rt_wait_tick
                             	; countdown tick
edda : 8a               [ 2] 	txa
eddb : d001             [ 3] 	bne df_rt_wait_skiphi
eddd : 88               [ 2] 	dey
edde :                       df_rt_wait_skiphi	
edde : ca               [ 2] 	dex
eddf : 8a               [ 2] 	txa
ede0 : d0f2             [ 3] 	bne df_rt_wait_counter
ede2 : 98               [ 2] 	tya
ede3 : d0ef             [ 3] 	bne df_rt_wait_counter
ede5 :                       df_rt_wait_done
ede5 : 60               [ 6] 	rts
                             
ede6 :                       df_rt_printat
                             	; Get x,y
ede6 : 20ede4           [ 6] 	jsr df_rt_parm_2ints
ede9 : a6a2             [ 3] 	ldx df_tmpptra
AS65 Assembler for R6502 [1.42].                                     Page  238
---------------------------------- bank0.s -----------------------------------

edeb : a4a4             [ 3] 	ldy df_tmpptrb
                             	; Set the cursror here
eded : 20bdcf           [ 6] 	jsr gr_set_cur
                             	; and continue to normal print command
edf0 :                       df_rt_print
edf0 : a489             [ 3] 	ldy df_exeoff
edf2 : 88               [ 2] 	dey
edf3 :                       df_rt_print_ws
edf3 : c8               [ 2] 	iny
                             
                             	; evaluate an expression
                             ;	cpy df_eolidx
                             ;	beq df_rt_print_done
edf4 : c480             [ 3] 	cpy df_nxtstidx
edf6 : f026             [ 4] 	beq df_rt_print_done
edf8 : b187             [ 5] 	lda (df_currlin),y
edfa : c93a             [ 2] 	cmp #':'
edfc : f020             [ 4] 	beq df_rt_print_done
edfe : c920             [ 2] 	cmp #' '
ee00 : f0f1             [ 4] 	beq df_rt_print_ws
ee02 : c92c             [ 2] 	cmp #','
ee04 : f0ed             [ 4] 	beq df_rt_print_ws
                             	; save index
ee06 : 8489             [ 3] 	sty df_exeoff
                             
                             	; if starts with string literal then process sev
                             ;	cmp #DFTK_STRLIT
                             ;	beq df_rt_print_string
                             	; else evaluate a numeric
ee08 : 2026e2           [ 6] 	jsr df_rt_neval
                             	; check what is on the argument stack
ee0b : 2095f7           [ 6] 	jsr df_ost_peekType
ee0e : 2904             [ 2] 	and #DFST_STR
ee10 : d006             [ 3] 	bne df_rt_print_gotstr
ee12 : 2038eb           [ 6] 	jsr df_rt_print_num
ee15 : 4cf0ed           [ 3] 	jmp df_rt_print
ee18 :                       df_rt_print_gotstr
ee18 : 203feb           [ 6] 	jsr df_rt_print_str
ee1b : 4cf0ed           [ 3] 	jmp df_rt_print
                             ;df_rt_print_string
                             ;	jsr df_rt_seval
                             ;	jmp df_rt_print_gotstr
ee1e :                       df_rt_print_done
ee1e : 8489             [ 3] 	sty df_exeoff
ee20 : 60               [ 6] 	rts
                             
ee21 :                       df_rt_println
ee21 : 20f0ed           [ 6] 	jsr df_rt_print
ee24 : a90d             [ 2] 	lda #UTF_CR
ee26 : 4c30c4           [ 3] 	jmp io_put_ch
                             
                             
                             ; assign to a number variable
                             ; X,A must have lvar
ee29 :                       df_rt_nassign
                             	; push var address, A ok to trample
ee29 : 48               [ 3] 	pha
ee2a : 8a               [ 2] 	txa
ee2b : 48               [ 3] 	pha
                             
                             	; now go evaluate expression in to A,X
ee2c : 2020e2           [ 6] 	jsr df_rt_getnval
AS65 Assembler for R6502 [1.42].                                     Page  239
---------------------------------- bank0.s -----------------------------------

                             	; restore variable address to write to to df_tmp
                             	; but don't lose current A
ee2f : a8               [ 2] 	tay					; Save A in Y
ee30 : 68               [ 4] 	pla
ee31 : 85a2             [ 3] 	sta df_tmpptra
ee33 : 68               [ 4] 	pla
ee34 : 85a3             [ 3] 	sta df_tmpptra+1
ee36 : 98               [ 2] 	tya					; Get A back from Y
                             
                             	; save X,A int in contents section
ee37 : a001             [ 2] 	ldy #1
ee39 : 91a2             [ 5] 	sta (df_tmpptra),y
ee3b : 8a               [ 2] 	txa
ee3c : 88               [ 2] 	dey
ee3d : 91a2             [ 5] 	sta (df_tmpptra),y
                             
ee3f : 60               [ 6] 	rts
                             
                             ; assign to a string variable
                             ; X,A must have lvar
ee40 :                       df_rt_sassign
                             	; now go evaluate expression
                             	; with the destination being already in X,A
ee40 : 20e4e2           [ 6] 	jsr df_rt_sval
                             
                             	; get string pointer from top of runtime stack
ee43 : 4c9ff7           [ 3] 	jmp df_ost_popStr
                             
                             
                             ; generate lvar from a var token ready for assign
ee46 :                       df_rt_generate_lvar
                             	; move past escape val
ee46 : a489             [ 3] 	ldy df_exeoff
ee48 : c8               [ 2] 	iny
                             	; pointing to variable index
ee49 : b187             [ 5] 	lda (df_currlin),y
ee4b : 85a2             [ 3] 	sta df_tmpptra
ee4d : c8               [ 2] 	iny
ee4e : b187             [ 5] 	lda (df_currlin),y
ee50 : 8489             [ 3] 	sty df_exeoff
ee52 : 85a3             [ 3] 	sta df_tmpptra+1
                             
                             	; get the type and save
ee54 : a200             [ 2] 	ldx #0
ee56 : a1a2             [ 6] 	lda (df_tmpptra,x)
ee58 : 48               [ 3] 	pha
                             
                             	; set carry flag to return pointer (lvar)
ee59 : 38               [ 2] 	sec
ee5a : 20cae3           [ 6] 	jsr df_rt_eval_var
ee5d : 20a3f7           [ 6] 	jsr df_ost_popPtr
                             
                             	; pull the type previously saved into Y
ee60 : 8538             [ 3] 	sta tmp_d		; Save A
ee62 : 68               [ 4] 	pla
ee63 : a8               [ 2] 	tay
ee64 : a538             [ 3] 	lda tmp_d
                             	; move past the lvar variable index
ee66 : e689             [ 5] 	inc df_exeoff
ee68 : 60               [ 6] 	rts
                             
                             ; general assignment execution
AS65 Assembler for R6502 [1.42].                                     Page  240
---------------------------------- bank0.s -----------------------------------

                             ; generate lvar first
ee69 :                       df_rt_assign
ee69 : 2046ee           [ 6] 	jsr df_rt_generate_lvar
                             ; X,A,Y contain lvar pointer and type
ee6c :                       df_rt_doassign
                             	; save A and put type Y in to A to check for str
ee6c : 48               [ 3] 	pha
ee6d : 98               [ 2] 	tya
ee6e : 2904             [ 2] 	and #DFVVT_STR
                             	; if a string then string expression
ee70 : d004             [ 3] 	bne df_rt_assign_str
                             	;  jump to numeric expression evaluator
                             	; remember to restore A
ee72 : 68               [ 4] 	pla
ee73 : 4c29ee           [ 3] 	jmp df_rt_nassign
ee76 :                       df_rt_assign_str
                             	; else jump to string expression evaluator
                             	; remember to restore A
ee76 : 68               [ 4] 	pla
ee77 : 4c40ee           [ 3] 	jmp df_rt_sassign
                             
                             ; comment or data token is ignored by runtime
ee7a :                       df_rt_comment
ee7a :                       df_rt_data
ee7a : 60               [ 6] 	rts
                             
                             
                             ; run token - future expansion
ee7b :                       df_rt_run
ee7b : 60               [ 6] 	rts
                             
                             ; end of line / statement indicator
                             ; CS = End, CC = not end
ee7c :                       df_rt_eos
ee7c : a489             [ 3] 	ldy df_exeoff
                             ;	cpy df_eolidx
                             ;	beq df_rt_eos_true
ee7e : c480             [ 3] 	cpy df_nxtstidx
ee80 : f008             [ 3] 	beq df_rt_eos_true
ee82 : b187             [ 5] 	lda (df_currlin),y
ee84 : c93a             [ 2] 	cmp #':'
ee86 : f002             [ 3] 	beq df_rt_eos_true
ee88 : 18               [ 2] 	clc
ee89 : 60               [ 6] 	rts
ee8a :                       df_rt_eos_true
ee8a : 38               [ 2] 	sec
ee8b : 60               [ 6] 	rts
                             
                             ; renum startLine,newStart,increment
                             ; renumbers from the first matching line to end o
                             ;df_rt_renum
                             ;	inc df_exeoff
                             ;	jsr df_rt_parm_3ints
                             ;	; starting line number
                             ;	ldx df_tmpptra
                             ;	lda df_tmpptra+1
                             ;	jsr df_pg_find_line
                             ;	bcc df_rt_renum_ok
                             ;	SWBRK DFERR_NOLINE
                             ;df_rt_renum_ok
                             ;	; save starting position pointer in ptrd
                             ;	stx df_tmpptrd
AS65 Assembler for R6502 [1.42].                                     Page  241
---------------------------------- bank0.s -----------------------------------

                             ;	sta df_tmpptrd+1
                             ;df_rt_renum_do
                             ;	; if not end of program
                             ;	ldy #0
                             ;	lda (df_tmpptrd),y
                             ;	; then renumber this line
                             ;	bne df_rt_renum_update
                             ;	; else done
                             ;	rts
                             ;df_rt_renum_update
                             ;	; so set this line number to new line number
                             ;	ldy #DFTK_LINNUM
                             ;	lda df_tmpptrb
                             ;	sta (df_tmpptrd),y
                             ;	iny
                             ;	lda df_tmpptrb+1
                             ;	sta (df_tmpptrd),y
                             ;	; add increment to new line
                             ;	_addZPWord df_tmpptrb,df_tmpptrc
                             ;df_rt_renum_next
                             ;	; point ptrd to the next line
                             ;	clc
                             ;	lda df_tmpptrd
                             ;	ldx #0
                             ;	adc (df_tmpptrd,x)
                             ;	sta df_tmpptrd
                             ;	_bcc 2
                             ;	inc df_tmpptrd+1
                             ;	jmp df_rt_renum_do
                             
                             
                             ; * List all procs in VNT
ee8c :                       df_rt_listprocnames
                             	; start at the beginning of the vnt table
                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
                             	; start at varcnt
ee94 : a572             [ 3] 	lda df_varcnt
ee96 : 85a4             [ 3] 	sta df_tmpptrb
ee98 :                       df_rt_listcheckvnt
                             	; If reached 0 then not found
ee98 : a5a4             [ 3] 	lda df_tmpptrb
ee9a : f03a             [ 3] 	beq df_rt_listpn_done
ee9c : a000             [ 2] 	ldy #0
ee9e : b1a2             [ 5] 	lda (df_tmpptra),y
eea0 : c95f             [ 2] 	cmp #'_'
eea2 : d01b             [ 3] 	bne df_rt_listnextvnt
eea4 :                       df_rt_listprocch
eea4 : b1a2             [ 5] 	lda (df_tmpptra),y
eea6 : 2030c4           [ 6] 	jsr io_put_ch
eea9 : aa               [ 2] 	tax
eeaa : f003             [ 3] 	beq df_rt_listproccr
eeac : c8               [ 2] 	iny
eead : d0f5             [ 3] 	bne df_rt_listprocch		; Always
eeaf :                       df_rt_listproccr
eeaf : a90d             [ 2] 	lda #UTF_CR
eeb1 : 2030c4           [ 6] 	jsr io_put_ch
eeb4 : 18               [ 2] 	clc
eeb5 :                       df_rt_listprocpause
eeb5 : 202dc4           [ 6] 	jsr io_get_ch
eeb8 : c920             [ 2] 	cmp #' '
eeba : d003             [ 3] 	bne df_rt_listnextvnt
AS65 Assembler for R6502 [1.42].                                     Page  242
---------------------------------- bank0.s -----------------------------------

eebc :                       df_rt_listwait
eebc : 38               [ 2] 	sec
eebd : b0f6             [ 3] 	bcs df_rt_listprocpause
eebf :                       df_rt_listnextvnt
eebf : b1a2             [ 5] 	lda (df_tmpptra),y
eec1 : f003             [ 3] 	beq df_rt_listgotnext
eec3 : c8               [ 2] 	iny
eec4 : d0f9             [ 3] 	bne df_rt_listnextvnt		; Always
eec6 :                       df_rt_listgotnext
                             	; dec vnt #
eec6 : c6a4             [ 5] 	dec df_tmpptrb
                             	; skip past zero terminator
eec8 : c8               [ 2] 	iny
                             	; add this to vnt pointer
eec9 : 18               [ 2] 	clc
eeca : 98               [ 2] 	tya
eecb : 65a2             [ 3] 	adc df_tmpptra
eecd : 85a2             [ 3] 	sta df_tmpptra
                             	_bcc 2
                             
eed1 : e6a3             [ 5] 	inc df_tmpptra+1
eed3 : 4c98ee           [ 3] 	jmp df_rt_listcheckvnt
eed6 :                       df_rt_listpn_done
eed6 : 60               [ 6] 	rts
                             
eed7 :                       df_rt_listproc
                             	; A already contains '_'
eed7 : 8d0004           [ 4] 	sta df_linbuff
eeda : a200             [ 2] 	ldx #0
eedc : a489             [ 3] 	ldy df_exeoff
eede :                       df_rt_listp_copy
eede : c8               [ 2] 	iny
eedf : e8               [ 2] 	inx
eee0 : b187             [ 5] 	lda (df_currlin),y
eee2 : 9d0004           [ 5] 	sta df_linbuff,x
eee5 : 20b4d8           [ 6] 	jsr df_tk_isalphanum
eee8 : b0f4             [ 3] 	bcs df_rt_listp_copy
                             	; zero the line index
eeea : a200             [ 2] 	ldx #0
eeec : 867d             [ 3] 	stx df_linoff
                             	; save runtime pos
eeee : 8489             [ 3] 	sty df_exeoff
                             	; Now try and find in VNT
eef0 : 20d6d6           [ 6] 	jsr df_var_find
eef3 : b036             [ 4] 	bcs df_rt_listp_notfound
                             	; Ok we have got a match in X,A find the proc
eef5 : 868f             [ 3] 	stx df_procptr
eef7 : 8590             [ 3] 	sta df_procptr+1
eef9 : 2002e6           [ 6] 	jsr df_rt_findproc
                             	; Save the line pointer
eefc : 86a2             [ 3] 	stx df_tmpptra
eefe : 85a3             [ 3] 	sta df_tmpptra+1
                             	; save statement index in to line
                             ;	sty df_lineidx
                             ;	; Check if '-' option used
                             ;	ldy df_exeoff
                             ;	lda (df_currlin),y
                             ;	cmp #'-'
                             ;	; if so, list to end of program
                             ;	beq df_rt_listprgend
                             	; Now try and find the end of this procedure
                             	; enddef or another def
AS65 Assembler for R6502 [1.42].                                     Page  243
---------------------------------- bank0.s -----------------------------------

                             	; A,X=Line ptr, Y=line idx
                             ;	ldx df_tmpptra
                             ;	lda df_tmpptra+1
                             ;	ldy df_lineidx
ef00 :                       df_rt_listp_findend
                             	; Go to next stat
ef00 : 20ade5           [ 6] 	jsr df_rt_nextstat
ef03 : b057             [ 3] 	bcs df_rt_listprgend
                             	; save y (a,x in lineptr), A is ok to trample
ef05 : 98               [ 2] 	tya
ef06 : 48               [ 3] 	pha
                             	; find the command
ef07 :                       df_rt_listp_findcmd
ef07 : c8               [ 2] 	iny
ef08 : b191             [ 5] 	lda (df_lineptr),y
ef0a : 10fb             [ 3] 	bpl df_rt_listp_findcmd
                             	; restore y to stat beginning
ef0c : 8538             [ 3] 	sta tmp_d
ef0e : 68               [ 4] 	pla
ef0f : a8               [ 2] 	tay
ef10 : a538             [ 3] 	lda tmp_d
                             	; check A - looking for enddef or def
ef12 : c987             [ 2] 	cmp #DFRT_ENDDEF
ef14 : f00b             [ 3] 	beq df_rt_listp_done
ef16 : c986             [ 2] 	cmp #DFRT_DEF
ef18 : f007             [ 3] 	beq df_rt_listp_done
                             	; if neither then next stat from current
ef1a : a691             [ 3] 	ldx df_lineptr
ef1c : a592             [ 3] 	lda df_lineptr+1
ef1e : 4c00ef           [ 3] 	jmp df_rt_listp_findend
ef21 :                       df_rt_listp_done
                             	; Push end line on to stack
ef21 : a592             [ 3] 	lda df_lineptr+1
ef23 : 48               [ 3] 	pha
ef24 : 8a               [ 2] 	txa
ef25 : 48               [ 3] 	pha
ef26 : a592             [ 3] 	lda df_lineptr+1
ef28 : 4c62ef           [ 3] 	jmp df_rt_list_line
ef2b :                       df_rt_listp_notfound
                             	; Fatal error if proc not found
                             	SWBRK DFERR_NOPROC
                             
                             
                             ; list token
ef2d :                       df_rt_list
ef2d : a900             [ 2] 	lda #0
ef2f : 85aa             [ 3] 	sta df_tmpptre		; Zero means in normal list mode
                             	; find non-ws
ef31 : 2057e6           [ 6] 	jsr df_rt_skip_ws
                             	; if end of statement then no line specifiers
ef34 : 207cee           [ 6] 	jsr df_rt_eos
                             	; so list whole program
ef37 : b01b             [ 3] 	bcs df_rt_listprg
                             
                             	;if '_' then use procnames
ef39 : c95f             [ 2] 	cmp #'_'
ef3b : d003             [ 3] 	bne df_rt_list_all
ef3d : 4cd7ee           [ 3] 	jmp df_rt_listproc
ef40 :                       df_rt_list_all
                             	;if '*' then display all procnames
ef40 : c92a             [ 2] 	cmp #'*'
ef42 : d003             [ 3] 	bne df_rt_list_linno
AS65 Assembler for R6502 [1.42].                                     Page  244
---------------------------------- bank0.s -----------------------------------

ef44 : 4c8cee           [ 3] 	jmp df_rt_listprocnames
ef47 :                       df_rt_list_linno
                             	; else get 1st parameter
ef47 : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; find the starting line number in X,A
ef4a : 204ae0           [ 6] 	jsr df_pg_find_line
                             	; save start in ptra
ef4d : 86a2             [ 3] 	stx df_tmpptra
ef4f : 85a3             [ 3] 	sta df_tmpptra+1
ef51 : 4c5cef           [ 3] 	jmp df_rt_listprgend
                             	; NO ability to choose and ending line number!
                             
                             ; Common listing routine used by LIST and SAVE
                             ; tmpe = 0 means in LIST mode else SAVE mode
                             ; can stop the listing in LIST mode with CTRL-C
ef54 :                       df_rt_listprg
                             	; program start and end as for pointer value
                             	_cpyZPWord df_prgstrt, df_tmpptra
                             
ef5c :                       df_rt_listprgend
ef5c : a569             [ 3] 	lda df_prgend+1
ef5e : 48               [ 3] 	pha
ef5f : a568             [ 3] 	lda df_prgend
ef61 : 48               [ 3] 	pha
ef62 :                       df_rt_list_line
                             	; if line length = 0 then end of program
ef62 : a000             [ 2] 	ldy #0
ef64 : b1a2             [ 5] 	lda (df_tmpptra),y
ef66 : f038             [ 3] 	beq df_rt_list_line_fin
                             	; if in list mode and CTRL-C then also stop
ef68 : a5aa             [ 3] 	lda df_tmpptre
ef6a : d010             [ 3] 	bne df_rt_list_line_cont
                             	; check for break, asynch get
ef6c : 18               [ 2] 	clc
ef6d :                       df_rt_list_synckey
ef6d : a5aa             [ 3] 	lda df_tmpptre					; Ignore keys on save mode
ef6f : d00b             [ 3] 	bne df_rt_list_line_cont
ef71 :                       df_rt_list_pause
ef71 : 202dc4           [ 6] 	jsr io_get_ch
ef74 : c920             [ 2] 	cmp #' '						; Space = PAUSE
ef76 : f0f9             [ 3] 	beq df_rt_list_pause			; C=1 for synchronouse ke
ef78 : c903             [ 2] 	cmp #UTF_ETX					; CTRL-C?
ef7a : f024             [ 3] 	beq df_rt_list_line_fin
ef7c :                       df_rt_list_line_cont
ef7c : a000             [ 2] 	ldy #0
ef7e : 847d             [ 3] 	sty df_linoff
ef80 : 20a3ef           [ 6] 	jsr df_rt_list_all_line
ef83 :                       df_rt_list_next_line
                             	; new line
ef83 : 206bc1           [ 6] 	jsr utilPrintCRLF
                             	; increment pointer to next line
ef86 : 18               [ 2] 	clc
ef87 : a5a2             [ 3] 	lda df_tmpptra
ef89 : a000             [ 2] 	ldy #0
ef8b : 71a2             [ 5] 	adc (df_tmpptra),y
ef8d : 85a2             [ 3] 	sta df_tmpptra
                             	_bcc 2
                             
ef91 : e6a3             [ 5] 	inc df_tmpptra+1
                             	; if pointer > end then listing is done
ef93 : 38               [ 2] 	sec
ef94 : 68               [ 4] 	pla
AS65 Assembler for R6502 [1.42].                                     Page  245
---------------------------------- bank0.s -----------------------------------

ef95 : aa               [ 2] 	tax
ef96 : e5a2             [ 3] 	sbc df_tmpptra
ef98 : 68               [ 4] 	pla
ef99 : 48               [ 3] 	pha
ef9a : e5a3             [ 3] 	sbc df_tmpptra+1
ef9c : 8a               [ 2] 	txa
ef9d : 48               [ 3] 	pha
ef9e : b0c2             [ 3] 	bcs df_rt_list_line
efa0 :                       df_rt_list_line_fin
                             	; if got here then reached tmpb
efa0 : 68               [ 4] 	pla
efa1 : 68               [ 4] 	pla
efa2 :                       df_rt_list_line_only_fin
efa2 : 60               [ 6] 	rts
                             
                             ;Using df_tmpptra as line pointer
                             ;Print decode an entire line
efa3 :                       df_rt_list_all_line				; Start here to include nu
efa3 : 20ddf0           [ 6] 	jsr df_rt_list_linnum
efa6 :                       df_rt_list_line_only			; Start here for just the 
efa6 : a003             [ 2] 	ldy #3
efa8 : b1a2             [ 5] 	lda (df_tmpptra),y
efaa : 8593             [ 3] 	sta df_lineidx
efac : c8               [ 2] 	iny
efad : 847d             [ 3] 	sty df_linoff
efaf :                       df_rt_list_decode
efaf : a47d             [ 3] 	ldy df_linoff
efb1 : b1a2             [ 5] 	lda (df_tmpptra),y
efb3 : 3010             [ 3] 	bmi df_rt_list_token
efb5 : c920             [ 2] 	cmp #DFTK_ESCVAL
efb7 : 9006             [ 3] 	bcc df_rt_list_escval
                             	; normal char just print it
efb9 : 2030c4           [ 6] 	jsr io_put_ch
efbc : 4cc8ef           [ 3] 	jmp df_rt_list_nexttok
efbf :                       df_rt_list_escval
                             	; A and Y need to be valid on entry
efbf : 20e1ef           [ 6] 	jsr df_rt_list_decode_esc
efc2 : 4cc8ef           [ 3] 	jmp df_rt_list_nexttok
efc5 :                       df_rt_list_token
efc5 : 20eef0           [ 6] 	jsr df_rt_list_decode_token
efc8 :                       df_rt_list_nexttok
                             	; advance the line offset
efc8 : e67d             [ 5] 	inc df_linoff
efca : a57d             [ 3] 	lda df_linoff
                             	; check if at end of line
efcc : a200             [ 2] 	ldx #0
efce : c1a2             [ 6] 	cmp (df_tmpptra,x)
efd0 : f0d0             [ 3] 	beq df_rt_list_line_only_fin
                             	; check if at end of statement
efd2 : c593             [ 3] 	cmp df_lineidx
efd4 : d0d9             [ 3] 	bne df_rt_list_decode
efd6 : a8               [ 2] 	tay
                             	; save the next statement offset
efd7 : b1a2             [ 5] 	lda (df_tmpptra),y
efd9 : 8593             [ 3] 	sta df_lineidx
efdb : c8               [ 2] 	iny
efdc : 847d             [ 3] 	sty df_linoff
efde : 4cafef           [ 3] 	jmp df_rt_list_decode
                             
                             
                             ; decode escape sequences
                             ; Input: A contains the esc val and Y is char lin
AS65 Assembler for R6502 [1.42].                                     Page  246
---------------------------------- bank0.s -----------------------------------

efe1 :                       df_rt_list_decode_esc
                             	; jump over esc byte
efe1 : c8               [ 2] 	iny
efe2 : 847d             [ 3] 	sty df_linoff
efe4 : 48               [ 3] 	pha
                             	; get the next two bytes in case needed
efe5 : b1a2             [ 5] 	lda (df_tmpptra),y
efe7 : 85a4             [ 3] 	sta df_tmpptrb
efe9 : c8               [ 2] 	iny
efea : b1a2             [ 5] 	lda (df_tmpptra),y
efec : 85a5             [ 3] 	sta df_tmpptrb+1
efee : 88               [ 2] 	dey				; Y is on byte after esc byte
efef : 68               [ 4] 	pla
                             	; x2 to get jmp offset
eff0 : 0a               [ 2] 	asl a
eff1 : aa               [ 2] 	tax
eff2 : bd4fe7           [ 4] 	lda df_rt_escjmp,x
eff5 : 85a6             [ 3] 	sta df_tmpptrc
eff7 : bd50e7           [ 4] 	lda df_rt_escjmp+1,x
effa : 85a7             [ 3] 	sta df_tmpptrc+1
                             	; now jump to decoder
effc : 6ca600           [ 6] 	jmp (df_tmpptrc)
                             
                             ; reserved
efff :                       df_rt_lst_reserved
efff : 60               [ 6] 	rts
                             
                             ; decode a byte char
f000 :                       df_rt_lst_chr
f000 : a927             [ 2] 	lda #0x27			; Single quote
f002 : 2030c4           [ 6] 	jsr io_put_ch
f005 : a5a4             [ 3] 	lda df_tmpptrb
f007 : 2030c4           [ 6] 	jsr io_put_ch
f00a : a927             [ 2] 	lda #0x27			; Single quote
f00c : 2030c4           [ 6] 	jsr io_put_ch
f00f : c8               [ 2] 	iny
f010 : 847d             [ 3] 	sty df_linoff
f012 : 60               [ 6] 	rts
                             
                             ; Output 0x for hex chars
f013 :                       df_rt_lst_hex_pre
f013 : a930             [ 2] 	lda #'0'
f015 : 2030c4           [ 6] 	jsr io_put_ch
f018 : a978             [ 2] 	lda #'x'
f01a : 4c30c4           [ 3] 	jmp io_put_ch
                             
                             
                             ; Decode a byte hex
f01d :                       df_rt_lst_bythex
f01d : 2013f0           [ 6] 	jsr df_rt_lst_hex_pre
f020 :                       df_rt_lst_lo_hex
f020 : a5a4             [ 3] 	lda df_tmpptrb
f022 : 2088c1           [ 6] 	jsr str_a_to_x
f025 : 2030c4           [ 6] 	jsr io_put_ch
f028 : 8a               [ 2] 	txa
f029 : 2030c4           [ 6] 	jsr io_put_ch
f02c :                       df_rt_lst_const_done
f02c : c8               [ 2] 	iny
f02d : 847d             [ 3] 	sty df_linoff
f02f : 60               [ 6] 	rts
                             
                             ; Decode an int hex
AS65 Assembler for R6502 [1.42].                                     Page  247
---------------------------------- bank0.s -----------------------------------

f030 :                       df_rt_lst_inthex
f030 : 2013f0           [ 6] 	jsr df_rt_lst_hex_pre
f033 : a5a5             [ 3] 	lda df_tmpptrb+1
f035 : 2088c1           [ 6] 	jsr str_a_to_x
f038 : 2030c4           [ 6] 	jsr io_put_ch
f03b : 8a               [ 2] 	txa
f03c : 2030c4           [ 6] 	jsr io_put_ch
f03f : 4c20f0           [ 3] 	jmp df_rt_lst_lo_hex
                             
                             ; Decode a byte binary
f042 :                       df_rt_lst_bytbin
f042 : a5a4             [ 3] 	lda df_tmpptrb
f044 : 85a5             [ 3] 	sta df_tmpptrb+1
f046 : a208             [ 2] 	ldx #8
f048 : d002             [ 3] 	bne df_rt_lst_bin
                             
                             ; Decode a int binary
f04a :                       df_rt_lst_intbin
f04a : a210             [ 2] 	ldx #16
                             	; FALL THROUGH
                             ; Main 01 decoding of binary
f04c :                       df_rt_lst_bin
f04c : a930             [ 2] 	lda #'0'
f04e : 2030c4           [ 6] 	jsr io_put_ch
f051 : a962             [ 2] 	lda #'b'
f053 : 2030c4           [ 6] 	jsr io_put_ch
f056 :                       df_rt_lst_bit
f056 : a930             [ 2] 	lda #'0'
f058 : 06a4             [ 5] 	asl df_tmpptrb
f05a : 26a5             [ 5] 	rol df_tmpptrb+1
f05c : 6900             [ 2] 	adc #0				; If C=1 then '0' becomes '1'
f05e :                       df_rt_lst_bit_skip0
f05e : 2030c4           [ 6] 	jsr io_put_ch
f061 : ca               [ 2] 	dex
f062 : d0f2             [ 3] 	bne df_rt_lst_bit
f064 : f0c6             [ 3] 	beq df_rt_lst_const_done
                             
                             ; Decode a decimal integer
f066 :                       df_rt_lst_intdec
f066 : a6a4             [ 3] 	ldx df_tmpptrb
f068 : a5a5             [ 3] 	lda df_tmpptrb+1
f06a : c8               [ 2] 	iny
f06b : 847d             [ 3] 	sty df_linoff
f06d : 18               [ 2] 	clc
f06e : 4ce8c3           [ 3] 	jmp print_a_to_d
                             
                             
                             ; decode a variable or procedure
                             ; Slot address to decode in ptrb
f071 :                       df_rt_lst_var
f071 :                       df_rt_lst_proc
                             	; jump over the address bytes
f071 : c8               [ 2] 	iny
f072 : 847d             [ 3] 	sty df_linoff
                             
                             	; ptrc starts at VNT start
                             	_cpyZPWord df_vntstrt,df_tmpptrc
                             
                             
                             	; ptrd starts at end of VVT
                             	_cpyZPWord df_vvtend,df_tmpptrd
                             
AS65 Assembler for R6502 [1.42].                                     Page  248
---------------------------------- bank0.s -----------------------------------

f084 : a000             [ 2] 	ldy #0
f086 :                       df_rt_list_findvvt
                             	; Check have we reached target addr in vvt?
f086 : a5a8             [ 3] 	lda df_tmpptrd
f088 : c5a4             [ 3] 	cmp df_tmpptrb
f08a : d006             [ 3] 	bne df_rt_list_vvtend
f08c : a5a9             [ 3] 	lda df_tmpptrd+1
f08e : c5a5             [ 3] 	cmp df_tmpptrb+1
f090 : f021             [ 3] 	beq df_rt_list_gotvvt
f092 :                       df_rt_list_vvtend
f092 : b1a6             [ 5] 	lda (df_tmpptrc),y
f094 : f009             [ 3] 	beq df_rt_list_gotvvtend
                             	_incZPWord df_tmpptrc
                             
f09c : 4c92f0           [ 3] 	jmp df_rt_list_vvtend
f09f :                       df_rt_list_gotvvtend
                             	_incZPWord df_tmpptrc
                             
                             	; move target slot address towards top of mem
f0a5 : 18               [ 2] 	clc
f0a6 : a5a8             [ 3] 	lda df_tmpptrd
f0a8 : 6908             [ 2] 	adc #DFVVT_SZ
f0aa : 85a8             [ 3] 	sta df_tmpptrd
                             	_bcc 2
                             
f0ae : e6a9             [ 5] 	inc df_tmpptrd+1
                             	; go back and check again
f0b0 : 4c86f0           [ 3] 	jmp df_rt_list_findvvt
f0b3 :                       df_rt_list_gotvvt
f0b3 : b1a6             [ 5] 	lda (df_tmpptrc),y
f0b5 : f025             [ 3] 	beq df_rt_list_donvvt
f0b7 : 2030c4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrc
                             
f0c0 : 4cb3f0           [ 3] 	jmp df_rt_list_gotvvt
                             
f0c3 :                       df_rt_lst_strlit
f0c3 : a922             [ 2] 	lda #0x22
f0c5 : 2030c4           [ 6] 	jsr io_put_ch
f0c8 : a47d             [ 3] 	ldy df_linoff
f0ca :                       df_rt_lst_strlitch
f0ca : b1a2             [ 5] 	lda (df_tmpptra),y
f0cc : f007             [ 3] 	beq df_rt_lst_strlitdon
f0ce : 2030c4           [ 6] 	jsr io_put_ch
f0d1 : c8               [ 2] 	iny
f0d2 : 4ccaf0           [ 3] 	jmp df_rt_lst_strlitch
f0d5 :                       df_rt_lst_strlitdon
f0d5 : a922             [ 2] 	lda #0x22
f0d7 : 2030c4           [ 6] 	jsr io_put_ch
f0da : 847d             [ 3] 	sty df_linoff
f0dc :                       df_rt_list_donvvt
f0dc : 60               [ 6] 	rts
                             
f0dd :                       df_rt_list_linnum
f0dd : a001             [ 2] 	ldy #1
f0df : b1a2             [ 5] 	lda (df_tmpptra),y
f0e1 : aa               [ 2] 	tax
f0e2 : c8               [ 2] 	iny
f0e3 : b1a2             [ 5] 	lda (df_tmpptra),y
f0e5 : 18               [ 2] 	clc
f0e6 : 20e8c3           [ 6] 	jsr print_a_to_d
f0e9 : a920             [ 2] 	lda #0x20			; Always add a space after line num
AS65 Assembler for R6502 [1.42].                                     Page  249
---------------------------------- bank0.s -----------------------------------

f0eb : 4c30c4           [ 3] 	jmp io_put_ch
                             
                             ; decode a token value with MSB set
f0ee :                       df_rt_list_decode_token
                             	; if not assembler then normal listing
f0ee : c997             [ 2] 	cmp #DFRT_ASM
f0f0 : d003             [ 3] 	bne df_rt_list_decode_token_normal
f0f2 : 4c2cf1           [ 3] 	jmp df_rt_asm_decode_token
f0f5 :                       df_rt_list_decode_token_normal
f0f5 : 297f             [ 2] 	and #0x7f
                             	; token 0 and 1 don't get decoded they are impli
f0f7 : c902             [ 2] 	cmp #2
f0f9 : b001             [ 3] 	bcs df_rt_list_do_decode_tkn
f0fb : 60               [ 6] 	rts
f0fc :                       df_rt_list_do_decode_tkn
f0fc : aa               [ 2] 	tax
f0fd : a956             [ 2] 	lda #lo(df_tokensyms)
f0ff : 85a4             [ 3] 	sta df_tmpptrb
f101 : a9dc             [ 2] 	lda #hi(df_tokensyms)
f103 : 85a5             [ 3] 	sta df_tmpptrb+1
f105 :                       df_rt_list_find_sym
f105 : 8a               [ 2] 	txa
f106 : f012             [ 3] 	beq df_rt_list_got_sym
f108 : a000             [ 2] 	ldy #0
f10a :                       df_rt_list_next_ch
f10a : b1a4             [ 5] 	lda (df_tmpptrb),y
f10c : 48               [ 3] 	pha
                             	_incZPWord df_tmpptrb
                             
f113 : 68               [ 4] 	pla
f114 : 10f4             [ 3] 	bpl df_rt_list_next_ch
f116 :                       df_rt_list_got_last_sym
                             	; ok got to the last ch
                             	; advance to next sym
f116 : ca               [ 2] 	dex
f117 : 4c05f1           [ 3] 	jmp df_rt_list_find_sym
f11a :                       df_rt_list_got_sym
f11a : a1a4             [ 6] 	lda (df_tmpptrb,x)		; Relies on X=0 from branch
f11c : 08               [ 3] 	php
f11d : 297f             [ 2] 	and #0x7f
f11f : 2030c4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrb
                             
f128 : 28               [ 4] 	plp
f129 : 10ef             [ 3] 	bpl df_rt_list_got_sym
f12b : 60               [ 6] 	rts
                             
                             ;** Decode assembler token in A **
f12c :                       df_rt_asm_decode_token
f12c : e67d             [ 5] 	inc df_linoff		; Point to token after asm token
f12e : a47d             [ 3] 	ldy df_linoff
f130 : b1a2             [ 5] 	lda (df_tmpptra),y	;If token N=1 then keyword
f132 : 300a             [ 3] 	bmi df_rt_asm_decode_token_keyword
f134 : a92e             [ 2] 	lda #'.'			;Put the '.' before escape processing
f136 : 2030c4           [ 6] 	jsr io_put_ch
f139 : b1a2             [ 5] 	lda (df_tmpptra),y	;Get asm token back
f13b : 4ce1ef           [ 3] 	jmp df_rt_list_decode_esc
f13e :                       df_rt_asm_decode_token_keyword
f13e : 297f             [ 2] 	and #0x7f			; Mask off MSB
f140 : aa               [ 2] 	tax					;Put it in to X as the counter
                             	; Point to asm symbol table
f141 : a9ac             [ 2] 	lda #lo(df_asm_tokensyms)
AS65 Assembler for R6502 [1.42].                                     Page  250
---------------------------------- bank0.s -----------------------------------

f143 : 85a4             [ 3] 	sta df_tmpptrb
f145 : a9fd             [ 2] 	lda #hi(df_asm_tokensyms)
f147 : 85a5             [ 3] 	sta df_tmpptrb+1
f149 :                       df_rt_list_find_asm_sym
f149 : 8a               [ 2] 	txa
f14a : f01b             [ 3] 	beq df_rt_list_got_asm_sym
f14c : a000             [ 2] 	ldy #0
f14e :                       df_rt_list_next_asm_ch
                             	_incZPWord df_tmpptrb
                             
f154 : b1a4             [ 5] 	lda (df_tmpptrb),y
f156 : c920             [ 2] 	cmp #' '			; Skip all chars >=' '
f158 : b0f4             [ 3] 	bcs df_rt_list_next_asm_ch
f15a : 38               [ 2] 	sec					; Skip offset and mode bytes
f15b : 65a4             [ 3] 	adc df_tmpptrb
f15d : 85a4             [ 3] 	sta df_tmpptrb
                             	_bcc 2
                             
f161 : e6a5             [ 5] 	inc df_tmpptrb+1
f163 : ca               [ 2] 	dex					; One less symbol to skip over
f164 : 4c49f1           [ 3] 	jmp df_rt_list_find_asm_sym
f167 :                       df_rt_list_got_asm_sym
f167 : a1a4             [ 6] 	lda (df_tmpptrb,x)	; Relies on X=0 from branch
f169 : c920             [ 2] 	cmp #' '
f16b : 900c             [ 3] 	bcc df_rt_asm_decode_token_done
f16d : 2030c4           [ 6] 	jsr io_put_ch
                             	_incZPWord df_tmpptrb
                             
f176 : 4c67f1           [ 3] 	jmp df_rt_list_got_asm_sym
f179 :                       df_rt_asm_decode_token_done
f179 : 60               [ 6] 	rts
                             
                             
f17a :                       df_rt_doke
f17a : 38               [ 2] 	sec
f17b : 24                    	db 0x24	; BIT skip the clc
f17c :                       df_rt_poke
f17c : 18               [ 2] 	clc
f17d : 08               [ 3] 	php
f17e : 20ede4           [ 6] 	jsr df_rt_parm_2ints
f181 : a5a4             [ 3] 	lda df_tmpptrb
f183 : a000             [ 2] 	ldy #0
f185 : 91a2             [ 5] 	sta (df_tmpptra),y
f187 : 28               [ 4] 	plp
f188 : 9005             [ 3] 	bcc df_rt_poke_done
                             	; get high byte to doke
f18a : a5a5             [ 3] 	lda df_tmpptrb+1
f18c : c8               [ 2] 	iny
                             	; poke hi byte
f18d : 91a2             [ 5] 	sta (df_tmpptra),y
f18f :                       df_rt_poke_done
f18f : 60               [ 6] 	rts
                             
f190 :                       df_rt_snd_common
                             	; 3 inputs
                             	; tmpa = channel (1,2,3), tmpb = period, tmpc = 
f190 : a5a2             [ 3] 	lda df_tmpptra
                             	; tone channel addressing is 0 to 2
f192 : 38               [ 2] 	sec
f193 : e901             [ 2] 	sbc #1
f195 : 2903             [ 2] 	and #3
                             	; ok doing a tone channel, get reg index for per
AS65 Assembler for R6502 [1.42].                                     Page  251
---------------------------------- bank0.s -----------------------------------

f197 : 0a               [ 2] 	asl a
f198 : aa               [ 2] 	tax
                             	; get low byte of period
f199 : a5a4             [ 3] 	lda df_tmpptrb
f19b : 206ec0           [ 6] 	jsr snd_set
                             	; increment reg number to high byte
f19e : e8               [ 2] 	inx
                             	; but if now at R7 then it's was noise period
                             	; so then no high period or volume
f19f : e007             [ 2] 	cpx #7
f1a1 : d001             [ 3] 	bne df_rt_not_noise
                             	; else do nothing more
f1a3 : 60               [ 6] 	rts
f1a4 :                       df_rt_not_noise
                              	; get high byte of period
f1a4 : a5a5             [ 3] 	lda df_tmpptrb+1
f1a6 : 290f             [ 2] 	and #0x0f
                             	; set hi period
f1a8 : 206ec0           [ 6] 	jsr snd_set
                             	; get volume register index (8 = channel 1)
f1ab : 18               [ 2] 	clc
f1ac : a5a2             [ 3] 	lda df_tmpptra
f1ae : 2903             [ 2] 	and #3
f1b0 : 6907             [ 2] 	adc #7
f1b2 : aa               [ 2] 	tax
                             	; get volume
f1b3 : a5a6             [ 3] 	lda df_tmpptrc
f1b5 : 290f             [ 2] 	and #0x0f
f1b7 : d002             [ 3] 	bne df_rt_sound_env_skip
                             	; envelope mode
f1b9 : 0910             [ 2] 	ora #0x10
f1bb :                       df_rt_sound_env_skip
f1bb : 4c6ec0           [ 3] 	jmp snd_set
                             
                             ; sound chan,period,volume
f1be :                       df_rt_sound
f1be : 20f8e4           [ 6] 	jsr df_rt_parm_3ints
f1c1 :                       df_rt_dosound
f1c1 : 4c90f1           [ 3] 	jmp df_rt_snd_common
                             
                             ; music chan,octave,note,volume
f1c4 :                       df_rt_music
f1c4 : 200fe5           [ 6] 	jsr df_rt_parm_4ints
                             	; parm 2 = octave, need to x 12word = 24
                             	; get period A,X (hi/lo)
                             	; pass in octave # in X and note # in Y
f1c7 : a6a4             [ 3] 	ldx df_tmpptrb
f1c9 : a4a6             [ 3] 	ldy df_tmpptrc
f1cb : 20d2d5           [ 6] 	jsr snd_get_note
                             	; store note period in b
f1ce : 86a4             [ 3] 	stx df_tmpptrb
f1d0 : 85a5             [ 3] 	sta df_tmpptrb+1
                             	; put vol in tmpc
f1d2 : a5a8             [ 3] 	lda df_tmpptrd
f1d4 : 85a6             [ 3] 	sta df_tmpptrc
                             	; tmpa,b,c contain chan,per,vol
f1d6 : 4cc1f1           [ 3] 	jmp df_rt_dosound
                             
                             
                             ; play tonemask,noisemask,envelope,period
f1d9 :                       df_rt_play
f1d9 : 200fe5           [ 6] 	jsr df_rt_parm_4ints
AS65 Assembler for R6502 [1.42].                                     Page  252
---------------------------------- bank0.s -----------------------------------

                             	; parm 1 = tone enable
f1dc : a5a2             [ 3] 	lda df_tmpptra
f1de : 2907             [ 2] 	and #7
f1e0 : 85a2             [ 3] 	sta df_tmpptra
                             	; parm 2 = noise enable
f1e2 : a5a4             [ 3] 	lda df_tmpptrb
f1e4 : 2907             [ 2] 	and #7
f1e6 : 0a               [ 2] 	asl a
f1e7 : 0a               [ 2] 	asl a
f1e8 : 0a               [ 2] 	asl a
f1e9 : 05a2             [ 3] 	ora df_tmpptra
                             	; we now have bits set for channels to enable
                             	; but need to invert for the 8910
                             	; top 2 bits are 0 and 1 as these are port b (in
f1eb : 497f             [ 2] 	eor #0x7f
                             	; reg 7 is control register
f1ed : a207             [ 2] 	ldx #7
f1ef : 206ec0           [ 6] 	jsr snd_set
                             	; parm 4 = envelope period
                             	; 11 is envelope period register
f1f2 : a20b             [ 2] 	ldx #11
                             	; get low
f1f4 : a5a8             [ 3] 	lda df_tmpptrd
f1f6 : 206ec0           [ 6] 	jsr snd_set
                             	; get high
f1f9 : e8               [ 2] 	inx
f1fa : a5a9             [ 3] 	lda df_tmpptrd+1
f1fc : 206ec0           [ 6] 	jsr snd_set
                             	; parm 3 = envelope mode
f1ff : a5a6             [ 3] 	lda df_tmpptrc
f201 : 290f             [ 2] 	and #0xf
                             	; 13 is envelope shape register
f203 : a20d             [ 2] 	ldx #13
f205 : 4c6ec0           [ 3] 	jmp snd_set
                             
                             ;df_rt_fill
                             ;	jsr df_rt_parm_5ints
                             ;	rts
                             	
                             ;* common filename procesing routine
                             ;* expects s: or t: followed by filename
                             ;* if no device specified then sd card default
f208 :                       df_rt_init_filename
                             	; evaluate string
f208 : 2026e2           [ 6] 	jsr df_rt_neval
f20b : 209ff7           [ 6] 	jsr df_ost_popStr
                             
                             	; save string address
f20e : 86a6             [ 3] 	stx df_tmpptrc
f210 : 85a7             [ 3] 	sta df_tmpptrc+1
                             
                             	; Check first 2 chars of string
                             	; if s: then device = sd card
                             	; if t: then device = tape
f212 : a201             [ 2] 	ldx #1							; Assume SD card i.e. device 1
f214 : ad0006           [ 4] 	lda io_default					; Unless no arduino detected
f217 : 3002             [ 3] 	bmi df_rt_sd_connected
f219 : a200             [ 2] 	ldx #0							; In which case assume tape i.e. de
f21b :                       df_rt_sd_connected
f21b : a001             [ 2] 	ldy #1
f21d : b1a6             [ 5] 	lda (df_tmpptrc),y
f21f : 88               [ 2] 	dey								; Y=0 i.e. assume no s: or t:
AS65 Assembler for R6502 [1.42].                                     Page  253
---------------------------------- bank0.s -----------------------------------

f220 : c93a             [ 2] 	cmp #':'						; if no ':' in pos 1 then default
f222 : d015             [ 3] 	bne df_rt_do_fname
f224 : b1a6             [ 5] 	lda (df_tmpptrc),y				; get first char
f226 : a002             [ 2] 	ldy #2							; filename must start at pos 2
f228 : c973             [ 2] 	cmp #'s'						; if s then still sd card
f22a : d007             [ 3] 	bne df_rt_try_tape
f22c : ad0006           [ 4] 	lda io_default					; But if no sd card then erro
f22f : 1043             [ 3] 	bpl df_rt_file_errc
f231 : 3006             [ 3] 	bmi df_rt_do_fname
f233 :                       df_rt_try_tape
f233 : c974             [ 2] 	cmp #'t'						; MUST be t else an error!
f235 : d03d             [ 3] 	bne df_rt_file_errc
f237 : a200             [ 2] 	ldx #0							; zero for tape
f239 :                       df_rt_do_fname
f239 : 8a               [ 2] 	txa								; Save device number
f23a : 48               [ 3] 	pha
                             	; copy string to fhandle, Y is at start pos of f
f23b : a200             [ 2] 	ldx #0
f23d :                       df_rt_copy_fn
f23d : b1a6             [ 5] 	lda (df_tmpptrc),y
f23f :                       df_rt_fname_case
f23f : 9d0004           [ 5] 	sta df_linbuff,x				; Put filename in line buffe
f242 : c8               [ 2] 	iny
f243 : e8               [ 2] 	inx
f244 : c900             [ 2] 	cmp #0
f246 : d0f5             [ 3] 	bne df_rt_copy_fn
f248 : 68               [ 4] 	pla								; Get device number in A
f249 : 60               [ 6] 	rts
                             
                             ; Delete a file from SD card
                             ; Only valid for SD card
f24a :                       df_rt_delete
f24a : 205af2           [ 6] 	jsr df_rt_parse_file
f24d : c901             [ 2] 	cmp #1
f24f : d023             [ 3] 	bne df_rt_file_errc
f251 : 2087c8           [ 6] 	jsr sd_delete
f254 : 4c04c4           [ 3] 	jmp io_set_default
                             
f257 :                       df_rt_dir
f257 : 4c92c8           [ 3] 	jmp sd_dir
                             
                             ;* common file parsing routine
                             ;* sets tp_print flag for interactive mode or not
f25a :                       df_rt_parse_file
                             	; if line number is zero then interactive mode..
f25a : a280             [ 2] 	ldx #0x80						; Assume interactive mode i.e. pr
f25c : a001             [ 2] 	ldy #DFTK_LINNUM				; Check the line number
f25e : b187             [ 5] 	lda (df_currlin),y
f260 : c8               [ 2] 	iny
f261 : 1187             [ 5] 	ora (df_currlin),y
f263 : d002             [ 3] 	bne df_rt_parse_file_print		; If not zero then n
f265 : a200             [ 2] 	ldx #0x00						; Ok must be running mode i.e no 
f267 :                       df_rt_parse_file_print
f267 : 865b             [ 3] 	stx tp_print					; Save the print flag for file 
                             	; now process filename
f269 : 2008f2           [ 6] 	jsr df_rt_init_filename
                             	; sub device number is in A (0=tape, 1=sdcard)
f26c : 48               [ 3] 	pha								; Save sub-device number
f26d : a900             [ 2] 	lda #0							; Always 0 for file device
f26f : 2007c4           [ 6] 	jsr io_active_device
f272 : 68               [ 4] 	pla								; Exit with device number found
f273 : 60               [ 6] 	rts
AS65 Assembler for R6502 [1.42].                                     Page  254
---------------------------------- bank0.s -----------------------------------

f274 :                       df_rt_file_errc
                             	SWBRK DFERR_FNAME
                             
                             
                             ; save "file" as text
f276 :                       df_rt_tsave
f276 : 205af2           [ 6] 	jsr df_rt_parse_file
f279 : 2036c4           [ 6] 	jsr io_open_write
f27c : b0f6             [ 3] 	bcs df_rt_file_errc
                             	; ok now have redirected output to device
                             	; go and list the program in save mode
f27e : a901             [ 2] 	lda #1
f280 : 85aa             [ 3] 	sta df_tmpptre
f282 : 2054ef           [ 6] 	jsr df_rt_listprg
                             	; final CR to end the save
f285 : a90d             [ 2] 	lda #UTF_CR
f287 : 2030c4           [ 6] 	jsr io_put_ch
f28a :                       df_rt_file_cleanup
                             	; close the file
f28a : 2039c4           [ 6] 	jsr io_close
                             	; restore to default device io
f28d : 4c04c4           [ 3] 	jmp io_set_default
                             
                             
                             ; load "file" from text
f290 :                       df_rt_tload
f290 : 205af2           [ 6] 	jsr df_rt_parse_file
f293 : 2033c4           [ 6] 	jsr io_open_read
f296 : b0dc             [ 3] 	bcs df_rt_file_errc
                             	; no echo - very important
                             	; else might try and write to a device
                             	; only open for reading (i.e. SD CARD)
f298 :                       df_rt_loadline
f298 : 18               [ 2] 	clc					; NO ECHO!
f299 : 2000e1           [ 6] 	jsr df_pg_inputline
                             	; if C clear then tokenise line
f29c : 9012             [ 3] 	bcc df_rt_ldtokenise
f29e : 208af2           [ 6] 	jsr df_rt_file_cleanup	; Ok now close file
                             	; df_tokbuff contains the last line loaded, use 
                             	; to decide it autostart is needed or not
f2a1 : ad8404           [ 4] 	lda df_tokbuff+4		; Check the first token in the
f2a4 : 1007             [ 3] 	bpl df_rt_no_autostart	; If less than 0x80 then 
f2a6 : c986             [ 2] 	cmp #DFRT_DEF			; Must be less than the def keyw
f2a8 : b003             [ 3] 	bcs df_rt_no_autostart
f2aa : 4c3de1           [ 3] 	jmp df_pg_runcommand
f2ad :                       df_rt_no_autostart
                             	; Back to the ready prompt when done (resets the
f2ad : 4c12e1           [ 3] 	jmp df_pg_dflat
                             
f2b0 :                       df_rt_ldtokenise
f2b0 : 2051e1           [ 6] 	jsr df_pg_tokenise		; Tokenise loaded string
f2b3 : 4c98f2           [ 3] 	jmp df_rt_loadline		; Continue with next until b
                             
                             ; Utility to open in binary mode save
f2b6 :                       df_rt_openforbinsave
f2b6 : 205af2           [ 6] 	jsr df_rt_parse_file
f2b9 : 2042c4           [ 6] 	jsr io_open_ext2		; Ext2 is binary file save
f2bc : b0b6             [ 3] 	bcs df_rt_file_errc
f2be : 60               [ 6] 	rts
                             
                             ; Utility to open in binary mode load
f2bf :                       df_rt_openforbinload
AS65 Assembler for R6502 [1.42].                                     Page  255
---------------------------------- bank0.s -----------------------------------

                             	; Get filename and open file for binary read
f2bf : 205af2           [ 6] 	jsr df_rt_parse_file
f2c2 : 203fc4           [ 6] 	jsr io_open_ext1		; Ext1 is binary file read
f2c5 : b0ad             [ 3] 	bcs df_rt_file_errc
f2c7 : 60               [ 6] 	rts
                             
                             ; bload addr,"file"
f2c8 :                       df_rt_bload
                             	; Get address but keep on stack
f2c8 : e689             [ 5] 	inc df_exeoff
f2ca : 2026e2           [ 6] 	jsr df_rt_neval
                             
                             	; Get filename and open file for binary read
f2cd : e689             [ 5] 	inc df_exeoff
f2cf : 20bff2           [ 6] 	jsr df_rt_openforbinload
                             
                             	; Get address from stack in to ptra
f2d2 : 209bf7           [ 6] 	jsr df_ost_popInt
f2d5 : 86a2             [ 3] 	stx df_tmpptra
f2d7 : 85a3             [ 3] 	sta df_tmpptra+1
                             
                             	; Get file address to X,Y
f2d9 : 202dc4           [ 6] 	jsr io_get_ch
f2dc : aa               [ 2] 	tax
f2dd : 202dc4           [ 6] 	jsr io_get_ch
f2e0 : a8               [ 2] 	tay
                             
                             	; Check if user address is zero
f2e1 : a5a2             [ 3] 	lda df_tmpptra
f2e3 : 05a3             [ 3] 	ora df_tmpptra+1
f2e5 : d004             [ 3] 	bne df_rt_bload_addr
                             	; If it is zero then use address from file
f2e7 : 86a2             [ 3] 	stx df_tmpptra
f2e9 : 84a3             [ 3] 	sty df_tmpptra+1
f2eb :                       df_rt_bload_addr
                             	; Get file length
f2eb : 202dc4           [ 6] 	jsr io_get_ch
f2ee : 85a4             [ 3] 	sta df_tmpptrb
f2f0 : 202dc4           [ 6] 	jsr io_get_ch
f2f3 : 85a5             [ 3] 	sta df_tmpptrb+1
                             
                             	; Go and load the bytes
f2f5 : 201cf3           [ 6] 	jsr df_rt_loadbin
                             	; Close the file
f2f8 : 4c8af2           [ 3] 	jmp df_rt_file_cleanup
                             
                             ; Save a binary file
                             ; addr,length,fname
f2fb :                       df_rt_bsave
                             	; Get source address and length but leave on sta
                             	; evaluate 1st parm
f2fb : 2026e2           [ 6] 	jsr df_rt_neval
                             	; jump over comma
f2fe : e689             [ 5] 	inc df_exeoff
                             	; evaluate the 2nd parm
f300 : 2026e2           [ 6] 	jsr df_rt_neval
                             
                             	; Process file and open for binary save
f303 : e689             [ 5] 	inc df_exeoff
f305 : 20b6f2           [ 6] 	jsr df_rt_openforbinsave
                             
                             	; Get length in to ptrb
AS65 Assembler for R6502 [1.42].                                     Page  256
---------------------------------- bank0.s -----------------------------------

f308 : 209bf7           [ 6] 	jsr df_ost_popInt
f30b : 86a4             [ 3] 	stx df_tmpptrb
f30d : 85a5             [ 3] 	sta df_tmpptrb+1
                             
                             	; Get address in to ptra
f30f : 209bf7           [ 6] 	jsr df_ost_popInt
f312 : 86a2             [ 3] 	stx df_tmpptra
f314 : 85a3             [ 3] 	sta df_tmpptra+1
                             
                             	; now save bytes
f316 : 202ef3           [ 6] 	jsr df_rt_savebin
                             	; Close the file
f319 : 4c8af2           [ 3] 	jmp df_rt_file_cleanup
                             
                             
                             ; save dflat tokenised program as binary
                             ;df_rt_save
                             ;	; Process file and open for binary save
                             ;	jsr df_rt_openforbinsave
                             ;
                             ;	; first save zero page stuff
                             ;	; ok this saves a bit more than needed
                             ;	; but it's no biggie and doesn't
                             ;	; clobber temp space
                             ;	lda #lo(dflat_zp_save_s)
                             ;	sta df_tmpptra
                             ;	lda #hi(dflat_zp_save_s)
                             ;	sta df_tmpptra+1
                             ;	; save length
                             ;	sec
                             ;	lda #lo(dflat_zp_save_e)
                             ;	sbc #lo(dflat_zp_save_s)
                             ;	sta df_tmpptrb
                             ;	lda #hi(dflat_zp_save_e)
                             ;	sbc #hi(dflat_zp_save_s)
                             ;	sta df_tmpptrb+1
                             ;	; now save bytes
                             ;	jsr df_rt_savebin
                             ;
                             ;	; now save the dflat program
                             ;	lda df_prgstrt
                             ;	sta df_tmpptra
                             ;	lda df_prgstrt+1
                             ;	sta df_tmpptra+1
                             ;	; save length
                             ;	sec
                             ;	lda df_prgend
                             ;	sbc df_prgstrt
                             ;	sta df_tmpptrb
                             ;	lda df_prgend+1
                             ;	sbc df_prgstrt+1
                             ;	sta df_tmpptrb+1
                             ;	; now save bytes
                             ;	jsr df_rt_savebin
                             ;
                             ;	; now save the variables VVT and VNT
                             ;	lda df_vntstrt
                             ;	sta df_tmpptra
                             ;	lda df_vntstrt+1
                             ;	sta df_tmpptra+1
                             ;	; save length
                             ;	sec
AS65 Assembler for R6502 [1.42].                                     Page  257
---------------------------------- bank0.s -----------------------------------

                             ;	lda df_vvtstrt
                             ;	sbc df_vntstrt
                             ;	sta df_tmpptrb
                             ;	lda df_vvtstrt+1
                             ;	sbc df_vntstrt+1
                             ;	sta df_tmpptrb+1
                             ;	; now save bytes
                             ;	jsr df_rt_savebin
                             ;
                             ;	; close the file
                             ;	jsr io_close
                             ;	clc
                             ;	; Close the file
                             ;	jmp df_rt_file_cleanup
                             
                             
                             ; load dflat tokenised program as binary
                             ;df_rt_load
                             ;	jsr df_rt_openforbinload
                             ;
                             ;	; Get zero page header
                             ;	jsr df_rt_getbin_parms
                             ;	; and get bytes
                             ;	jsr df_rt_loadbin
                             ;
                             ;	; Get program header
                             ;	jsr df_rt_getbin_parms
                             ;	; and get bytes
                             ;	jsr df_rt_loadbin
                             ;
                             ;	; Get variables header
                             ;	jsr df_rt_getbin_parms
                             ;	; and get bytes
                             ;	jsr df_rt_loadbin
                             ;
                             ;	; close the file
                             ;	jsr io_close
                             ;	clc
                             ;	; Close the file
                             ;	jmp df_rt_file_cleanup
                             ;
                             
                             ; Utility to get 4 parms from binary header
                             ;df_rt_getbin_parms
                             ;	ldx #0
                             ;df_rt_getbin_parms_loop
                             ;	jsr io_get_ch
                             ;	sta df_tmpptra,x
                             ;	inx
                             ;	cpx #4
                             ;	bne df_rt_getbin_parms_loop
                             ;	rts
                             
                             ; Utility to load a bin file in address ptra
                             ; Length in ptr b
f31c :                       df_rt_loadbin
                             	; Now load all bytes
f31c : a000             [ 2] 	ldy #0
f31e :                       df_rt_loadbin_byte
                             	; Get a byte from tape
f31e : 202dc4           [ 6] 	jsr io_get_ch
                             	; Save it to destination
AS65 Assembler for R6502 [1.42].                                     Page  258
---------------------------------- bank0.s -----------------------------------

f321 : 91a2             [ 5] 	sta (df_tmpptra),y
                             	; Increment destination
f323 : c8               [ 2] 	iny
f324 : d002             [ 3] 	bne df_rt_loadbin_inc
f326 : e6a3             [ 5] 	inc df_tmpptra+1
f328 :                       df_rt_loadbin_inc
                             	; Decrement length remaining
f328 : 204cf3           [ 6] 	jsr df_rt_dec_binlen
                             	; Not done, do another byte
f32b : d0f1             [ 3] 	bne df_rt_loadbin_byte
                             	; Yes the close the file
f32d : 60               [ 6] 	rts
                             
                             ; Utility to save a bin file from address ptra
                             ; Length in ptr b
f32e :                       df_rt_savebin
                             	; Save dest and length to tape
f32e : a200             [ 2] 	ldx #0
f330 :                       df_rt_bsave_parms
f330 : b5a2             [ 4] 	lda df_tmpptra,x
f332 : 2030c4           [ 6] 	jsr io_put_ch
f335 : e8               [ 2] 	inx
f336 : e004             [ 2] 	cpx #4
f338 : d0f6             [ 3] 	bne df_rt_bsave_parms
                             
                             	; Now save all bytes
f33a : a000             [ 2] 	ldy #0
f33c :                       df_rt_savebin_byte
                             	; Get byte from memory
f33c : b1a2             [ 5] 	lda (df_tmpptra),y
                             	; Put byte to tape
f33e : 2030c4           [ 6] 	jsr io_put_ch
                             	; Increment destination
f341 : c8               [ 2] 	iny
f342 : d002             [ 3] 	bne df_rt_savebin_inc
f344 : e6a3             [ 5] 	inc df_tmpptra+1
f346 :                       df_rt_savebin_inc
                             	; Decrement length remaining
f346 : 204cf3           [ 6] 	jsr df_rt_dec_binlen
                             	; Not done, do another byte
f349 : d0f1             [ 3] 	bne df_rt_savebin_byte
f34b : 60               [ 6] 	rts
                             
                             ; Decrement length in ptrb
f34c :                       df_rt_dec_binlen
                             	; Decrement length remaining
f34c : a5a4             [ 3] 	lda df_tmpptrb
f34e : d002             [ 3] 	bne df_rt_binlen_skip
f350 : c6a5             [ 5] 	dec df_tmpptrb+1
f352 :                       df_rt_binlen_skip
f352 : c6a4             [ 5] 	dec df_tmpptrb
                             	; Reached zero?
f354 : a5a4             [ 3] 	lda df_tmpptrb
f356 : 05a5             [ 3] 	ora df_tmpptrb+1
f358 : 60               [ 6] 	rts
                             
                             
                             ; reset var
f359 :                       df_rt_reset
                             	; now get lvar X,A from current statement
f359 : 2064e6           [ 6] 	jsr df_rt_getlvar
                             	; save lvar in tmpb, vvt ptr in tmpa
AS65 Assembler for R6502 [1.42].                                     Page  259
---------------------------------- bank0.s -----------------------------------

f35c : 86a4             [ 3] 	stx df_tmpptrb
f35e : 85a5             [ 3] 	sta df_tmpptrb+1
                             	; load the vdp count as the reset value of timer
                             	; turn off interrupts while reading vdp lo,hi
f360 : a000             [ 2] 	ldy #0	; This is in readiness to read high byte 
                             	; clear interrupts to access 3 byte vdp counter 
f362 : 78               [ 2] 	sei
f363 : a508             [ 3] 	lda vdp_cnt
f365 : 91a4             [ 5] 	sta (df_tmpptrb),y
f367 : a509             [ 3] 	lda vdp_cnt+1
f369 : c8               [ 2] 	iny
f36a : 91a4             [ 5] 	sta (df_tmpptrb),y
                             	; restore interrupts asap
f36c : 58               [ 2] 	cli
f36d : 60               [ 6] 	rts
                             
                             ;***** FUNCTIONS *****
                             
f36e :                       df_rt_deek
f36e : 38               [ 2] 	sec
f36f : 24                    	db 0x24	; BIT skip the clc
f370 :                       df_rt_peek
f370 : 18               [ 2] 	clc
f371 :                       df_rt_readbyte
f371 : 08               [ 3] 	php
                             ;	inc df_exeoff
f372 : 2020e2           [ 6] 	jsr df_rt_getnval
f375 : 86a2             [ 3] 	stx df_tmpptra
f377 : 85a3             [ 3] 	sta df_tmpptra+1
f379 : a000             [ 2] 	ldy #0
f37b : b1a2             [ 5] 	lda (df_tmpptra),y
f37d : aa               [ 2] 	tax
f37e : a900             [ 2] 	lda #0
f380 : 28               [ 4] 	plp
f381 : 9003             [ 3] 	bcc df_rt_readbyte_skip
f383 : c8               [ 2] 	iny
f384 : b1a2             [ 5] 	lda (df_tmpptra),y
f386 :                       df_rt_readbyte_skip
f386 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
                             ; Random number generator
                             ; rnd(0) = get next number
                             ; rnd(>0) = set seed
f389 :                       df_rt_rnd
                             ;	inc df_exeoff
f389 : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; if input is 0 then generate next random number
f38c : e000             [ 2] 	cpx #0
f38e : d014             [ 3] 	bne df_rt_rnd_set
f390 : c900             [ 2] 	cmp #0
f392 : d010             [ 3] 	bne df_rt_rnd_set
                             	; generate next number
f394 : a599             [ 3] 	lda df_rnd+1
f396 : 4a               [ 2] 	lsr a
f397 : 2698             [ 5] 	rol df_rnd
f399 : 9002             [ 3] 	bcc df_rt_rnd_noeor
f39b : 49b4             [ 2] 	eor #0xb4
f39d :                       df_rt_rnd_noeor
f39d : 8599             [ 3] 	sta df_rnd+1
f39f : 4598             [ 3] 	eor df_rnd
f3a1 : 4c6ff7           [ 3] 	jmp df_ost_pushIntA
                             	; else set the seed to that number and done
AS65 Assembler for R6502 [1.42].                                     Page  260
---------------------------------- bank0.s -----------------------------------

f3a4 :                       df_rt_rnd_set
f3a4 : 8698             [ 3] 	stx df_rnd
f3a6 : 8599             [ 3] 	sta df_rnd+1
f3a8 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
                             
                             ;* Return memory footprint as follows:
                             ;* 0	Return free memory (start of vnt - end of he
                             ;* 1	Return program size (end of prg - start of p
                             ;* 2	Return size of vars (end of vvt - start of v
f3ab :                       df_rt_mem
                             ;	inc df_exeoff
f3ab : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used
f3ae : e001             [ 2] 	cpx #1
f3b0 : f017             [ 3] 	beq df_rt_mem_prg
f3b2 : e002             [ 2] 	cpx #2
f3b4 : f026             [ 3] 	beq df_rt_mem_var
                             	; default is free memory
f3b6 :                       df_rt_mem_free
                             	_cpyZPWord df_vntstrt,df_tmpptra
                             
                             	_cpyZPWord df_starend,df_tmpptrb
                             
f3c6 : 4cecf3           [ 3] 	jmp df_rt_mem_calc
f3c9 :                       df_rt_mem_prg
                             	_cpyZPWord df_prgend,df_tmpptra
                             
                             	_cpyZPWord df_prgstrt,df_tmpptrb
                             
f3d9 : 4cecf3           [ 3] 	jmp df_rt_mem_calc
f3dc :                       df_rt_mem_var
                             	_cpyZPWord df_vvtend,df_tmpptra
                             
                             	_cpyZPWord df_vntstrt,df_tmpptrb
                             
f3ec :                       df_rt_mem_calc
                             	; tmpa-tmpb result in X,A
f3ec : 38               [ 2] 	sec
f3ed : a5a2             [ 3] 	lda df_tmpptra
f3ef : e5a4             [ 3] 	sbc df_tmpptrb
f3f1 : aa               [ 2] 	tax
f3f2 : a5a3             [ 3] 	lda df_tmpptra+1
f3f4 : e5a5             [ 3] 	sbc df_tmpptrb+1
f3f6 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
                             ;* a=stick()
                             ;* returns bit condition of joystick positions
                             ;* no actual joystick support so this is
                             ;* Check for fire | down | up | right | left
                             ;*        bit  4     3      2     1       0
f3f9 :                       df_rt_stick
                             ;	inc df_exeoff
f3f9 : 20e2c8           [ 6] 	jsr kb_stick				; Get pos in to A
f3fc : 4c6ff7           [ 3] 	jmp df_ost_pushIntA
                             
                             ; k=get(sync) sync>=1 means sync
f3ff :                       df_rt_get
                             ;	inc df_exeoff
f3ff : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; only low byte is used, check for sync or async
                             	; c=0 if x<1 else x>=1 makes c=1
AS65 Assembler for R6502 [1.42].                                     Page  261
---------------------------------- bank0.s -----------------------------------

f402 : e001             [ 2] 	cpx #1
f404 :                       df_rt_get_sync
f404 : 08               [ 3] 	php
f405 : 202dc4           [ 6] 	jsr io_get_ch				; Return in A, C=0 is good
f408 : 9005             [ 3] 	bcc df_rt_get_pushp			; Push A (and do plp)
f40a : 28               [ 4] 	plp
f40b : b0f7             [ 3] 	bcs df_rt_get_sync			; If sync then check again
f40d : 9001             [ 3] 	bcc df_rt_get_push			; Else push zero (no plp)
f40f :                       df_rt_get_pushp
f40f : 28               [ 4] 	plp
f410 :                       df_rt_get_push
f410 : 4c6ff7           [ 3] 	jmp df_ost_pushIntA
                             
                             ; s = scrn(x,y)
f413 :                       df_rt_scrn
                             ;	inc df_exeoff
f413 : 20ede4           [ 6] 	jsr df_rt_parm_2ints
f416 : a4a2             [ 3] 	ldy df_tmpptra			; Y is the x coord!
f418 : a6a4             [ 3] 	ldx df_tmpptrb			; X is the y coord!
f41a : 20b7cf           [ 6] 	jsr gr_get
f41d : 4c6ff7           [ 3] 	jmp df_ost_pushIntA
                             
                             ; p = pixel(x,y)
f420 :                       df_rt_pixel
                             ;	inc df_exeoff
f420 : 20ede4           [ 6] 	jsr df_rt_parm_2ints
f423 : a6a2             [ 3] 	ldx df_tmpptra
f425 : a4a4             [ 3] 	ldy df_tmpptrb
f427 : 201fd2           [ 6] 	jsr gr_pixel
f42a : 4c6ff7           [ 3] 	jmp df_ost_pushIntA
                             
                             
                             ; e=elapsed(var)
f42d :                       df_rt_elapsed
                             	; now get lvar X,A from current statement
f42d : 2064e6           [ 6] 	jsr df_rt_getlvar
f430 : e689             [ 5] 	inc df_exeoff
                             	; save lvar in tmpb, vvt ptr in tmpa
f432 : 86a4             [ 3] 	stx df_tmpptrb
f434 : 85a5             [ 3] 	sta df_tmpptrb+1
                             	; subtract vdp counter from value
                             	; turn off interrupts while reading vdp lo,hi
f436 : a000             [ 2] 	ldy #0	; This is in readiness to read high byte 
f438 : 38               [ 2] 	sec
                             	; disable interrupts to access vdp counter
f439 : 78               [ 2] 	sei
f43a : a508             [ 3] 	lda vdp_cnt
f43c : f1a4             [ 5] 	sbc (df_tmpptrb),y
f43e : aa               [ 2] 	tax
f43f : a509             [ 3] 	lda vdp_cnt+1
                             	; restore interrupts asap
f441 : 58               [ 2] 	cli
f442 : c8               [ 2] 	iny
f443 : f1a4             [ 5] 	sbc (df_tmpptrb),y
f445 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
f448 :                       df_rt_call
                             ;	inc df_exeoff
f448 : 200fe5           [ 6] 	jsr df_rt_parm_4ints
f44b : a5a4             [ 3] 	lda df_tmpptrb				; load A
f44d : a6a6             [ 3] 	ldx	df_tmpptrc				; load X
f44f : a4a8             [ 3] 	ldy df_tmpptrd				; load Y
AS65 Assembler for R6502 [1.42].                                     Page  262
---------------------------------- bank0.s -----------------------------------

f451 : 2057f4           [ 6] 	jsr df_rt_calljsr
f454 :                       df_rt_push_int1
f454 : 4c6bf7           [ 3] 	jmp df_ost_pushInt			; A,X pair is return value
f457 :                       df_rt_calljsr
f457 : 6ca200           [ 6] 	jmp (df_tmpptra)			; tmpptra is address, return 
                             
f45a :                       df_rt_sgn
                             ;	inc df_exeoff
f45a : 2020e2           [ 6] 	jsr df_rt_getnval
f45d : 86a2             [ 3] 	stx df_tmpptra
f45f : 05a2             [ 3] 	ora df_tmpptra
f461 : f00f             [ 3] 	beq df_rt_sgn_z
f463 : 2980             [ 2] 	and #0x80
f465 : d006             [ 3] 	bne df_rt_sgn_n
f467 : a201             [ 2] 	ldx #1
f469 : a900             [ 2] 	lda #0
f46b : f0e7             [ 3] 	beq df_rt_push_int1			; Always
f46d :                       df_rt_sgn_n
f46d : a2ff             [ 2] 	ldx #0xff
f46f : 8a               [ 2] 	txa
f470 : d0e2             [ 3] 	bne df_rt_push_int1			; Always
f472 :                       df_rt_sgn_z
f472 : a200             [ 2] 	ldx #0
f474 : 8a               [ 2] 	txa
f475 : f0dd             [ 3] 	beq df_rt_push_int1			; Always
                             
                             ; addr(X)
f477 :                       df_rt_addr
                             	; get lvar X,A from current statement
f477 : 2064e6           [ 6] 	jsr df_rt_getlvar
f47a : e689             [ 5] 	inc df_exeoff
f47c : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
                             ; string length calculator
                             ; X,A = source
                             ; A = length not including zero
f47f :                       df_rt_strlen_common
f47f : 86a2             [ 3] 	stx df_tmpptra
f481 : 85a3             [ 3] 	sta df_tmpptra+1
f483 : a0ff             [ 2] 	ldy #0xff
f485 :                       df_rt_strlen_count
f485 : c8               [ 2] 	iny
f486 : b1a2             [ 5] 	lda (df_tmpptra),y
f488 : d0fb             [ 3] 	bne df_rt_strlen_count
f48a : 98               [ 2] 	tya
f48b : 60               [ 6] 	rts
                             
                             
                             ; common routine to extract a string
                             ; tmpa = source string
                             ; tmpb = dest string
                             ; tmpc = start pos
                             ; tmpd = endpos
f48c :                       df_rt_str_extract
                             	; source string
f48c : 209ff7           [ 6] 	jsr df_ost_popStr
f48f : 86a2             [ 3] 	stx df_tmpptra
f491 : 85a3             [ 3] 	sta df_tmpptra+1
                             	; destination is string accumulator
f493 : a57b             [ 3] 	lda df_sevalptr
f495 : 85a4             [ 3] 	sta df_tmpptrb
f497 : a57c             [ 3] 	lda df_sevalptr+1
AS65 Assembler for R6502 [1.42].                                     Page  263
---------------------------------- bank0.s -----------------------------------

f499 : 85a5             [ 3] 	sta df_tmpptrb+1
                             	; start pos
f49b : a4a6             [ 3] 	ldy df_tmpptrc
f49d : a200             [ 2] 	ldx #0
f49f :                       df_rt_str_cpy_ch
f49f : c4a8             [ 3] 	cpy df_tmpptrd
f4a1 : f011             [ 3] 	beq df_str_src_end
f4a3 : b1a2             [ 5] 	lda (df_tmpptra),y
f4a5 : f00d             [ 3] 	beq df_str_src_end
f4a7 : 81a4             [ 6] 	sta (df_tmpptrb,x)
                             	_incZPWord df_tmpptrb
                             
f4af : c8               [ 2] 	iny
f4b0 : d0ed             [ 3] 	bne df_rt_str_cpy_ch
                             	SWBRK DFERR_STRLONG
                             
f4b4 :                       df_str_src_end
f4b4 : a900             [ 2] 	lda #0
f4b6 : 81a4             [ 6] 	sta (df_tmpptrb,x)
f4b8 : a67b             [ 3] 	ldx df_sevalptr
f4ba : a57c             [ 3] 	lda df_sevalptr+1
f4bc : 4c76f7           [ 3] 	jmp df_ost_pushStr
                             
                             ; $c = chr(x)
f4bf :                       df_rt_chr
                             ;	inc df_exeoff
                             	; get char in X
f4bf : 2020e2           [ 6] 	jsr df_rt_getnval
f4c2 : a000             [ 2] 	ldy #0
                             	; transfer lo byte to A
f4c4 : 8a               [ 2] 	txa
f4c5 : 917b             [ 5] 	sta (df_sevalptr),y
f4c7 : c8               [ 2] 	iny
                             	; zero terminator
f4c8 : a900             [ 2] 	lda #0
f4ca : 917b             [ 5] 	sta (df_sevalptr),y
                             	; point to seval scratch area
f4cc : a67b             [ 3] 	ldx df_sevalptr
f4ce : a57c             [ 3] 	lda df_sevalptr+1
f4d0 : 4c76f7           [ 3] 	jmp df_ost_pushStr
                             
                             ; $c = hex(x)
f4d3 :                       df_rt_hex
                             ;	inc df_exeoff
                             	; create hex digits
f4d3 : 2020e2           [ 6] 	jsr df_rt_getnval
f4d6 : 85a2             [ 3] 	sta df_tmpptra	; Save the high byte
f4d8 : 8a               [ 2] 	txa				; Convert low byte first
f4d9 : 2088c1           [ 6] 	jsr str_a_to_x	; Hex digits in A,X
f4dc : 85a4             [ 3] 	sta df_tmpptrb
f4de : 8a               [ 2] 	txa				; Push low digit of low byte from X
f4df : 48               [ 3] 	pha
f4e0 : a5a4             [ 3] 	lda df_tmpptrb	; Get A back from temp
f4e2 : 48               [ 3] 	pha				; Push high digit of low byte
f4e3 : a5a2             [ 3] 	lda df_tmpptra	; Get the high byte
f4e5 : 2088c1           [ 6] 	jsr str_a_to_x	; Hex digits in A,X
                             	; create string
f4e8 : a000             [ 2] 	ldy #0			; Index in to string temp area
                             	; hi/hi
f4ea : 917b             [ 5] 	sta (df_sevalptr),y
f4ec : c8               [ 2] 	iny
                             	; hi/lo
AS65 Assembler for R6502 [1.42].                                     Page  264
---------------------------------- bank0.s -----------------------------------

f4ed : 8a               [ 2] 	txa
f4ee : 917b             [ 5] 	sta (df_sevalptr),y
f4f0 : c8               [ 2] 	iny
                             	; lo/hi
f4f1 : 68               [ 4] 	pla
f4f2 : 917b             [ 5] 	sta (df_sevalptr),y
f4f4 : c8               [ 2] 	iny
                             	; lo/lo
f4f5 : 68               [ 4] 	pla
f4f6 : 917b             [ 5] 	sta (df_sevalptr),y
f4f8 : c8               [ 2] 	iny
                             	; zero terminator
f4f9 : a900             [ 2] 	lda #0
f4fb : 917b             [ 5] 	sta (df_sevalptr),y
                             	; point to seval scratch area
f4fd : a67b             [ 3] 	ldx df_sevalptr
f4ff : a57c             [ 3] 	lda df_sevalptr+1
f501 : 4c76f7           [ 3] 	jmp df_ost_pushStr
                             
                             ; $c = dec(x)
f504 :                       df_rt_dec
                             ;	inc df_exeoff
                             	; create dec digits
f504 : 2020e2           [ 6] 	jsr df_rt_getnval
f507 : 209ec3           [ 6] 	jsr int_to_str
                             	; point to num_buf scratch area
f50a : a24d             [ 2] 	ldx #lo(num_buf)
f50c : a900             [ 2] 	lda #hi(num_buf)
f50e : 4c76f7           [ 3] 	jmp df_ost_pushStr
                             
                             
                             ; $l = left($s, x)
f511 :                       df_rt_left
                             ;	inc df_exeoff
                             
                             	; first get the string to act on
                             	; point to string accumulator
f511 : 20e0e2           [ 6] 	jsr df_rt_seval
                             	; now get the num of chars
f514 : e689             [ 5] 	inc df_exeoff
f516 : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; number of chars to extract
f519 : 86a8             [ 3] 	stx df_tmpptrd
                             	; start position
f51b : a000             [ 2] 	ldy #0
f51d : 84a6             [ 3] 	sty df_tmpptrc
f51f : 4c8cf4           [ 3] 	jmp df_rt_str_extract
                             
                             ; $r = right($s, x)
f522 :                       df_rt_right
                             ;	inc df_exeoff
                             	; first get the string to act on
                             	; point to string accumulator
f522 : 20e0e2           [ 6] 	jsr df_rt_seval
                             	; now get the num of chars from the right
f525 : e689             [ 5] 	inc df_exeoff
f527 : 2020e2           [ 6] 	jsr df_rt_getnval
                             	; number of chars to extract from the right
f52a : 86a6             [ 3] 	stx df_tmpptrc
                             	; end pos = len
f52c : a67b             [ 3] 	ldx df_sevalptr
f52e : a57c             [ 3] 	lda df_sevalptr+1
AS65 Assembler for R6502 [1.42].                                     Page  265
---------------------------------- bank0.s -----------------------------------

f530 : 207ff4           [ 6] 	jsr df_rt_strlen_common
f533 : 85a8             [ 3] 	sta df_tmpptrd
                             	; subtract num chars to extract to get start pos
f535 : 38               [ 2] 	sec
f536 : e5a6             [ 3] 	sbc df_tmpptrc
f538 : 85a6             [ 3] 	sta df_tmpptrc
f53a : 4c8cf4           [ 3] 	jmp df_rt_str_extract
                             
                             ; $m = mid($s, x, y)
f53d :                       df_rt_mid
                             ;	inc df_exeoff
                             	; first get the string to act on
                             	; point to string accumulator
f53d : 20e0e2           [ 6] 	jsr df_rt_seval
                             	; now get start of string segment
f540 : e689             [ 5] 	inc df_exeoff
f542 : 2026e2           [ 6] 	jsr df_rt_neval
                             	; number of chars to extract
f545 : e689             [ 5] 	inc df_exeoff
f547 : 2020e2           [ 6] 	jsr df_rt_getnval
f54a : 86a8             [ 3] 	stx df_tmpptrd
                             	; start position
f54c : 209bf7           [ 6] 	jsr df_ost_popInt
f54f : ca               [ 2] 	dex					; zero offset rather than 1
f550 : 86a6             [ 3] 	stx df_tmpptrc
                             	; update end pos by adding start pos
f552 : 8a               [ 2] 	txa
f553 : 18               [ 2] 	clc
f554 : 65a8             [ 3] 	adc df_tmpptrd
f556 : 85a8             [ 3] 	sta df_tmpptrd
f558 : 4c8cf4           [ 3] 	jmp df_rt_str_extract
                             
                             ; %l = len($s)
f55b :                       df_rt_len
                             ;	inc df_exeoff
                             	; evaluate the string in the string accumulator
f55b : 20e0e2           [ 6] 	jsr df_rt_seval
f55e : 209ff7           [ 6] 	jsr df_ost_popStr
                             	; now calculate the length of this string
f561 : 207ff4           [ 6] 	jsr df_rt_strlen_common
f564 : 4c6ff7           [ 3] 	jmp df_ost_pushIntA
                             
                             ; %l = asc($s)
f567 :                       df_rt_asc
                             ;	inc df_exeoff
                             	; Evaluate string in the string accumulator
f567 : 20e0e2           [ 6] 	jsr df_rt_seval
f56a : 209ff7           [ 6] 	jsr df_ost_popStr
                             	; Store point in ZP
f56d : 86a2             [ 3] 	stx df_tmpptra
f56f : 85a3             [ 3] 	sta df_tmpptra+1
                             	; Find the character at beginning
f571 : a200             [ 2] 	ldx #0
f573 : a1a2             [ 6] 	lda (df_tmpptra,x)
f575 : 4c6ff7           [ 3] 	jmp df_ost_pushIntA
                             
                             ; %l = val($s)
f578 :                       df_rt_val
                             ;	inc df_exeoff
                             	; evaluate the string
f578 : 20e0e2           [ 6] 	jsr df_rt_seval
f57b : 209ff7           [ 6] 	jsr df_ost_popStr
AS65 Assembler for R6502 [1.42].                                     Page  266
---------------------------------- bank0.s -----------------------------------

f57e : a000             [ 2] 	ldy #0				; any numeric format
f580 : 20d1c1           [ 6] 	jsr con_n_to_a		; result in num_a
f583 : b007             [ 3] 	bcs df_rt_val_err
f585 : a63d             [ 3] 	ldx num_a
f587 : a53e             [ 3] 	lda num_a+1
                             	; Save as an int
f589 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
f58c :                       df_rt_val_err
                             	SWBRK DFERR_TYPEMISM
                             
                             
                             ; stop execution
f58e :                       df_rt_abort
                             	SWBRK DFERR_ABORT
                             
                             
f590 :                       df_rt_sprchar
f590 : 20ede4           [ 6] 	jsr df_rt_parm_2ints
f593 : a5a2             [ 3] 	lda df_tmpptra
f595 : a6a4             [ 3] 	ldx df_tmpptrb
f597 : 4c92d4           [ 3] 	jmp gr_spr_char
                             
f59a :                       df_rt_sprpos
f59a : 20f8e4           [ 6] 	jsr df_rt_parm_3ints
f59d : a5a2             [ 3] 	lda df_tmpptra
f59f : a6a4             [ 3] 	ldx df_tmpptrb
f5a1 : a4a6             [ 3] 	ldy df_tmpptrc
f5a3 : 4ca2d4           [ 3] 	jmp gr_spr_pos
                             
f5a6 :                       df_rt_sprupd
f5a6 : 202dd4           [ 6] 	jsr gr_spr_erase
f5a9 : 203fd4           [ 6] 	jsr gr_spr_new
f5ac : 4c71d4           [ 3] 	jmp gr_spr_draw
                             
f5af :                       df_rt_sprinit
f5af : 4c1fd4           [ 3] 	jmp gr_spr_init
                             
f5b2 :                       df_rt_sprmulti
f5b2 : 20ede4           [ 6] 	jsr df_rt_parm_2ints
f5b5 : 4cafd4           [ 3] 	jmp gr_spr_multi_pos
                             
f5b8 :                       df_rt_sprhit
                             ;	inc df_exeoff
f5b8 : 2020e2           [ 6] 	jsr df_rt_getnval
f5bb : 8a               [ 2] 	txa
f5bc : 2098d4           [ 6] 	jsr gr_spr_hit
f5bf : b003             [ 3] 	bcs df_rt_sprhit_inactive
                             	; Active sprite hit = background
f5c1 : 4c6ff7           [ 3] 	jmp df_ost_pushIntA
f5c4 :                       df_rt_sprhit_inactive
                             	; Inactive sprite hit = -1
f5c4 : a2ff             [ 2] 	ldx #0xff
f5c6 : 8a               [ 2] 	txa
f5c7 : 4c6bf7           [ 3] 	jmp df_ost_pushInt
                             
                             
f5ca :                       mod_sz_rtsubs_e
                             
                             
                             	include "dflat/proc.s"
                             ;************************************************
                             ;*
AS65 Assembler for R6502 [1.42].                                     Page  267
---------------------------------- bank0.s -----------------------------------

                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  PROC.S
                             ;*  dflat module to handle procedures:
                             ;*  - executing a procedure
                             ;*  - find a proc, pass local and non-local param
                             ;*  - return from a proc, unload locals
                             ;*  - save the definition of a proc in the VNT an
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f5ca :                       mod_sz_proc_s
                             
f5ca :                       df_rt_proc_parmerr
f5ca :                       df_rt_deferr
                             	SWBRK DFERR_PROCPARM
                             
                             
                             
                             ; call procedure
f5cc :                       df_rt_proc
                             	; move past escape token
f5cc : a489             [ 3] 	ldy df_exeoff
f5ce : c8               [ 2] 	iny
                             	; Get VVT address X,A and procptr
f5cf : b187             [ 5] 	lda (df_currlin),y
f5d1 : aa               [ 2] 	tax
f5d2 : c8               [ 2] 	iny
f5d3 : b187             [ 5] 	lda (df_currlin),y
f5d5 : c8               [ 2] 	iny
f5d6 : 8489             [ 3] 	sty df_exeoff
f5d8 : 868f             [ 3] 	stx df_procptr
f5da : 8590             [ 3] 	sta df_procptr+1
                             	
                             	; is index 0 (held in dim1)
                             	; then need to find the procedure
f5dc : a003             [ 2] 	ldy #DFVVT_DIM1
f5de : b18f             [ 5] 	lda (df_procptr),y
f5e0 : d014             [ 3] 	bne df_rt_proc_addr
                             	; find proc
f5e2 : 2002e6           [ 6] 	jsr df_rt_findproc
                             	; save y (line index)
f5e5 : 8438             [ 3] 	sty tmp_d
                             	; now go and update the proc vvt address
f5e7 : a002             [ 2] 	ldy #DFVVT_HI
f5e9 : 918f             [ 5] 	sta (df_procptr),y
f5eb : a001             [ 2] 	ldy #DFVVT_LO
f5ed : 8a               [ 2] 	txa
f5ee : 918f             [ 5] 	sta (df_procptr),y
f5f0 : a003             [ 2] 	ldy #DFVVT_DIM1
                             	; get back line index in to A
f5f2 : a538             [ 3] 	lda tmp_d
f5f4 : 918f             [ 5] 	sta (df_procptr),y
f5f6 :                       df_rt_proc_addr
                             	; move past first open bracket
AS65 Assembler for R6502 [1.42].                                     Page  268
---------------------------------- bank0.s -----------------------------------

f5f6 : e689             [ 5] 	inc df_exeoff
                             	
                             	; get parm count
f5f8 : a004             [ 2] 	ldy #DFVVT_DIM2
f5fa : b18f             [ 5] 	lda (df_procptr),y	
f5fc : f018             [ 4] 	beq df_rt_proc_parm_none
                             	; push the right number of parms on
f5fe : 48               [ 3] 	pha
                             
f5ff : c689             [ 5] 	dec df_exeoff		; Pre-adjust
f601 :                       df_rt_proc_push_parm
                             	; move past comma or opening bracket
f601 : e689             [ 5] 	inc df_exeoff
                             	; if at end then error!
f603 : a489             [ 3] 	ldy df_exeoff
f605 : b187             [ 5] 	lda (df_currlin),y
f607 : c929             [ 2] 	cmp #')'
f609 : f0bf             [ 4] 	beq df_rt_proc_parmerr
                             	; else try and evaluate
f60b : 2026e2           [ 6] 	jsr df_rt_neval
                             	; get parm count off stack
f60e : 68               [ 4] 	pla
                             	; decrement
f60f : 38               [ 2] 	sec
f610 : e901             [ 2] 	sbc #1
                             	; and put back on stack
f612 : 48               [ 3] 	pha
                             	; go back and do all required parms
f613 : d0ec             [ 3] 	bne df_rt_proc_push_parm
                             	; remove parm counter from stack
f615 :                       df_rt_proc_parm_done
f615 : 68               [ 4] 	pla
f616 :                       df_rt_proc_parm_none
                             	; should be at close bracket
f616 : a489             [ 3] 	ldy df_exeoff
f618 : b187             [ 5] 	lda (df_currlin),y
f61a : c929             [ 2] 	cmp #')'
f61c : d0ac             [ 4] 	bne df_rt_proc_parmerr
                             	; should be no more parms
                             	; ok, finally we have all parms on rt stack
                             	; now execute the procedure
                             	; get back the proc address
f61e : a68f             [ 3] 	ldx df_procptr
f620 : a590             [ 3] 	lda df_procptr+1
                             ;	bne df_rt_exec_proc		; ALWAYS as procptr+1 !=0
                             	
                             ; executing a procedure in VVT slot A,X
f622 :                       df_rt_exec_proc
                             	; save slot address
f622 : 86a2             [ 3] 	stx df_tmpptra
f624 : 85a3             [ 3] 	sta df_tmpptra+1
                             	
                             	; need to save all important vars
f626 : a587             [ 3] 	lda df_currlin
f628 : 48               [ 3] 	pha
f629 : a588             [ 3] 	lda df_currlin+1
f62b : 48               [ 3] 	pha
f62c : a589             [ 3] 	lda df_exeoff
f62e : 48               [ 3] 	pha
f62f : a580             [ 3] 	lda df_nxtstidx
f631 : 48               [ 3] 	pha
f632 : a581             [ 3] 	lda df_curstidx
AS65 Assembler for R6502 [1.42].                                     Page  269
---------------------------------- bank0.s -----------------------------------

f634 : 48               [ 3] 	pha
f635 : a57f             [ 3] 	lda df_eolidx
f637 : 48               [ 3] 	pha
f638 : a594             [ 3] 	lda df_ifnest
f63a : 48               [ 3] 	pha
                             
                             	; now initialise the data
f63b : a001             [ 2] 	ldy #DFVVT_LO
f63d : b1a2             [ 5] 	lda (df_tmpptra),y
f63f : 8587             [ 3] 	sta df_currlin
f641 : c8               [ 2] 	iny
f642 : b1a2             [ 5] 	lda (df_tmpptra),y
f644 : 8588             [ 3] 	sta df_currlin+1
f646 : c8               [ 2] 	iny
f647 : b1a2             [ 5] 	lda (df_tmpptra),y
f649 : 8589             [ 3] 	sta df_exeoff
f64b : 8581             [ 3] 	sta df_curstidx
f64d : a000             [ 2] 	ldy #0		; hmm XXXXX might need to be tay to get 
f64f : b187             [ 5] 	lda (df_currlin),y
f651 : 8580             [ 3] 	sta df_nxtstidx
                             	; now execute statements
f653 : 203ee5           [ 6] 	jsr df_rt_exec_stat
                             ;	bcs df_rt_exec_proc_err
                             	; now restore the position
f656 : 68               [ 4] 	pla
f657 : 8594             [ 3] 	sta df_ifnest
f659 : 68               [ 4] 	pla
f65a : 857f             [ 3] 	sta df_eolidx
f65c : 68               [ 4] 	pla
f65d : 8581             [ 3] 	sta df_curstidx
f65f : 68               [ 4] 	pla
f660 : 8580             [ 3] 	sta df_nxtstidx
f662 : 68               [ 4] 	pla
f663 : 8589             [ 3] 	sta df_exeoff
f665 : 68               [ 4] 	pla
f666 : 8588             [ 3] 	sta df_currlin+1
f668 : 68               [ 4] 	pla
f669 : 8587             [ 3] 	sta df_currlin
                             	; should be all restored, so return
f66b : 60               [ 6] 	rts
                             
                             
f66c :                       df_rt_def
                             	; line offset pointing at DFTK_PROC
                             	; skip over PROC address and open bracket
f66c : a689             [ 3] 	ldx df_exeoff
f66e : e8               [ 2] 	inx
f66f : e8               [ 2] 	inx
f670 : e8               [ 2] 	inx
f671 : 8689             [ 3] 	stx df_exeoff
                             	; parms on stack in reverse order to parm list
                             	; so get each parm and type and save to scratch
f673 : a201             [ 2] 	ldx #1									; index in to scratch
f675 : 868d             [ 3] 	stx df_procargs							; Proc args is the #args-1
f677 : a489             [ 3] 	ldy df_exeoff
f679 :                       df_rt_def_find_var
f679 : c8               [ 2] 	iny
f67a : b187             [ 5] 	lda (df_currlin),y
                             	; check if end of parm list
f67c : c929             [ 2] 	cmp #')'
f67e : f01f             [ 3] 	beq df_rt_def_parm_done
                             	; else check if found a variable escape token (<
AS65 Assembler for R6502 [1.42].                                     Page  270
---------------------------------- bank0.s -----------------------------------

f680 : c911             [ 2] 	cmp #DFTK_VAR
f682 : f007             [ 3] 	beq df_rt_def_got_var
                             	; else check if non-local specifier
f684 : c926             [ 2] 	cmp #DFTK_VARPARM						; This is a regular ASCII
f686 : d0f1             [ 3] 	bne df_rt_def_find_var
f688 :                       df_rt_def_got_varparm
                             	; set high bit
f688 : 0980             [ 2] 	ora #0x80
                             	; advance over non-local specifier
f68a : c8               [ 2] 	iny
f68b :                       df_rt_def_got_var
f68b : 9d1f06           [ 5] 	sta scratch,x		; Save parm type (by value or ref
                             	; get address and save in scratch
f68e : c8               [ 2] 	iny
f68f : b187             [ 5] 	lda (df_currlin),y
f691 : 9d3f06           [ 5] 	sta scratch+32,x	; Hope 32 params is enough! :-)
f694 : c8               [ 2] 	iny
f695 : b187             [ 5] 	lda (df_currlin),y
f697 : 9d5f06           [ 5] 	sta scratch+64,x
f69a : e8               [ 2] 	inx
f69b : e68d             [ 5] 	inc df_procargs
f69d : d0da             [ 3] 	bne df_rt_def_find_var  ; always - relies not ze
f69f :                       df_rt_def_parm_done
                             	; save index that we got to
f69f : 8489             [ 3] 	sty df_exeoff
                             	; save def param list position in temp
f6a1 : 868c             [ 3] 	stx df_procmode
                             	; all var indices on the operator stack
                             	; now load up variables with parameters
                             	; initially assume no locals
f6a3 : a900             [ 2] 	lda #0
f6a5 : 858e             [ 3] 	sta df_procloc
f6a7 :                       df_rt_def_load_var
f6a7 : c68d             [ 5] 	dec df_procargs
f6a9 : f02f             [ 3] 	beq df_rt_def_load_var_done
                             	; get var address
f6ab : c68c             [ 5] 	dec df_procmode
f6ad : a68c             [ 3] 	ldx df_procmode
f6af : bd3f06           [ 4] 	lda scratch+32,x
f6b2 : 85a2             [ 3] 	sta df_tmpptra
f6b4 : bd5f06           [ 4] 	lda scratch+64,x
f6b7 : 85a3             [ 3] 	sta df_tmpptra+1
                             	
f6b9 : bd1f06           [ 4] 	lda scratch,x
                             	; if MSB is set then this is not a local variabl
                             	; so just go an initialise with stacking
f6bc : 3009             [ 3] 	bmi df_rt_def_initialise_parm
                             	; else call the local handling code to 
                             	; push the var address on to the runtime stack
f6be : a6a2             [ 3] 	ldx df_tmpptra
f6c0 : a5a3             [ 3] 	lda df_tmpptra+1
f6c2 : 200ef7           [ 6] 	jsr df_rt_proc_local
                             	; increment number of locals
f6c5 : e68e             [ 5] 	inc df_procloc
f6c7 :                       df_rt_def_initialise_parm
                             	; load type
f6c7 : a000             [ 2] 	ldy #DFVVT_TYPE
f6c9 : b1a2             [ 5] 	lda (df_tmpptra),y
f6cb : a8               [ 2] 	tay					; Put the type into Y
f6cc : 207ef7           [ 6] 	jsr df_ost_popParmX	; Try to get this off the st
                             	; update the variable
f6cf : a002             [ 2] 	ldy #DFVVT_HI
AS65 Assembler for R6502 [1.42].                                     Page  271
---------------------------------- bank0.s -----------------------------------

f6d1 : 91a2             [ 5] 	sta (df_tmpptra),y
f6d3 : 88               [ 2] 	dey
f6d4 : 8a               [ 2] 	txa
f6d5 : 91a2             [ 5] 	sta (df_tmpptra),y
                             
f6d7 : 4ca7f6           [ 3] 	jmp df_rt_def_load_var
f6da :                       df_rt_def_load_var_done
                             	; save the number of local parameters found so t
                             	; be unloaded when the proc ends
f6da : a58e             [ 3] 	lda df_procloc
f6dc : 2022f7           [ 6] 	jsr df_rst_pushByte
                             	; continue with next statement
f6df : 18               [ 2] 	clc
f6e0 : 60               [ 6] 	rts
                             
                             	
                             ; return a value
f6e1 :                       df_rt_return
                             	; evaluate the return and put on the parameter s
                             	; then process this like an end of procedure
f6e1 : 2026e2           [ 6] 	jsr df_rt_neval
                             ; end def for a proc
f6e4 :                       df_rt_enddef
                             	; unload any locals
                             ;	jsr df_rt_proc_unlocal
                             	; nothing to do - main loop will terminate
                             ;	clc
                             ;	rts
                             ; enddef falls through to the unlocal code	
                             	
                             ; unload any local variables from runtime stack
                             ;df_rt_proc_unlocal
f6e4 : 202bf7           [ 6] 	jsr df_rst_popByte
f6e7 : aa               [ 2] 	tax
f6e8 : f020             [ 4] 	beq df_rt_proc_unload_done
f6ea :                       df_rt_proc_unloadvar
f6ea : 8a               [ 2] 	txa
f6eb : 48               [ 3] 	pha
                             	; var value is popped first then index
                             	; get a word and put in tmpb
f6ec : 2048f7           [ 6] 	jsr df_rst_popWord
f6ef : 86a4             [ 3] 	stx df_tmpptrb
f6f1 : 85a5             [ 3] 	sta df_tmpptrb+1
                             	; get the var address
f6f3 : 2048f7           [ 6] 	jsr df_rst_popWord
f6f6 : 86a2             [ 3] 	stx df_tmpptra
f6f8 : 85a3             [ 3] 	sta df_tmpptra+1
                             	; store lo byte first
f6fa : a001             [ 2] 	ldy #DFVVT_LO
f6fc : a5a4             [ 3] 	lda df_tmpptrb
f6fe : 91a2             [ 5] 	sta (df_tmpptra),y
                             	; then hi
f700 : c8               [ 2] 	iny
f701 : a5a5             [ 3] 	lda df_tmpptrb+1
f703 : 91a2             [ 5] 	sta (df_tmpptra),y
                             	; restore counter
f705 : 68               [ 4] 	pla
f706 : aa               [ 2] 	tax
f707 : ca               [ 2] 	dex
f708 : d0e0             [ 4] 	bne df_rt_proc_unloadvar
f70a :                       df_rt_proc_unload_done
f70a : 68               [ 4] 	pla				; Pull old return address from stack
AS65 Assembler for R6502 [1.42].                                     Page  272
---------------------------------- bank0.s -----------------------------------

f70b : 68               [ 4] 	pla
f70c : 18               [ 2] 	clc
f70d : 60               [ 6] 	rts
                             	
                             ; push a local variable to the runtime stack
                             ; X,A = var slot
f70e :                       df_rt_proc_local
                             	; save address
f70e : 86a2             [ 3] 	stx df_tmpptra
f710 : 85a3             [ 3] 	sta df_tmpptra+1
                             	; push var slot on rt stack
f712 : 203af7           [ 6] 	jsr df_rst_pushWord
f715 :                       df_rt_proc_local_load	
                             	; load x,a with var value lo,hi
f715 : a001             [ 2] 	ldy #DFVVT_LO
f717 : b1a2             [ 5] 	lda (df_tmpptra),y
f719 : aa               [ 2] 	tax
f71a : c8               [ 2] 	iny
f71b : b1a2             [ 5] 	lda (df_tmpptra),y
                             	; push word on to rt stack
f71d : 203af7           [ 6] 	jsr df_rst_pushWord
f720 : 18               [ 2] 	clc
f721 : 60               [ 6] 	rts
                             		
f722 :                       mod_sz_proc_e
                             
                             
f722 :                       mod_sz_runtime_e
                             
                             
                             
                             	include "dflat/stack.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  STACK.S
                             ;*  This module implements the dflat software sta
                             ;*  needs a few stacks:
                             ;*  - 6502 stack for expression parsing and reent
                             ;*  - dflat runtime stack for things like for/nex
                             ;*  - dflat parameter stack for passing parameter
                             ;*  The two software stacks are implemented in th
                             ;*  with the operator stack growing up from 0 and
                             ;*  runtime stack growing down from 255.  Hopeful
                             ;*  don't meet as there are no checks for this at
                             ;*  purely because I want speed over friendliness
                             ;*  I may come to regret this!
                             ;*  I have also added the only runtime memory all
                             ;*  needed by dflat here.  Humourously I have cal
                             ;*  which is taken from the C language, but it's 
                             ;*  grab some memory after end the of dflat progr
                             ;*  arrays - which of course cannot have storage 
                             ;*  tokenisation time (e.g. because I dimension a
                             ;*  a size from a variable).
                             ;*
                             ;************************************************
                             
AS65 Assembler for R6502 [1.42].                                     Page  273
---------------------------------- bank0.s -----------------------------------

                             	; ROM code
                             	code  
                             
                             
                             ;****************************************
                             ;* Push a byte on to runtime stack
                             ;* A = byte
                             ;****************************************
f722 :                       df_rst_pushByte
f722 : a477             [ 3] 	ldy df_rtstop
f724 : 990005           [ 5] 	sta df_rtstck,y
f727 : 88               [ 2] 	dey
f728 : 8477             [ 3] 	sty df_rtstop
f72a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop a byte off runtime stack
                             ;* A = byte
                             ;****************************************
f72b :                       df_rst_popByte
f72b : a477             [ 3] 	ldy df_rtstop
f72d : c8               [ 2] 	iny
f72e : b90005           [ 4] 	lda df_rtstck,y
f731 : 8477             [ 3] 	sty df_rtstop
f733 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Peek a byte off runtime stack
                             ;* A = byte
                             ;****************************************
f734 :                       df_rst_peekByte
f734 : a477             [ 3] 	ldy df_rtstop
                             	; Look at what is below top of stack
                             	; below means the next address up as
                             	; this stack grows downwards like 6502
f736 : b90105           [ 4] 	lda df_rtstck+1,y
f739 : 60               [ 6] 	rts
                             	
                             ;****************************************
                             ;* Push a word on to runtime stack
                             ;* X,A = word lo,hi
                             ;****************************************
f73a :                       df_rst_pushWord
f73a : a477             [ 3] 	ldy df_rtstop
f73c : 990005           [ 5] 	sta df_rtstck,y
f73f : 88               [ 2] 	dey
f740 : 8a               [ 2] 	txa
f741 : 990005           [ 5] 	sta df_rtstck,y
f744 : 88               [ 2] 	dey
f745 : 8477             [ 3] 	sty df_rtstop
f747 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop a word off runtime stack
                             ;* X,A = word lo,hi
                             ;****************************************
f748 :                       df_rst_popWord
f748 : a477             [ 3] 	ldy df_rtstop
f74a : c8               [ 2] 	iny
f74b : be0005           [ 4] 	ldx df_rtstck,y
f74e : c8               [ 2] 	iny
f74f : b90005           [ 4] 	lda df_rtstck,y
AS65 Assembler for R6502 [1.42].                                     Page  274
---------------------------------- bank0.s -----------------------------------

f752 : 8477             [ 3] 	sty df_rtstop
f754 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push a parameter on to parm stack
                             ;* X,A - int
                             ;* Y - type
                             ;****************************************
f755 :                       df_ost_pushParmX
f755 : 8438             [ 3] 	sty tmp_d		; Save Type
f757 : a478             [ 3] 	ldy df_parmtop	; Get stack index
                             	; push high byte first (A)
f759 : 990005           [ 5] 	sta df_rtstck,y
f75c : c8               [ 2] 	iny
                             	; push low byte next (X)
f75d : 8a               [ 2] 	txa
f75e : 990005           [ 5] 	sta df_rtstck,y
f761 : c8               [ 2] 	iny
f762 : a538             [ 3] 	lda tmp_d		; get Type
f764 : 990005           [ 5] 	sta df_rtstck,y
f767 : c8               [ 2] 	iny
                             	; save new top of stack
f768 : 8478             [ 3] 	sty df_parmtop
f76a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Push an int on to parm stack
                             ;* X,A - int
                             ;****************************************
f76b :                       df_ost_pushInt
f76b : a003             [ 2] 	ldy #DFST_INT
f76d : d0e6             [ 3] 	bne df_ost_pushParmX		; ALWAYS!
                             
                             ;****************************************
                             ;* Push A on to parm stack
                             ;* X,A - int
                             ;****************************************
f76f :                       df_ost_pushIntA
f76f : a003             [ 2] 	ldy #DFST_INT
f771 : aa               [ 2] 	tax
f772 : a900             [ 2] 	lda #0
f774 : f0df             [ 3] 	beq df_ost_pushParmX		; ALWAYS!
                             
                             ;****************************************
                             ;* Push a string pointer on to parm stack
                             ;* X,A - int
                             ;****************************************
f776 :                       df_ost_pushStr
f776 : a004             [ 2] 	ldy #DFST_STR
f778 : d0db             [ 3] 	bne df_ost_pushParmX		; ALWAYS!
                             
                             ;****************************************
                             ;* Push a general pointer on to parm stack
                             ;* X,A - int
                             ;****************************************
f77a :                       df_ost_pushPtr
f77a : a0ff             [ 2] 	ldy #DFST_PTR
f77c : d0d7             [ 3] 	bne df_ost_pushParmX		; ALWAYS!
                             	
                             ;****************************************
                             ;* Pop parameter from the stack
                             ;* X,A - int
AS65 Assembler for R6502 [1.42].                                     Page  275
---------------------------------- bank0.s -----------------------------------

                             ;* Y - type expected
                             ;****************************************
f77e :                       df_ost_popParmX
f77e : 98               [ 2] 	tya
f77f : a478             [ 3] 	ldy df_parmtop
                             	; pull type first
f781 : 88               [ 2] 	dey
f782 : 390005           [ 4] 	and df_rtstck,y
f785 : f00c             [ 3] 	beq df_st_typemismatcherr
                             	; pull low byte first
f787 : 88               [ 2] 	dey
f788 : be0005           [ 4] 	ldx df_rtstck,y
                             	; pull high byte next
f78b : 88               [ 2] 	dey
f78c : b90005           [ 4] 	lda df_rtstck,y
                             	; save new top of stack
f78f : 8478             [ 3] 	sty df_parmtop
f791 : 18               [ 2] 	clc
f792 : 60               [ 6] 	rts
f793 :                       df_st_typemismatcherr
                             	SWBRK DFERR_TYPEMISM
                             
                             
                             ;****************************************
                             ;* Return type on top of stack
                             ;* A - type
                             ;****************************************
f795 :                       df_ost_peekType
f795 : a478             [ 3] 	ldy df_parmtop
f797 : b9ff04           [ 4] 	lda df_rtstck-1,y
f79a : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* Pop an int off parm stack
                             ;* X,A - int
                             ;****************************************
f79b :                       df_ost_popInt
f79b : a003             [ 2] 	ldy #DFST_INT
f79d : d0df             [ 3] 	bne df_ost_popParmX			; ALWAYS!
                             
                             ;****************************************
                             ;* Pop a string pointer off parm stack
                             ;* X,A - int
                             ;****************************************
f79f :                       df_ost_popStr
f79f : a004             [ 2] 	ldy #DFST_STR
f7a1 : d0db             [ 3] 	bne df_ost_popParmX			; ALWAYS!
                             	
                             ;****************************************
                             ;* Pop a general pointer off parm stack
                             ;* X,A - int
                             ;****************************************
f7a3 :                       df_ost_popPtr
f7a3 : a0ff             [ 2] 	ldy #DFST_PTR
f7a5 : d0d7             [ 3] 	bne df_ost_popParmX			; ALWAYS!
                             	
                             	
                             ;****************************************
                             ;* Allocate space on the heap
                             ;* X, A = Number of bytes to allocate
                             ;* X, A return address of allocated space
                             ;****************************************
AS65 Assembler for R6502 [1.42].                                     Page  276
---------------------------------- bank0.s -----------------------------------

f7a7 :                       df_st_malloc
                             	; save A in Y
f7a7 : a8               [ 2] 	tay
                             	; save old starend
f7a8 : a576             [ 3] 	lda df_starend+1
f7aa : 48               [ 3] 	pha
f7ab : a575             [ 3] 	lda df_starend
f7ad : 48               [ 3] 	pha
                             	; restore A from Y
f7ae : 98               [ 2] 	tya
                             	; add X,A to starend
f7af : 48               [ 3] 	pha
f7b0 : 8a               [ 2] 	txa
f7b1 : 18               [ 2] 	clc
f7b2 : 6575             [ 3] 	adc df_starend
f7b4 : 8575             [ 3] 	sta df_starend
f7b6 : 68               [ 4] 	pla
f7b7 : 6576             [ 3] 	adc df_starend+1
f7b9 : 8576             [ 3] 	sta df_starend+1
                             	; return old starend as start of space
f7bb : 68               [ 4] 	pla
f7bc : aa               [ 2] 	tax
f7bd : 68               [ 4] 	pla
f7be : 60               [ 6] 	rts
                             	
                             
                             ;****************************************
                             ;* df_init
                             ;* Initialise dflat language settings
                             ;****************************************
f7bf :                       df_init
                             	; Initialise top of memory to default
                             	; This can be overridden by himem command
f7bf : a900             [ 2] 	lda #lo(DF_MEMTOP)
f7c1 : 8d1d06           [ 4] 	sta df_memtop
f7c4 : a998             [ 2] 	lda #hi(DF_MEMTOP)
f7c6 : 8d1e06           [ 4] 	sta df_memtop+1
                             
                             	; Init program space
f7c9 : 4cccf7           [ 3] 	jmp df_clear
                             
                             	; Initialise assembler
                             ;	jsr asm_init
                             
                             ;	rts
                             
                             
                             ;****************************************
                             ;* df_clear
                             ;* Initialise program space
                             ;****************************************
f7cc :                       df_clear
                             	; Start of program space
f7cc : a91f             [ 2] 	lda #lo(DF_PROGSTART)
f7ce : 8566             [ 3] 	sta df_prgstrt
f7d0 : 8568             [ 3] 	sta df_prgend
f7d2 : a907             [ 2] 	lda #hi(DF_PROGSTART)
f7d4 : 8567             [ 3] 	sta df_prgstrt+1
f7d6 : 8569             [ 3] 	sta df_prgend+1
                             	; Terminal value in prog space
f7d8 : a900             [ 2] 	lda #0
f7da : a8               [ 2] 	tay
AS65 Assembler for R6502 [1.42].                                     Page  277
---------------------------------- bank0.s -----------------------------------

f7db : 9166             [ 5] 	sta (df_prgstrt),y
                             	; No variables - zero the count
f7dd : 8572             [ 3] 	sta df_varcnt
                             
                             	; Variable value table
                             	; Grows down from mem top
f7df : ad1d06           [ 4] 	lda df_memtop
f7e2 : 856e             [ 3] 	sta df_vvtstrt
f7e4 : 8570             [ 3] 	sta df_vvtend
f7e6 : ad1e06           [ 4] 	lda df_memtop+1
f7e9 : 856f             [ 3] 	sta df_vvtstrt+1
f7eb : 8571             [ 3] 	sta df_vvtend+1
                             
                             	; Variable name table
                             	; Grows down from mem top
f7ed : a56e             [ 3] 	lda df_vvtstrt
f7ef : 856a             [ 3] 	sta df_vntstrt
f7f1 : 856c             [ 3] 	sta df_vntend
f7f3 : a56f             [ 3] 	lda df_vvtstrt+1
f7f5 : 856b             [ 3] 	sta df_vntstrt+1
f7f7 : 856d             [ 3] 	sta df_vntend+1
                             
                             	; String accumulator
f7f9 : a91f             [ 2] 	lda #lo(scratch)
f7fb : 857b             [ 3] 	sta df_sevalptr
f7fd : a906             [ 2] 	lda #hi(scratch)
f7ff : 857c             [ 3] 	sta df_sevalptr+1
                             
f801 : 60               [ 6] 	rts
                             
f802 :                       mod_sz_dflat_e
                             
                             	include "dflat/error.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.S
                             ;*  Error handling module.
                             ;*  Whan an error is thrown using BRK, this modul
                             ;*  displaying the error plus any associated line
                             ;*  if it was running a program.  It then resets 
                             ;*  settings and takes the system back to program
                             ;*  mode.  The message uses the general IO handle
                             ;*  output must be set to the right place else fo
                             ;*	the error message will be written to tape!
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             	include "dflat/error.i"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
AS65 Assembler for R6502 [1.42].                                     Page  278
---------------------------------- bank0.s -----------------------------------

                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ERROR.I
                             ;*  Error definitions file.
                             ;*  The macro to throw an error is elswhere, but 
                             ;*  It issues a 6502 BRK commmand with the next b
                             ;*  the error code.  The BRK handler then picks u
                             ;*  code and shows the appropriate message plus a
                             ;*  number if a program was running.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Error message numbers
0000 =                       DFERR_OK		=	0
0001 =                       DFERR_SYNTAX	=	1
0002 =                       DFERR_TYPEMISM	=	2
0003 =                       DFERR_DIM		=	3
0004 =                       DFERR_UNTIL		=	4
0005 =                       DFERR_NOPROC	=	5
0006 =                       DFERR_PROCPARM	=	6
0007 =                       DFERR_IMMEDIATE	=	7
0008 =                       DFERR_UNCLOSEDIF=	8
0009 =                       DFERR_NOIF		=	9
000a =                       DFERR_NEXTFOR	=	10
000b =                       DFERR_FNAME		=	11
000c =                       DFERR_STRLONG	=	12
000d =                       DFERR_BREAK		=	13
000e =                       DFERR_NODATA	=	14
000f =                       DFERR_WEND		=	15
0010 =                       DFERR_NOLINE	=	16
0011 =                       DFERR_RETURN	=	17
0012 =                       DFERR_ABORT		=	18
0013 =                       DFERR_QUANTITY	=	19
0014 =                       DFERR_NOORG		=	20
                             
                             
                             
                             
                             
                             ; Error message table, each msg null terminated
f802 :                       df_tk_errortab
f802 : 4f6b00                	db	"Ok", 0
f805 : 53796e74617800        	db	"Syntax", 0
f80c : 5479706500            	db	"Type", 0
f811 : 44696d00              	db	"Dim", 0
f815 : 4e6f2072657065..      	db	"No repeat", 0
f81f : 4e6f206465666e00      	db	"No defn", 0
f827 : 5061726d00            	db	"Parm", 0
f82c : 456e64656400          	db	"Ended", 0
f832 : 4e6f20656e6469..      	db	"No endif", 0
f83b : 4e6f20696600          	db	"No if", 0
f841 : 4e6f20666f7200        	db	"No for", 0
f848 : 4e6f7420666f75..      	db	"Not found", 0
f852 : 546f6f206c6f6e..      	db	"Too long", 0
f85b : 427265616b00          	db	"Break", 0
f861 : 4e6f206461746100      	db	"No data", 0
f869 : 4e6f207768696c..      	db	"No while", 0
f872 : 4e6f206c696e6500      	db	"No line", 0
f87a : 4e6f2072657475..      	db	"No return ", 0
AS65 Assembler for R6502 [1.42].                                     Page  279
---------------------------------- bank0.s -----------------------------------

f885 : 41626f7274656400      	db	"Aborted", 0
f88d : 426f756e647300        	db	"Bounds", 0
f894 : 4e6f206f726700        	db	"No org", 0
f89b : 00                    	db	0
                             
f89c :                       df_tk_error_inline
f89c : 20696e206c696e..      	db	" in line ", 0
f8a6 :                       df_tk_error_atpos
f8a6 : 20706f732000          	db	" pos ", 0
f8ac :                       df_tk_error_error
f8ac : 206572726f7200        	db	" error", 0
                             
                             ;****************************************
                             ;* df_trap_error
                             ;* Show an error message
                             ;* errno is error number
                             ;* currlin = Line number
                             ;* exeoff = offset
                             ;* at the end jump to program editor
                             ;****************************************
f8b3 :                       df_trap_error
                             	; set IO back to normal
f8b3 : 20fdc4           [ 6] 	jsr init_via0
f8b6 : 2004c4           [ 6] 	jsr io_set_default
f8b9 : 58               [ 2] 	cli
                             
f8ba : a902             [ 2] 	lda #lo(df_tk_errortab)
f8bc : 85a2             [ 3] 	sta df_tmpptra
f8be : a9f8             [ 2] 	lda #hi(df_tk_errortab)
f8c0 : 85a3             [ 3] 	sta df_tmpptra+1
f8c2 : a65e             [ 3] 	ldx errno				; 0 or >=128 goes to monitor
f8c4 : f002             [ 3] 	beq df_trap_go_monitor
f8c6 : 1003             [ 3] 	bpl df_trap_normal
f8c8 :                       df_trap_go_monitor
f8c8 : 4c41f9           [ 3] 	jmp df_trap_monitor
f8cb :                       df_trap_normal
f8cb : a000             [ 2] 	ldy #0
f8cd :                       df_show_err_find
                             	; If on a zero, then error table exhausted
                             	; so drop in to the monitor
f8cd : b1a2             [ 5] 	lda (df_tmpptra),y
f8cf : f070             [ 4] 	beq df_trap_monitor
                             	; Skip over this error text including zero termi
f8d1 :                       df_show_err_skip
                             	_incZPWord df_tmpptra
                             
f8d7 : b1a2             [ 5] 	lda (df_tmpptra),y
f8d9 : d0f6             [ 3] 	bne df_show_err_skip
                             	_incZPWord df_tmpptra
                             
f8e1 : ca               [ 2] 	dex
f8e2 : d0e9             [ 3] 	bne df_show_err_find
                             	; Error message found
f8e4 : a6a2             [ 3] 	ldx df_tmpptra
f8e6 : a5a3             [ 3] 	lda df_tmpptra+1
f8e8 : 207ec4           [ 6] 	jsr io_print_line
f8eb : a2ac             [ 2] 	ldx #lo(df_tk_error_error)
f8ed : a9f8             [ 2] 	lda #hi(df_tk_error_error)
f8ef : 207ec4           [ 6] 	jsr io_print_line
                             	; if line number <> 0 then print it
f8f2 : a001             [ 2] 	ldy #DFTK_LINNUM
f8f4 : b187             [ 5] 	lda (df_currlin),y
AS65 Assembler for R6502 [1.42].                                     Page  280
---------------------------------- bank0.s -----------------------------------

f8f6 : aa               [ 2] 	tax
f8f7 : c8               [ 2] 	iny
f8f8 : b187             [ 5] 	lda (df_currlin),y
f8fa : d004             [ 4] 	bne df_show_err_linnum
f8fc : e000             [ 2] 	cpx #0x00
f8fe : f019             [ 4] 	beq df_show_err_fin
f900 :                       df_show_err_linnum
                             	_println df_tk_error_inline
                             
f915 : 18               [ 2] 	clc
f916 : 20e8c3           [ 6] 	jsr print_a_to_d
f919 :                       df_show_err_fin
f919 : a489             [ 3] 	ldy df_exeoff
f91b : f01d             [ 3] 	beq df_show_err_done
                             	_println df_tk_error_atpos
                             
f932 : 98               [ 2] 	tya
f933 : aa               [ 2] 	tax
f934 : a900             [ 2] 	lda #0
f936 : 18               [ 2] 	clc
f937 : 20e8c3           [ 6] 	jsr print_a_to_d
f93a :                       df_show_err_done
f93a : 206bc1           [ 6] 	jsr utilPrintCRLF
f93d : 18               [ 2] 	clc
                             	; back to editor
f93e : 4c12e1           [ 3] 	jmp df_pg_dflat
                             
                             
                             ; For unknown errors, jump to monitor
f941 :                       df_trap_monitor
                             	; Print PC
                             	_println_low df_msg_pc
                             
f948 : a564             [ 3] 	lda df_brkpc+1
f94a : 2073c1           [ 6] 	jsr utilPrintA
f94d : a563             [ 3] 	lda df_brkpc
f94f : 2073c1           [ 6] 	jsr utilPrintA
f952 : 2063c1           [ 6] 	jsr utilPrintSPC
                             
                             	; Print A
                             	_println_low df_msg_acc
                             
f95c : a53d             [ 3] 	lda num_a
f95e : 2073c1           [ 6] 	jsr utilPrintA
f961 : 2063c1           [ 6] 	jsr utilPrintSPC
                             
                             	; Print X
                             	_println_low df_msg_xreg
                             
f96b : a53e             [ 3] 	lda num_a+1
f96d : 2073c1           [ 6] 	jsr utilPrintA
f970 : 2063c1           [ 6] 	jsr utilPrintSPC
                             
                             	; Print Y
                             	_println_low df_msg_yreg
                             
f97a : a53f             [ 3] 	lda num_a+2
f97c : 2073c1           [ 6] 	jsr utilPrintA
f97f : 206bc1           [ 6] 	jsr utilPrintCRLF
                             
f982 : 204ce9           [ 6] 	jsr df_rt_monitor
                             	; back to editor
AS65 Assembler for R6502 [1.42].                                     Page  281
---------------------------------- bank0.s -----------------------------------

f985 : 4c12e1           [ 3] 	jmp df_pg_dflat
                             
f988 :                       df_msg_pc
f988 : 50433a00              	db "PC:\x0"
f98c :                       df_msg_acc
f98c : 413a00                	db "A:\x0"
f98f :                       df_msg_xreg
f98f : 583a00                	db "X:\x0"
f992 :                       df_msg_yreg
f992 : 593a00                	db "Y:\x0"
                             
                             	include	"dflat/asm.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASM.S
                             ;*  This is the main controller code file for the
                             ;*  This file includes all the required source fi
                             ;*	in addition to dflat.s
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code
                             
f995 :                       mod_sz_asm_s
                             
                             	;	dflat.s is already included, so just the addit
                             	include "dflat/asm.i"
                             ;* Addressing modes - 15 in total, 16 with direct
                             ;*  0   Nothing
                             ;*	1 	Absolute			XXX <word>
                             ;*	2 	Absolute,X			XXX <word>,x
                             ;*	3 	Absolute,Y			XXX <word>,y
                             ;*	4	Zeropage			XXX	<byte>
                             ;*	5	Zeropage,X			XXX	<byte>,x
                             ;*	6	Zeropage,Y			XXX	<byte>,y
                             ;*	7	Indirect			XXX	(<byte>)
                             ;*	8	Indirect,X			XXX	(<byte>,x)
                             ;*	9	Indirect,Y			XXX	(<byte>),y
                             ;*	A	Absolute indirect	XXX	(<word>)
                             ;*	B	Absolute indirect,x	XXX	(<word>,x)
                             ;*	C	Immediate			XXX #<byte>
                             ;*	D	Accumulator			XXX (same as implied)
                             ;*	E	Implied				XXX
                             ;*	F	Relative			XXX	<byte>
                             ;*	10	Assembler directive	XXX .......
                             
0000 =                       AM_NONE		= 0
0001 =                       AM_ABS	 	= 1
0002 =                       AM_ABSX		= 2
0003 =                       AM_ABSY		= 3
0004 =                       AM_ZP		= 4
0005 =                       AM_ZPX		= 5
0006 =                       AM_ZPY		= 6
0007 =                       AM_ZPIND	= 7
0008 =                       AM_ZPINDX	= 8
AS65 Assembler for R6502 [1.42].                                     Page  282
---------------------------------- bank0.s -----------------------------------

0009 =                       AM_ZPINDY	= 9
000a =                       AM_ABSIND	= 10
000b =                       AM_ABSINDX	= 11
000c =                       AM_IMM		= 12
000d =                       AM_ACC		= 13
000d =                       AM_IMP		= AM_ACC
000f =                       AM_REL		= 15
0010 =                       AM_DIR		= 16
                             
                             
                             
                             	include "dflat/tkasm.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASM.S
                             ;*	Module that implements tokenisation of the ass
                             ;* 	The assembler is an extension to dflat, almos
                             ;*	almost a language within a language, as it has
                             ;*	own symbol tables to allow adding new keywords
                             ;*	running out of space in the main symtol table 
                             ;*	for normal 6502 asembler syntax which is at od
                             ;*	regular dflat.
                             ;*	Hence, this module has to do its own additiona
                             ;*	to tokenise the assembly.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
f995 :                       mod_sz_tkasm_s
                             
                             	; if didn't find regular keywords then try assen
f995 :                       df_tk_asm_parse_command
                             ;	; skip the white space after the dot
                             ;	jsr df_tk_skip_ws
                             	; find the assembler symbol
f995 : 20caf9           [ 6] 	jsr df_tk_asm_matchtok
                             	; if no match with asm token they maybe a label?
f998 : b01d             [ 3] 	bcs df_tk_asm_label
f99a :                       df_tk_asm_found_command
                             	; Before asm keyword, put the asm handler token
f99a : a997             [ 2] 	lda #DFRT_ASM
f99c : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	; Set the MSB of found symbol index
f99f : a584             [ 3] 	lda df_symoff
f9a1 : 0980             [ 2] 	ora #0x80
f9a3 : 206fd8           [ 6] 	jsr df_tk_put_tok
                             	; check the first addressing mode code
                             	; remember to jump over the offset byte
f9a6 : a001             [ 2] 	ldy #1
f9a8 : b182             [ 5] 	lda (df_symtab),y
                             	; Directive?
f9aa : c910             [ 2] 	cmp #AM_DIR
f9ac : d006             [ 3] 	bne df_tk_asm_mnemonic
                             	; if directive then process it
AS65 Assembler for R6502 [1.42].                                     Page  283
---------------------------------- bank0.s -----------------------------------

f9ae : a584             [ 3] 	lda df_symoff
f9b0 : 4c21fa           [ 3] 	jmp df_tk_asm_exec_parser
f9b3 :                       df_tk_asm_parse_command_err
f9b3 : 60               [ 6] 	rts
f9b4 :                       df_tk_asm_mnemonic
                             	; for all nmemonics, work out the addressing mod
f9b4 : 4c30fa           [ 3] 	jmp df_tk_asm_addr_mode
                             
                             ; try to tokenise a label
f9b7 :                       df_tk_asm_label
                             	; labels must start with '.'
f9b7 : a92e             [ 2] 	lda #'.'
f9b9 : 20d6d8           [ 6] 	jsr df_tk_expect
f9bc : b0f5             [ 3] 	bcs df_tk_asm_parse_command_err
                             	; Before asm label, put the asm handler token
f9be : a997             [ 2] 	lda #DFRT_ASM
f9c0 : 206fd8           [ 6] 	jsr df_tk_put_tok
f9c3 : e67d             [ 5] 	inc df_linoff			;Skip the '.'
                             	; Tokenise a variable
f9c5 : a900             [ 2] 	lda #0
f9c7 : 4c9ad9           [ 3] 	jmp df_tk_var
                             
                             ;****************************************
                             ;* df_tk_asm_matchtok
                             ;* Try and find a token match against the table d
                             ;* Input:
                             ;*			Current df_linbuff and df_linoff
                             ;* Return: 	CC = No Error, CS = Error
                             ;*			df_linoff points to next char if CC else unc
                             ;****************************************
f9ca :                       df_tk_asm_matchtok
                             	; Start at token symbols beginning
f9ca : a9ac             [ 2] 	lda #lo(df_asm_tokensyms)
f9cc : 8582             [ 3] 	sta df_symtab
f9ce : a9fd             [ 2] 	lda #hi(df_asm_tokensyms)
f9d0 : 8583             [ 3] 	sta df_symtab+1
f9d2 : a900             [ 2] 	lda #0
f9d4 : 8584             [ 3] 	sta df_symoff
f9d6 : a200             [ 2] 	ldx #0
f9d8 :                       df_tk_asm_checknexttok
                             	; From the line buffer current pointer
                             	; Check for a token match
f9d8 : a47d             [ 3] 	ldy df_linoff
f9da :                       df_tk_asm_checktokch
                             	; Get symtable char
f9da : a182             [ 6] 	lda (df_symtab,x)
                             	; if less than ascii ' ' then reached end of
                             	; this symbol and everything matched so found!
f9dc : c920             [ 2] 	cmp #' '
f9de : 9033             [ 4] 	bcc df_tk_asm_symfound
                             	; Else compare with current line buffer char
f9e0 : d90004           [ 4] 	cmp df_linbuff,y
                             	; If chars not match then this symbol fails
f9e3 : d00a             [ 3] 	bne df_tk_asm_symnomatch
                             	; else more chars to match
                             	; so increment line buffer pointers
                             	_incZPWord df_symtab
                             
f9eb : c8               [ 2] 	iny
f9ec : 4cdaf9           [ 3] 	jmp df_tk_asm_checktokch
f9ef :                       df_tk_asm_symnomatch
                             	; Increment symbol counter to next symbol
AS65 Assembler for R6502 [1.42].                                     Page  284
---------------------------------- bank0.s -----------------------------------

f9ef : e684             [ 5] 	inc df_symoff
f9f1 :                       df_tk_asm_symnextentry
f9f1 : a182             [ 6] 	lda (df_symtab,x)
                             	; End of symbol is < ' '
f9f3 : c920             [ 2] 	cmp #' '
f9f5 : 9009             [ 4] 	bcc  df_tk_asm_foundsymend
                             	_incZPWord df_symtab
                             
f9fd : 4cf1f9           [ 3] 	jmp df_tk_asm_symnextentry
fa00 :                       df_tk_asm_foundsymend
                             	; Now at the offset to jump over addressing
                             	; mode and opcode values. Add offset to ptr
                             	; remember than C is clear and A has offset
                             	; set C so always jump over the offset
fa00 : 38               [ 2] 	sec
fa01 : 6582             [ 3] 	adc df_symtab
fa03 : 8582             [ 3] 	sta df_symtab
fa05 : a583             [ 3] 	lda df_symtab+1
fa07 : 6900             [ 2] 	adc #0
fa09 : 8583             [ 3] 	sta df_symtab+1
                             	; If next char is not zero then
                             	; try and match with line buffer
fa0b : a182             [ 6] 	lda (df_symtab,x)
fa0d : d0c9             [ 4] 	bne df_tk_asm_checknexttok
                             	; else symbol table exhausted
                             	; so no match found
                             	; Zero symbol counter
fa0f : 8584             [ 3] 	sta df_symoff		; Relies on A=0
                             	; Set C to indicate error (no match)
fa11 : 38               [ 2] 	sec
fa12 : 60               [ 6] 	rts
fa13 :                       df_tk_asm_symfound
                             	; Full match with keyword in symtable but
                             	; check the next buffer char is not alphanum
                             	; as this could be part of a symbol
                             	; Point to next buffer char in any case
                             	; y already points to char after keyword
fa13 : b90004           [ 4] 	lda df_linbuff,y
                             	; if it is an alphanum then
fa16 : 20b4d8           [ 6] 	jsr df_tk_isalphanum
                             	; do not count as a match
fa19 : b0d4             [ 4] 	bcs df_tk_asm_symnomatch
                             	; Save line buffer pointer (points to next char)
                             	; Clear C to indicate success (match)
fa1b : 847d             [ 3] 	sty df_linoff
fa1d : a584             [ 3] 	lda df_symoff
                             	; df_symtab points to the offset
fa1f :                       df_tk_asm_addr_mode_ok
fa1f : 18               [ 2] 	clc
fa20 : 60               [ 6] 	rts
                             
                             ;****************************************
                             ;* df_tk_asm_exec_parser
                             ;* Execute parse routine for this statement
                             ;* Input: a is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
fa21 :                       df_tk_asm_exec_parser
fa21 : 0a               [ 2] 	asl a
fa22 : aa               [ 2] 	tax
fa23 : bdddff           [ 4] 	lda df_tk_asm_tokenjmp,x
fa26 : 85a2             [ 3] 	sta df_tmpptra
AS65 Assembler for R6502 [1.42].                                     Page  285
---------------------------------- bank0.s -----------------------------------

fa28 : bddeff           [ 4] 	lda df_tk_asm_tokenjmp+1,x
fa2b : 85a3             [ 3] 	sta df_tmpptra+1
fa2d : 6ca200           [ 6] 	jmp (df_tmpptra)
                             
                             
                             ;****************************************
                             ;* df_tk_asm_addr_mode
                             ;* Tokenise the addressing mode
                             ;* Input: a is the token found
                             ;* Return: CC = Parsed ok, CS = Error
                             ;****************************************
fa30 :                       df_tk_asm_addr_mode
fa30 : 20c0d8           [ 6] 	jsr df_tk_skip_ws		;Skip whitespace
fa33 : c900             [ 2] 	cmp #0					;End of line?
fa35 : f0e8             [ 3] 	beq df_tk_asm_addr_mode_ok
fa37 : c93a             [ 2] 	cmp #':'				;End of statement?
fa39 : f0e4             [ 3] 	beq df_tk_asm_addr_mode_ok
fa3b : a923             [ 2] 	lda #'#'				; Check for immediate
fa3d : 20e4d8           [ 6] 	jsr df_tk_expect_tok
fa40 : b003             [ 3] 	bcs df_tk_asm_addr_mode_1
fa42 : 4c65fa           [ 3] 	jmp df_tk_imm		; Process immediate
fa45 :                       df_tk_asm_addr_mode_1
fa45 : a928             [ 2] 	lda #'('				; One of indirect modes?
fa47 : 20e4d8           [ 6] 	jsr df_tk_expect_tok
fa4a : b003             [ 3] 	bcs df_tk_asm_addr_mode_2
fa4c : 4c68fa           [ 3] 	jmp df_tk_indirect
fa4f :                       df_tk_asm_addr_mode_2
                             	; here just a regular address
                             	; Just one expression expected
fa4f : 20e1da           [ 6] 	jsr df_tk_expression
                             	; Is there a comma after the expression
fa52 : a92c             [ 2] 	lda #','
fa54 : 20e4d8           [ 6] 	jsr df_tk_expect_tok
fa57 : b0c6             [ 3] 	bcs df_tk_asm_addr_mode_ok
                             	; must be x or y
fa59 : a978             [ 2] 	lda #'x'
fa5b : 20e4d8           [ 6] 	jsr df_tk_expect_tok
fa5e : 90bf             [ 3] 	bcc df_tk_asm_addr_mode_ok
                             	; got to here, must be y
fa60 : a979             [ 2] 	lda #'y'
fa62 : 4cefd8           [ 3] 	jmp df_tk_expect_tok_err
                             	
                             	
                             ;* Tokenise immediate addressing mode	
fa65 :                       df_tk_imm
                             	; Just one expression expected
fa65 : 4ce1da           [ 3] 	jmp df_tk_expression
                             	
                             ;* Tokenise indirect
fa68 :                       df_tk_indirect
                             	; Just one expression expected
fa68 : 20e1da           [ 6] 	jsr df_tk_expression
                             	; Is there a comma after the expression
fa6b : a92c             [ 2] 	lda #','
fa6d : 20e4d8           [ 6] 	jsr df_tk_expect_tok
                             	; if not then might be indirect Y
fa70 : b00a             [ 3] 	bcs df_tk_indirect_y
                             	; Else must have be indirect "x)"
fa72 : a978             [ 2] 	lda #'x'
fa74 : 20efd8           [ 6] 	jsr df_tk_expect_tok_err
fa77 : a929             [ 2] 	lda #')'
fa79 : 4cefd8           [ 3] 	jmp df_tk_expect_tok_err
AS65 Assembler for R6502 [1.42].                                     Page  286
---------------------------------- bank0.s -----------------------------------

                             	
fa7c :                       df_tk_indirect_y
                             	; Definitely has a close bracket
fa7c : a929             [ 2] 	lda #')'
fa7e : 20efd8           [ 6] 	jsr df_tk_expect_tok_err
                             	; Is there a comma after the expression
fa81 : a92c             [ 2] 	lda #','
fa83 : 20e4d8           [ 6] 	jsr df_tk_expect_tok
fa86 : b005             [ 3] 	bcs df_tk_indirect_done
                             	; if comma then must be indirect y
fa88 : a979             [ 2] 	lda #'y'
fa8a : 4cefd8           [ 3] 	jmp df_tk_expect_tok_err
                             
fa8d :                       df_tk_indirect_done
fa8d : 18               [ 2] 	clc
fa8e : 60               [ 6] 	rts
                             	
                             
                             	
                             
                             
                             ;************************************************
                             ;*           TOKENISATION SUBROUTINES
                             ;************************************************
                             
                             
                             ;* HANDLE DIRECTIVES
                             
                             ;* All tokenisation is part of regular toksub rou
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
fa8f :                       mod_sz_tkasm_e
                             
                             
                             	include "dflat/rtasm.s"
                             ;************************************************
AS65 Assembler for R6502 [1.42].                                     Page  287
---------------------------------- bank0.s -----------------------------------

                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  RTASM.S
                             ;*  Module that implements the runtime execution 
                             ;*  assembler.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
fa8f :                       mod_sz_rtasm_s
                             
fa8f :                       df_rt_asm_assemble
                             	; check if >=0x80 (directive or mnemonic)
fa8f : a489             [ 3] 	ldy df_exeoff
fa91 : b187             [ 5] 	lda (df_currlin),y
fa93 : 1009             [ 3] 	bpl df_rt_asm_do_label
fa95 : 20a2fa           [ 6] 	jsr df_rt_asm_command
fa98 : 2090fc           [ 6] 	jsr df_rt_asm_printCR
fa9b : 4ca1fa           [ 3] 	jmp df_rt_asm_assemble_done
fa9e :                       df_rt_asm_do_label
fa9e : 20c6fa           [ 6] 	jsr df_rt_asm_label
faa1 :                       df_rt_asm_assemble_done
                             	; any clean up here
faa1 : 60               [ 6] 	rts
                             
                             ; Jump to mnemonic or 
                             ; directive with index in A ignoring MSB
faa2 :                       df_rt_asm_command
faa2 : 297f             [ 2] 	and #0x7f
faa4 : 48               [ 3] 	pha
faa5 : aa               [ 2] 	tax
                             	; Point to Xth symtable entry of addr modes and 
faa6 : 205efd           [ 6] 	jsr df_rt_asm_skip_to_sym
                             
                             	; Get first addressing mode (ignoring offset byt
faa9 : a001             [ 2] 	ldy #1
faab : b182             [ 5] 	lda (df_symtab),y
                             	; is it a directive?
faad : c910             [ 2] 	cmp #AM_DIR
                             	; if directive
faaf : f003             [ 3] 	beq df_rt_asm_dir
                             	; Else must be a normal mnemonic
fab1 : 4c8cfb           [ 3] 	jmp df_rt_asm_mnem
                             
                             ; Jump to the appropriate directive
fab4 :                       df_rt_asm_dir
                             	; Get the index and *2
                             	; to get jump vector
fab4 : 68               [ 4] 	pla
fab5 : 0a               [ 2] 	asl a
fab6 : aa               [ 2] 	tax
                             	; jump over directive code
fab7 : e689             [ 5] 	inc df_exeoff
                             	; jump to directive handler
fab9 : bde7ff           [ 4] 	lda df_rt_asm_tokenjmp,x
AS65 Assembler for R6502 [1.42].                                     Page  288
---------------------------------- bank0.s -----------------------------------

fabc : 85a2             [ 3] 	sta df_tmpptra
fabe : bde8ff           [ 4] 	lda df_rt_asm_tokenjmp+1,x
fac1 : 85a3             [ 3] 	sta df_tmpptra+1
fac3 : 6ca200           [ 6] 	jmp (df_tmpptra)
                             
                             ; Process label
                             ; Set the label to the PC
fac6 :                       df_rt_asm_label
                             	; Get the address of the variable in A,X
fac6 : 2046ee           [ 6] 	jsr df_rt_generate_lvar
fac9 : 869f             [ 3] 	stx df_asmoprnd
facb : 85a0             [ 3] 	sta df_asmoprnd+1
                             	; Assign to value of PC
facd : a000             [ 2] 	ldy #0
facf : a59a             [ 3] 	lda df_asmpc
fad1 : 919f             [ 5] 	sta (df_asmoprnd),y
fad3 : a59b             [ 3] 	lda df_asmpc+1
fad5 : c8               [ 2] 	iny
fad6 : 919f             [ 5] 	sta (df_asmoprnd),y
fad8 : 60               [ 6] 	rts	
                             
                             ;* Set the code origin
fad9 :                       df_rt_asm_org
                             	; Get the address from expression
fad9 : 203bfd           [ 6] 	jsr df_rt_asm_get_operand
                             	; Put this in to PC
fadc : a59f             [ 3] 	lda df_asmoprnd
fade : 859a             [ 3] 	sta df_asmpc
fae0 : a5a0             [ 3] 	lda df_asmoprnd+1
fae2 : 859b             [ 3] 	sta df_asmpc+1
fae4 : a903             [ 2] 	lda #3
fae6 : 85a1             [ 3] 	sta df_asmlen
fae8 : 4c52fc           [ 3] 	jmp df_rt_asm_printPC
                             
                             ; Set the assembly option
                             ; Bit 0 set = Print code to console
                             ; But 1 set = Write code to memory
                             ; Be sure to run 2 non-write passes
                             ; before a write pass
                             ; First pass may result in ZP used a lot
                             ; Second pass resolves forward refs to ABS
                             ; Final write pass then stores the code
faeb :                       df_rt_asm_opt
                             	; Get the value from expression
faeb : 203bfd           [ 6] 	jsr df_rt_asm_get_operand
                             	; Put this in to OPT
faee : a59f             [ 3] 	lda df_asmoprnd
faf0 : 859c             [ 3] 	sta df_asmopt
faf2 : 60               [ 6] 	rts
                             
                             ; dw and db handled here
                             ; keep going through comma separated
                             ; list and write bytes or words
                             ; string expansion also handled
faf3 :                       df_rt_asm_db
faf3 : a902             [ 2] 	lda #2
faf5 : 2c                    	db	0x2c			; BIT abs to ignore next 2 bytes
faf6 :                       df_rt_asm_dw
faf6 : a903             [ 2] 	lda #3
faf8 :                       df_rt_asm_db_start
faf8 : 85a1             [ 3] 	sta df_asmlen
fafa : 2052fc           [ 6] 	jsr df_rt_asm_printPC
AS65 Assembler for R6502 [1.42].                                     Page  289
---------------------------------- bank0.s -----------------------------------

fafd : 206dfc           [ 6] 	jsr df_rt_asm_printSPC
fb00 :                       df_rt_asm_data
fb00 : 2026e2           [ 6] 	jsr df_rt_neval		; Evaluate expression
fb03 : 2095f7           [ 6] 	jsr df_ost_peekType	; What is the type
fb06 : 2904             [ 2] 	and #DFST_STR
fb08 : d00d             [ 3] 	bne df_rt_asm_string; If string
fb0a : 209bf7           [ 6] 	jsr df_ost_popInt	; else get number in A,X
fb0d : 869f             [ 3] 	stx df_asmoprnd		; store low value
fb0f : 85a0             [ 3] 	sta df_asmoprnd+1	; store high value
fb11 : 203ffb           [ 6] 	jsr df_rt_asm_data_write
fb14 : 4c34fb           [ 3] 	jmp df_rt_asm_data_next
fb17 :                       df_rt_asm_string
fb17 : 20a3f7           [ 6] 	jsr df_ost_popPtr	; pop string pointer
fb1a : 86a2             [ 3] 	stx df_tmpptra		; save pointer to tmpa
fb1c : 85a3             [ 3] 	sta df_tmpptra+1
fb1e :                       df_rt_asm_string_ch
fb1e : a000             [ 2] 	ldy #0
fb20 : b1a2             [ 5] 	lda (df_tmpptra),y	; Get string char, 0=done
fb22 : f010             [ 3] 	beq df_rt_asm_data_next
fb24 : 859f             [ 3] 	sta df_asmoprnd		; Save as operand
fb26 : 84a0             [ 3] 	sty df_asmoprnd+1	; High is always zero
fb28 : 203ffb           [ 6] 	jsr df_rt_asm_data_write
                             	_incZPWord df_tmpptra
                             
fb31 : 4c1efb           [ 3] 	jmp df_rt_asm_string_ch
fb34 :                       df_rt_asm_data_next
fb34 : 207cee           [ 6] 	jsr df_rt_eos		; End?
fb37 : b005             [ 3] 	bcs df_rt_asm_data_done
fb39 : e689             [ 5] 	inc df_exeoff		; Jump over ','
fb3b : 4c00fb           [ 3] 	jmp df_rt_asm_data
fb3e :                       df_rt_asm_data_done
fb3e : 60               [ 6] 	rts	
                             
                             ; Write one db or dw value
                             ; Check for value too big for db
                             ; Advance PC by df_asmlen
fb3f :                       df_rt_asm_data_write
fb3f : 2076fc           [ 6] 	jsr df_rt_asm_printOPR
fb42 :                       df_rt_asm_data_write_skip1
fb42 : a902             [ 2] 	lda #2
fb44 : 259c             [ 3] 	and df_asmopt
fb46 : f017             [ 3] 	beq df_rt_asm_data_write_skip2
fb48 : a59f             [ 3] 	lda df_asmoprnd
fb4a : a000             [ 2] 	ldy #0
fb4c : 919a             [ 5] 	sta (df_asmpc),y
fb4e : c8               [ 2] 	iny
fb4f : a902             [ 2] 	lda #2
fb51 : c5a1             [ 3] 	cmp df_asmlen
fb53 : d006             [ 3] 	bne df_rt_asm_data_write_hi
fb55 : a5a0             [ 3] 	lda df_asmoprnd+1
fb57 : d014             [ 3] 	bne df_rt_asm_data_write_err
fb59 : f004             [ 3] 	beq df_rt_asm_data_write_skip2
fb5b :                       df_rt_asm_data_write_hi
fb5b : a5a0             [ 3] 	lda df_asmoprnd+1
fb5d : 919a             [ 5] 	sta (df_asmpc),y
fb5f :                       df_rt_asm_data_write_skip2
fb5f : a4a1             [ 3] 	ldy df_asmlen
fb61 : 88               [ 2] 	dey					; Add 1 less!
fb62 : 98               [ 2] 	tya
fb63 : 18               [ 2] 	clc
fb64 : 659a             [ 3] 	adc df_asmpc
fb66 : 859a             [ 3] 	sta df_asmpc
AS65 Assembler for R6502 [1.42].                                     Page  290
---------------------------------- bank0.s -----------------------------------

                             	_bcc 2
                             
fb6a : e69b             [ 5] 	inc df_asmpc+1
fb6c : 60               [ 6] 	rts
fb6d :                       df_rt_asm_data_write_err	
                             	SWBRK DFERR_QUANTITY
                             
                             	
                             	
fb6f :                       df_rt_asm_ds
fb6f : 2052fc           [ 6] 	jsr df_rt_asm_printPC
fb72 : 206dfc           [ 6] 	jsr df_rt_asm_printSPC
                             	; Get the address from expression
fb75 : 203bfd           [ 6] 	jsr df_rt_asm_get_operand
                             	; ADD this in to PC
fb78 : 18               [ 2] 	clc
fb79 : a59f             [ 3] 	lda df_asmoprnd
fb7b : 659a             [ 3] 	adc df_asmpc
fb7d : 859a             [ 3] 	sta df_asmpc
fb7f : a5a0             [ 3] 	lda df_asmoprnd+1
fb81 : 659b             [ 3] 	adc df_asmpc+1
fb83 : 859b             [ 3] 	sta df_asmpc+1
                             	; len=1 for printing
fb85 : a903             [ 2] 	lda #3
fb87 : 85a1             [ 3] 	sta df_asmlen
fb89 : 4c76fc           [ 3] 	jmp df_rt_asm_printOPR
                             
                             
                             ; Process a normal assembler mnemonic
fb8c :                       df_rt_asm_mnem
fb8c : 68               [ 4] 	pla				; Throw away previous temp variable
                             	; jump over mnemonic code
fb8d : e689             [ 5] 	inc df_exeoff
                             	; work out the addressing mode and get operand
fb8f : 20befc           [ 6] 	jsr df_rt_asm_addrmode
                             
fb92 :                       df_rt_asm_mnem_try
fb92 : a59d             [ 3] 	lda df_asmadmd					; With the addressing mode
fb94 : 2046fd           [ 6] 	jsr df_rt_asm_find_addr_mode	; Find it for this 
fb97 : c900             [ 2] 	cmp #AM_NONE					; Exists?
fb99 : d014             [ 3] 	bne	df_rt_asm_mnem_chk			; If does then check it
fb9b :                       df_rt_asm_check_alt
fb9b : a69d             [ 3] 	ldx df_asmadmd					; Use ad mode as an index
fb9d : bd9bfd           [ 4] 	lda df_asm_altaddrmode,x		; Else get alternate
fba0 : c900             [ 2] 	cmp #AM_NONE					; Is there an alternate?
fba2 : f02d             [ 3] 	beq df_rt_asm_mnem_err			; If no then error
fba4 : 2046fd           [ 6] 	jsr df_rt_asm_find_addr_mode	; Check does mode e
fba7 : c900             [ 2] 	cmp #AM_NONE					; this instruction
fba9 : f026             [ 3] 	beq df_rt_asm_mnem_err			; if no then error
fbab : c59d             [ 3] 	cmp df_asmadmd					; Same as the original?
fbad : f00e             [ 3] 	beq df_rt_asm_mnem_done			; if so then done
fbaf :                       df_rt_asm_mnem_chk
fbaf : 859d             [ 3] 	sta df_asmadmd					; This is the final mode
fbb1 : aa               [ 2] 	tax								; Get the length
fbb2 : bd8afd           [ 4] 	lda df_asm_length,x
fbb5 : a6a0             [ 3] 	ldx df_asmoprnd+1				; Is operand hi non-zero?
fbb7 : f004             [ 3] 	beq df_rt_asm_mnem_done			; If zero then done
fbb9 : c903             [ 2] 	cmp #3							; Else must be len 3?
fbbb : d0de             [ 3] 	bne df_rt_asm_check_alt			; Try an alternate
fbbd :                       df_rt_asm_mnem_done
fbbd : a69d             [ 3] 	ldx df_asmadmd					; Get the final mode index
fbbf : bd8afd           [ 4] 	lda df_asm_length,x				; Get the length
AS65 Assembler for R6502 [1.42].                                     Page  291
---------------------------------- bank0.s -----------------------------------

fbc2 : 85a1             [ 3] 	sta df_asmlen
fbc4 : a59d             [ 3] 	lda df_asmadmd					; Get the final mode
fbc6 : 2046fd           [ 6] 	jsr df_rt_asm_find_addr_mode	; Get the Y index o
                             	; Ok now get the opcode
fbc9 : c8               [ 2] 	iny
fbca : b182             [ 5] 	lda (df_symtab),y
fbcc : 859e             [ 3] 	sta df_asmopcde
                             	; Now have all information to assemble
fbce : 4cd3fb           [ 3] 	jmp df_rt_asm_encode
                             	
fbd1 :                       df_rt_asm_mnem_err
                             	SWBRK DFERR_SYNTAX
                             
                             	
                             ; Take assembler data and encode it
                             ; depending on the current option
                             ; Option 0 = No write
                             ; Option 1 = No write, Print
                             ; Option 2 = Write
                             ; Option 3 = Write, Print
fbd3 :                       df_rt_asm_encode
                             	; Only write the code if bit 1=1
fbd3 : a902             [ 2] 	lda #0x02
fbd5 : 259c             [ 3] 	and df_asmopt
fbd7 : f059             [ 4] 	beq df_rt_asm_encode_print
fbd9 : a000             [ 2] 	ldy #0
fbdb : a59e             [ 3] 	lda df_asmopcde
fbdd : 919a             [ 5] 	sta (df_asmpc),y
fbdf : a5a1             [ 3] 	lda df_asmlen
fbe1 : c901             [ 2] 	cmp #1						; No operand
fbe3 : f04d             [ 4] 	beq df_rt_asm_encode_print
fbe5 : c903             [ 2] 	cmp #3						; Word operand
fbe7 : f03f             [ 4] 	beq df_rt_asm_encode_writeword
                             	; If here then byte operand
                             	; Check relative then need to calculate offset
fbe9 : a59d             [ 3] 	lda df_asmadmd
fbeb : c90f             [ 2] 	cmp #AM_REL
fbed : d02c             [ 4] 	bne df_rt_asm_encode_skiprel
                             	; calculate distance from PC
                             	; first take 2 off operand
fbef : 38               [ 2] 	sec
fbf0 : a59f             [ 3] 	lda df_asmoprnd
fbf2 : e902             [ 2] 	sbc #2
fbf4 : 859f             [ 3] 	sta df_asmoprnd
fbf6 : a5a0             [ 3] 	lda df_asmoprnd+1
fbf8 : e900             [ 2] 	sbc #0
fbfa : 85a0             [ 3] 	sta df_asmoprnd+1
                             	; now calculate current operand-PC
fbfc : 38               [ 2] 	sec
fbfd : a59f             [ 3] 	lda df_asmoprnd
fbff : e59a             [ 3] 	sbc df_asmpc
fc01 : 859f             [ 3] 	sta df_asmoprnd
fc03 : a5a0             [ 3] 	lda df_asmoprnd+1
fc05 : e59b             [ 3] 	sbc df_asmpc+1
                             	; A contains high byte result of subtraction
                             	; and must be 0 (operand <=127) or 255 (operand 
fc07 : 85a0             [ 3] 	sta df_asmoprnd+1
fc09 : f00a             [ 3] 	beq df_rt_asm_rel_postive
fc0b : c9ff             [ 2] 	cmp #0xff				; If not 0xff then error
fc0d : d010             [ 3] 	bne df_rt_asm_err_quantity
                             	; Check negative branch >=128 (N=1)
fc0f : a59f             [ 3] 	lda df_asmoprnd
AS65 Assembler for R6502 [1.42].                                     Page  292
---------------------------------- bank0.s -----------------------------------

fc11 : 100c             [ 3] 	bpl df_rt_asm_err_quantity
fc13 : 300c             [ 3] 	bmi df_rt_asm_encode_writebyte
fc15 :                       df_rt_asm_rel_postive
                             	; Check positive branch <=127
fc15 : a59f             [ 3] 	lda df_asmoprnd
fc17 : 3006             [ 3] 	bmi df_rt_asm_err_quantity
fc19 : 1006             [ 3] 	bpl df_rt_asm_encode_writebyte
fc1b :                       df_rt_asm_encode_skiprel
                             	; byte operand, high byte must be zero
fc1b : a5a0             [ 3] 	lda df_asmoprnd+1
fc1d : f002             [ 3] 	beq df_rt_asm_encode_writebyte
fc1f :                       df_rt_asm_err_quantity
                             	SWBRK DFERR_QUANTITY
                             
fc21 :                       df_rt_asm_encode_writebyte
fc21 : a59f             [ 3] 	lda df_asmoprnd
fc23 : c8               [ 2] 	iny 
fc24 : 919a             [ 5] 	sta (df_asmpc),y
                             	; Due to the iny, relying on Z=0 here!
fc26 : d00a             [ 3] 	bne df_rt_asm_encode_print
fc28 :                       df_rt_asm_encode_writeword
fc28 : c8               [ 2] 	iny 
fc29 : a59f             [ 3] 	lda df_asmoprnd
fc2b : 919a             [ 5] 	sta (df_asmpc),y
fc2d : c8               [ 2] 	iny 
fc2e : a5a0             [ 3] 	lda df_asmoprnd+1
fc30 : 919a             [ 5] 	sta (df_asmpc),y	
fc32 :                       df_rt_asm_encode_print
fc32 : 2042fc           [ 6] 	jsr df_rt_asm_print_mmen
                             	; advance pc
fc35 : 18               [ 2] 	clc
fc36 : a59a             [ 3] 	lda df_asmpc
fc38 : 65a1             [ 3] 	adc df_asmlen
fc3a : 859a             [ 3] 	sta df_asmpc
                             	_bcc 2
                             
fc3e : e69b             [ 5] 	inc df_asmpc+1
fc40 : 18               [ 2] 	clc
fc41 : 60               [ 6] 	rts
                             
                             
                             ; Print the full 1,2,3 byte instruction
                             ; depends on df_asmopt
fc42 :                       df_rt_asm_print_mmen
fc42 : 2052fc           [ 6] 	jsr df_rt_asm_printPC
fc45 : 206dfc           [ 6] 	jsr df_rt_asm_printSPC
fc48 : 2062fc           [ 6] 	jsr df_rt_asm_printOPC
fc4b : 206dfc           [ 6] 	jsr df_rt_asm_printSPC
fc4e : 2076fc           [ 6] 	jsr df_rt_asm_printOPR
fc51 :                       df_rt_asm_print_rts			; Hopefully subs can get he
fc51 : 60               [ 6] 	rts
                             
fc52 :                       df_rt_asm_printPC
                             	; Check the option bit 0 (Print)
fc52 : a901             [ 2] 	lda #0x01
fc54 : 259c             [ 3] 	and df_asmopt
fc56 : f0f9             [ 3] 	beq df_rt_asm_print_rts
                             	; Print current PC
fc58 : a59b             [ 3] 	lda df_asmpc+1
fc5a : 2073c1           [ 6] 	jsr utilPrintA
fc5d : a59a             [ 3] 	lda df_asmpc
fc5f : 4c73c1           [ 3] 	jmp utilPrintA
AS65 Assembler for R6502 [1.42].                                     Page  293
---------------------------------- bank0.s -----------------------------------

                             
fc62 :                       df_rt_asm_printOPC
                             	; Check the option bit 0 (Print)
fc62 : a901             [ 2] 	lda #0x01
fc64 : 259c             [ 3] 	and df_asmopt
fc66 : f0e9             [ 3] 	beq df_rt_asm_print_rts
fc68 : a59e             [ 3] 	lda df_asmopcde
fc6a : 4c73c1           [ 3] 	jmp utilPrintA
                             
fc6d :                       df_rt_asm_printSPC
                             	; Check the option bit 0 (Print)
fc6d : a901             [ 2] 	lda #0x01
fc6f : 259c             [ 3] 	and df_asmopt
fc71 : f0de             [ 3] 	beq df_rt_asm_print_rts
fc73 : 4c63c1           [ 3] 	jmp utilPrintSPC
                             	
fc76 :                       df_rt_asm_printOPR
                             	; Check the option bit 0 (Print)
fc76 : a901             [ 2] 	lda #0x01
fc78 : 259c             [ 3] 	and df_asmopt
fc7a : f0d5             [ 3] 	beq df_rt_asm_print_rts	
fc7c : a5a1             [ 3] 	lda df_asmlen				; check how may operand bytes
fc7e : c901             [ 2] 	cmp #1						; if only opcode, done
fc80 : f0cf             [ 3] 	beq df_rt_asm_print_rts	
fc82 : c902             [ 2] 	cmp #2
fc84 : f005             [ 3] 	beq df_rt_asm_printOPR_1	; if only 2 do low byte
fc86 : a5a0             [ 3] 	lda df_asmoprnd+1
fc88 : 2073c1           [ 6] 	jsr utilPrintA
fc8b :                       df_rt_asm_printOPR_1
fc8b : a59f             [ 3] 	lda df_asmoprnd
fc8d : 4c73c1           [ 3] 	jmp utilPrintA
                             
fc90 :                       df_rt_asm_printCR
                             	; Check the option bit 0 (Print)
fc90 : a901             [ 2] 	lda #0x01
fc92 : 259c             [ 3] 	and df_asmopt
fc94 : f0bb             [ 3] 	beq df_rt_asm_print_rts
fc96 : 4c6bc1           [ 3] 	jmp utilPrintCRLF
                             
fc99 :                       df_rt_asm_printCH
fc99 : 8538             [ 3] 	sta tmp_d
                             	; Check the option bit 0 (Print)
fc9b : a901             [ 2] 	lda #0x01
fc9d : 259c             [ 3] 	and df_asmopt
fc9f : f0b0             [ 3] 	beq df_rt_asm_print_rts
fca1 : a538             [ 3] 	lda tmp_d
fca3 : 4c30c4           [ 3] 	jmp io_put_ch
                             
                             ; Print an entire line, but save df_exeoff
fca6 :                       df_rt_asm_printline
                             	; Check the option bit 0 (Print)
fca6 : a901             [ 2] 	lda #0x01
fca8 : 259c             [ 3] 	and df_asmopt
fcaa : f0a5             [ 3] 	beq df_rt_asm_print_rts
fcac : a589             [ 3] 	lda df_exeoff
fcae : 48               [ 3] 	pha
                             	; use df_tmpptra
                             	_cpyZPWord df_currlin, df_tmpptra
                             
fcb7 : 20a6ef           [ 6] 	jsr df_rt_list_line_only
fcba : 68               [ 4] 	pla
fcbb : 8589             [ 3] 	sta df_exeoff
AS65 Assembler for R6502 [1.42].                                     Page  294
---------------------------------- bank0.s -----------------------------------

fcbd : 60               [ 6] 	rts
                             
                             
                             ; Calculate the addressing mode
                             ; Populate the operand as needed
                             ; A and df_asmadmd contain Addressing Mode
fcbe :                       df_rt_asm_addrmode	
                             	; Store nothing in address mode
fcbe : a900             [ 2] 	lda #AM_NONE
fcc0 : 859d             [ 3] 	sta df_asmadmd
                             	; zero out the operand
fcc2 : a900             [ 2] 	lda #0
fcc4 : 859f             [ 3] 	sta df_asmoprnd
fcc6 : 85a0             [ 3] 	sta df_asmoprnd+1
fcc8 : 207cee           [ 6] 	jsr df_rt_eos			; End of statement?
fccb : b00d             [ 3] 	bcs df_rt_asm_AM_IMP
                             	; jump over whitespace
fccd : 2057e6           [ 6] 	jsr df_rt_skip_ws
                             	; Check what it is
fcd0 : c923             [ 2] 	cmp #'#'				; Immediate?
fcd2 : f034             [ 4] 	beq df_rt_asm_AM_IMM
fcd4 : c928             [ 2] 	cmp #'('				; Indirect something?
fcd6 : f03a             [ 4] 	beq df_rt_asm_AM_INDIRECT
                             	; Must be ABS,ZP or REL
fcd8 : d005             [ 3] 	bne df_rt_asm_ABSREL
                             ; Process IMP/ACC
fcda :                       df_rt_asm_AM_IMP
fcda : a90d             [ 2] 	lda #AM_IMP
fcdc : 859d             [ 3] 	sta df_asmadmd
fcde : 60               [ 6] 	rts
                             ; Process ABS or REL
fcdf :                       df_rt_asm_ABSREL	
                             	; Evaluate operand
fcdf : 203bfd           [ 6] 	jsr df_rt_asm_get_operand
                             
fce2 : 207cee           [ 6] 	jsr df_rt_eos			; End of statement?
fce5 : b00f             [ 3] 	bcs df_rt_asm_AM_ABS
fce7 : c8               [ 2] 	iny						; Jump over ","
fce8 : b187             [ 5] 	lda (df_currlin),y		; Load X or Y
fcea : c8               [ 2] 	iny						; Jump over index reg
fceb : 8589             [ 3] 	sta df_exeoff			; Save exe offset
fced : c978             [ 2] 	cmp #'x'				; Indirect X?
fcef : f012             [ 4] 	beq df_rt_asm_AM_ABSX
                             ; Process ABSY
fcf1 :                       df_rt_asm_AM_ABSY
fcf1 : a906             [ 2] 	lda #AM_ZPY				; Go for smallest modes
fcf3 : 859d             [ 3] 	sta df_asmadmd
fcf5 : 60               [ 6] 	rts
                             ; Process what looks like pure ABS, could be REL
fcf6 :                       df_rt_asm_AM_ABS
fcf6 : a001             [ 2] 	ldy #1					; Check first addressing mode
fcf8 : b182             [ 5] 	lda (df_symtab),y
fcfa : c90f             [ 2] 	cmp #AM_REL
fcfc : f002             [ 4] 	beq df_rt_asm_AM_REL
fcfe : a904             [ 2] 	lda #AM_ZP				; Go for smallest modes
fd00 :                       df_rt_asm_AM_REL
fd00 : 859d             [ 3] 	sta df_asmadmd
fd02 : 60               [ 6] 	rts
                             ; Process ABSX
fd03 :                       df_rt_asm_AM_ABSX
fd03 : a905             [ 2] 	lda #AM_ZPX				; Go for smallest modes
fd05 : 859d             [ 3] 	sta df_asmadmd
AS65 Assembler for R6502 [1.42].                                     Page  295
---------------------------------- bank0.s -----------------------------------

fd07 : 60               [ 6] 	rts
                             ; Process Immediate
fd08 :                       df_rt_asm_AM_IMM
                             	; skip over #
fd08 : e689             [ 5] 	inc df_exeoff
                             	; Get operand
fd0a : 203bfd           [ 6] 	jsr df_rt_asm_get_operand
                             	; Mark as immediate
fd0d : a90c             [ 2] 	lda #AM_IMM
fd0f : 859d             [ 3] 	sta df_asmadmd
fd11 : 60               [ 6] 	rts
                             ; Process indirect
fd12 :                       df_rt_asm_AM_INDIRECT
                             	; skip over (
fd12 : e689             [ 5] 	inc df_exeoff
                             	; Calculate the operand
fd14 : 203bfd           [ 6] 	jsr df_rt_asm_get_operand
                             	; what is next char?
fd17 : a489             [ 3] 	ldy df_exeoff
fd19 : b187             [ 5] 	lda (df_currlin),y
fd1b : c929             [ 2] 	cmp #')'			; Could be IND or INDY
fd1d : f009             [ 3] 	beq df_rt_asm_AM_ZPINDORY
                             	; else must be INDX
                             	; skip 'x)'
fd1f : c8               [ 2] 	iny
fd20 : c8               [ 2] 	iny
fd21 : 8489             [ 3] 	sty df_exeoff
fd23 : a908             [ 2] 	lda #AM_ZPINDX
fd25 : 859d             [ 3] 	sta df_asmadmd
fd27 : 60               [ 6] 	rts
                             ; Pure indirect mode found
fd28 :                       df_rt_asm_AM_ZPINDORY
fd28 : a907             [ 2] 	lda #AM_ZPIND			; Assume ZPIND
fd2a : c8               [ 2] 	iny
fd2b : 8489             [ 3] 	sty df_exeoff
                             	; if at end of line/statement then pure indirect
fd2d : 207cee           [ 6] 	jsr df_rt_eos			; End of statement?
fd30 : b006             [ 3] 	bcs df_rt_asm_AM_ZPIND
                             	; else must be INDY
fd32 : a909             [ 2] 	lda #AM_ZPINDY
                             	; skip ',Y'
fd34 : c8               [ 2] 	iny
fd35 : c8               [ 2] 	iny
fd36 : 8489             [ 3] 	sty df_exeoff
fd38 :                       df_rt_asm_AM_ZPIND
fd38 : 859d             [ 3] 	sta df_asmadmd
fd3a : 60               [ 6] 	rts
                             
                             ; Get and save the operand
                             ; df_asmoprnd contains the result
fd3b :                       df_rt_asm_get_operand
                             	; evaluate
fd3b : 2026e2           [ 6] 	jsr df_rt_neval
                             	; Get the parameter from stack
fd3e : 209bf7           [ 6] 	jsr df_ost_popInt
                             	; put in the operand
fd41 : 869f             [ 3] 	stx df_asmoprnd
fd43 : 85a0             [ 3] 	sta df_asmoprnd+1
fd45 : 60               [ 6] 	rts
                             	
                             ; From current symtab entry, find addressing
                             ; mode in A.  AM_NONE=Not found, Y=index
AS65 Assembler for R6502 [1.42].                                     Page  296
---------------------------------- bank0.s -----------------------------------

fd46 :                       df_rt_asm_find_addr_mode
                             	; save A in tmp
fd46 : 8538             [ 3] 	sta tmp_d
                             	; Start first entry (1) - 2 = 0xff
fd48 : a0ff             [ 2] 	ldy #0xff
fd4a : a200             [ 2] 	ldx #0
fd4c :                       df_rt_asm_find_addr_mode_loop
                             	; next entry
fd4c : c8               [ 2] 	iny
fd4d : c8               [ 2] 	iny
                             	; if current index > num entries then error
fd4e : 98               [ 2] 	tya
fd4f : 38               [ 2] 	sec
fd50 : e182             [ 6] 	sbc (df_symtab,x)
fd52 : b007             [ 3] 	bcs df_rt_asm_find_addr_mode_err
                             	; is symtab addressing mode what we want?
fd54 : b182             [ 5] 	lda (df_symtab),y
fd56 : c538             [ 3] 	cmp tmp_d
fd58 : d0f2             [ 3] 	bne df_rt_asm_find_addr_mode_loop
                             	; done A=mode, y=index in to df_symtab
fd5a : 60               [ 6] 	rts
fd5b :                       df_rt_asm_find_addr_mode_err
fd5b : a900             [ 2] 	lda #AM_NONE
fd5d :                       df_rt_asm_skip_to_sym_done; Used by function belo
fd5d : 60               [ 6] 	rts
                             
                             
                             ; Skip X amount of symbols in table
                             ; A contains how many addr mode and op code bytes
                             ; df_symtab points to offset byte
fd5e :                       df_rt_asm_skip_to_sym
fd5e : e8               [ 2] 	inx				; so done when X=0
                             	; Start at token symbols beginning
fd5f : a9ac             [ 2] 	lda #lo(df_asm_tokensyms)
fd61 : 8582             [ 3] 	sta df_symtab
fd63 : a9fd             [ 2] 	lda #hi(df_asm_tokensyms)
fd65 : 8583             [ 3] 	sta df_symtab+1
fd67 : a900             [ 2] 	lda #0
fd69 : 8584             [ 3] 	sta df_symoff
fd6b : a8               [ 2] 	tay
fd6c :                       df_rt_asm_skip_to_sym_next
                             	; Get symtable char
fd6c : b182             [ 5] 	lda (df_symtab),y
                             	; if < ' ' then jumped over symbol chars
fd6e : c920             [ 2] 	cmp #' '
fd70 : 9009             [ 3] 	bcc df_rt_asm_skip_to_sym_end
                             	;else next smy tab char
                             	_incZPWord df_symtab
                             
fd78 : 4c6cfd           [ 3] 	jmp df_rt_asm_skip_to_sym_next
                             	; Found end of symbol
fd7b :                       df_rt_asm_skip_to_sym_end
                             	;if done then return
fd7b : ca               [ 2] 	dex
fd7c : f0df             [ 3] 	beq df_rt_asm_skip_to_sym_done
                             	;jump over addr and op code by A bytes
fd7e : 38               [ 2] 	sec
fd7f : 6582             [ 3] 	adc df_symtab
fd81 : 8582             [ 3] 	sta df_symtab
                             	_bcc 2
                             
fd85 : e683             [ 5] 	inc df_symtab+1
AS65 Assembler for R6502 [1.42].                                     Page  297
---------------------------------- bank0.s -----------------------------------

fd87 : 4c6cfd           [ 3] 	jmp df_rt_asm_skip_to_sym_next
                             
fd8a :                       mod_sz_rtasm_e
                             
                             
                             	include "dflat/asmsymtab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASMSYMTAB.S
                             ;*	Mainly this contains the symbol table for asse
                             ;*	mnemonics but also meta data like what address
                             ;*	and the length of opcodes.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             	;* Length of each addressing mode
                             	;* ORDER significant!
fd8a :                       df_asm_length
fd8a : 00030303020202..      	db	0,3,3,3,2,2,2,2,2,2,3,3,2,1,1,2,0
                             
                             	; Always try for lowest addressing mode, but
                             	; this table maps to alternative
fd9b :                       df_asm_altaddrmode
fd9b : 00                    	db AM_NONE		;AM_NONE	= 0
fd9c : 00                    	db AM_NONE		;AM_ABS	 	= 1
fd9d : 00                    	db AM_NONE		;AM_ABSX	= 2
fd9e : 00                    	db AM_NONE		;AM_ABSY	= 3
fd9f : 01                    	db AM_ABS		;AM_ZP		= 4
fda0 : 02                    	db AM_ABSX		;AM_ZPX		= 5
fda1 : 03                    	db AM_ABSY		;AM_ZPY		= 6
fda2 : 0a                    	db AM_ABSIND	;AM_ZPIND	= 7
fda3 : 0b                    	db AM_ABSINDX	;AM_ZPINDX	= 8
fda4 : 09                    	db AM_ZPINDY	;AM_ZPINDY	= 9
fda5 : 00                    	db AM_NONE		;AM_ABSIND	= 10
fda6 : 00                    	db AM_NONE		;AM_ABSINDX	= 11
fda7 : 00                    	db AM_NONE		;AM_IMM		= 12
fda8 : 00                    	db AM_NONE		;AM_ACC		= 13
fda9 : 00                    	db AM_NONE		;AM_IMP		= AM_ACC
fdaa : 0f                    	db AM_REL		;AM_REL		= 15
fdab : 00                    	db AM_NONE		;AM_DIR		= 16
                             
                             
                             	;*	Mnemonic/	How many addressing modes /
                             	;* 	Mode		Opcode for mode
fdac :                       df_asm_tokensyms
                             	;* Start with directives
fdac : 2e6f726702            	db	".org",		1*2
fdb1 : 1000                  	db	AM_DIR,		0x00
fdb3 : 2e6f707402            	db	".opt",		1*2
fdb8 : 1000                  	db	AM_DIR,		0x00
fdba : 2e646202              	db	".db",		1*2
fdbe : 1000                  	db	AM_DIR,		0x00
fdc0 : 2e647702              	db	".dw",		1*2
AS65 Assembler for R6502 [1.42].                                     Page  298
---------------------------------- bank0.s -----------------------------------

fdc4 : 1000                  	db	AM_DIR,		0x00
fdc6 : 2e647302              	db	".ds",		1*2
fdca : 1000                  	db	AM_DIR,		0x00	
                             
fdcc : 61646310              	db	"adc",		8*2
fdd0 : 0c69                  	db	AM_IMM,		0x69
fdd2 : 0465                  	db	AM_ZP,		0x65
fdd4 : 0575                  	db	AM_ZPX,		0x75
fdd6 : 016d                  	db	AM_ABS,		0x6d
fdd8 : 027d                  	db	AM_ABSX,	0x7d
fdda : 0379                  	db	AM_ABSY,	0x79
fddc : 0861                  	db	AM_ZPINDX,	0x61
fdde : 0971                  	db	AM_ZPINDY,	0x71
                             	
fde0 : 616e6410              	db	"and",		8*2
fde4 : 0c29                  	db	AM_IMM,		0x29
fde6 : 0425                  	db	AM_ZP,		0x25
fde8 : 0535                  	db	AM_ZPX,		0x35
fdea : 012d                  	db	AM_ABS,		0x2d
fdec : 023d                  	db	AM_ABSX,	0x3d
fdee : 0339                  	db	AM_ABSY,	0x39
fdf0 : 0821                  	db	AM_ZPINDX,	0x21
fdf2 : 0931                  	db	AM_ZPINDY,	0x31
                             
fdf4 : 636d7010              	db	"cmp",		8*2
fdf8 : 0cc9                  	db	AM_IMM,		0xc9
fdfa : 04c5                  	db	AM_ZP,		0xc5
fdfc : 05d5                  	db	AM_ZPX,		0xd5
fdfe : 01cd                  	db	AM_ABS,		0xcd
fe00 : 02dd                  	db	AM_ABSX,	0xdd
fe02 : 03d9                  	db	AM_ABSY,	0xd9
fe04 : 08c1                  	db	AM_ZPINDX,	0xc1
fe06 : 09d1                  	db	AM_ZPINDY,	0xd1
                             
fe08 : 656f7210              	db	"eor",		8*2
fe0c : 0c49                  	db	AM_IMM,		0x49
fe0e : 0445                  	db	AM_ZP,		0x45
fe10 : 0555                  	db	AM_ZPX,		0x55
fe12 : 014d                  	db	AM_ABS,		0x4d
fe14 : 025d                  	db	AM_ABSX,	0x5d
fe16 : 0359                  	db	AM_ABSY,	0x59
fe18 : 0841                  	db	AM_ZPINDX,	0x41
fe1a : 0951                  	db	AM_ZPINDY,	0x51
                             
fe1c : 6c646110              	db	"lda",		8*2
fe20 : 0ca9                  	db	AM_IMM,		0xa9
fe22 : 04a5                  	db	AM_ZP,		0xa5
fe24 : 05b5                  	db	AM_ZPX,		0xb5
fe26 : 01ad                  	db	AM_ABS,		0xad
fe28 : 02bd                  	db	AM_ABSX,	0xbd
fe2a : 03b9                  	db	AM_ABSY,	0xb9
fe2c : 08a1                  	db	AM_ZPINDX,	0xa1
fe2e : 09b1                  	db	AM_ZPINDY,	0xb1
                             
fe30 : 6f726110              	db	"ora",		8*2
fe34 : 0c09                  	db	AM_IMM,		0x09
fe36 : 0405                  	db	AM_ZP,		0x05
fe38 : 0515                  	db	AM_ZPX,		0x15
fe3a : 010d                  	db	AM_ABS,		0x0d
fe3c : 021d                  	db	AM_ABSX,	0x1d
fe3e : 0319                  	db	AM_ABSY,	0x19
fe40 : 0801                  	db	AM_ZPINDX,	0x01
AS65 Assembler for R6502 [1.42].                                     Page  299
---------------------------------- bank0.s -----------------------------------

fe42 : 0911                  	db	AM_ZPINDY,	0x11
                             
fe44 : 73626310              	db	"sbc",		8*2
fe48 : 0ce9                  	db	AM_IMM,		0xe9
fe4a : 04e5                  	db	AM_ZP,		0xe5
fe4c : 05f5                  	db	AM_ZPX,		0xf5
fe4e : 01ed                  	db	AM_ABS,		0xed
fe50 : 02fd                  	db	AM_ABSX,	0xfd
fe52 : 03f9                  	db	AM_ABSY,	0xf9
fe54 : 08e1                  	db	AM_ZPINDX,	0xe1
fe56 : 09f1                  	db	AM_ZPINDY,	0xf1
                             
fe58 : 73746110              	db	"sta",		8*2
fe5c : 0485                  	db	AM_ZP,		0x85
fe5e : 0595                  	db	AM_ZPX,		0x95
fe60 : 018d                  	db	AM_ABS,		0x8d
fe62 : 029d                  	db	AM_ABSX,	0x9d
fe64 : 0399                  	db	AM_ABSY,	0x99
fe66 : 0881                  	db	AM_ZPINDX,	0x81
fe68 : 0991                  	db	AM_ZPINDY,	0x91
fe6a : 0792                  	db	AM_ZPIND,	0x92
                             
fe6c : 61736c0a              	db	"asl",		5*2
fe70 : 0d0a                  	db	AM_IMP,		0x0a
fe72 : 0406                  	db	AM_ZP,		0x06
fe74 : 0516                  	db	AM_ZPX,		0x16
fe76 : 010e                  	db	AM_ABS,		0x0e
fe78 : 021e                  	db	AM_ABSX,	0x1e
fe7a : 64656308              	db	"dec",		4*2
fe7e : 04c6                  	db	AM_ZP,		0xc6
fe80 : 05d6                  	db	AM_ZPX,		0xd6
fe82 : 01ce                  	db	AM_ABS,		0xce
fe84 : 02de                  	db	AM_ABSX,	0xde
fe86 : 696e6308              	db	"inc",		4*2
fe8a : 04e6                  	db	AM_ZP,		0xe6
fe8c : 05f6                  	db	AM_ZPX,		0xf6
fe8e : 01ee                  	db	AM_ABS,		0xee
fe90 : 02fe                  	db	AM_ABSX,	0xfe
fe92 : 6c73720a              	db	"lsr",		5*2
fe96 : 0d4a                  	db	AM_IMP,		0x4a
fe98 : 0446                  	db	AM_ZP,		0x46
fe9a : 0556                  	db	AM_ZPX,		0x56
fe9c : 014e                  	db	AM_ABS,		0x4e
fe9e : 025e                  	db	AM_ABSX,	0x5e
fea0 : 726f6c0a              	db	"rol",		5*2
fea4 : 0d2a                  	db	AM_IMP,		0x2a
fea6 : 0426                  	db	AM_ZP,		0x26
fea8 : 0536                  	db	AM_ZPX,		0x36
feaa : 012e                  	db	AM_ABS,		0x2e
feac : 023e                  	db	AM_ABSX,	0x3e
feae : 726f720a              	db	"ror",		5*2
feb2 : 0d6a                  	db	AM_IMP,		0x6a
feb4 : 0466                  	db	AM_ZP,		0x66
feb6 : 0576                  	db	AM_ZPX,		0x76
feb8 : 016e                  	db	AM_ABS,		0x6e
feba : 027e                  	db	AM_ABSX,	0x7e
                             
febc : 62697404              	db	"bit",		2*2
fec0 : 0424                  	db	AM_ZP,		0x24
fec2 : 012c                  	db	AM_ABS,		0x2c
                             	
fec4 : 62726b02              	db	"brk",		1*2
AS65 Assembler for R6502 [1.42].                                     Page  300
---------------------------------- bank0.s -----------------------------------

fec8 : 0d00                  	db	AM_IMP,		0x00
                             	
feca : 636c6302              	db	"clc",		1*2
fece : 0d18                  	db	AM_IMP,		0x18
fed0 : 636c6402              	db	"cld",		1*2
fed4 : 0dd8                  	db	AM_IMP,		0xd8
fed6 : 636c6902              	db	"cli",		1*2
feda : 0d58                  	db	AM_IMP,		0x58
fedc : 636c7602              	db	"clv",		1*2
fee0 : 0db8                  	db	AM_IMP,		0xb8
fee2 : 73656302              	db	"sec",		1*2
fee6 : 0d38                  	db	AM_IMP,		0x38
fee8 : 73656402              	db	"sed",		1*2
feec : 0df8                  	db	AM_IMP,		0xf8
feee : 73656902              	db	"sei",		1*2
fef2 : 0d78                  	db	AM_IMP,		0x78
                             	
fef4 : 63707806              	db	"cpx",		3*2
fef8 : 0ce0                  	db	AM_IMM,		0xe0
fefa : 04e4                  	db	AM_ZP,		0xe4
fefc : 01ec                  	db	AM_ABS,		0xec
fefe : 63707906              	db	"cpy",		3*2
ff02 : 0cc0                  	db	AM_IMM,		0xc0
ff04 : 04c4                  	db	AM_ZP,		0xc4
ff06 : 01cc                  	db	AM_ABS,		0xcc
ff08 : 64657802              	db	"dex",		1*2
ff0c : 0dca                  	db	AM_IMP,		0xca
ff0e : 64657902              	db	"dey",		1*2
ff12 : 0d88                  	db	AM_IMP,		0x88
ff14 : 696e7802              	db	"inx",		1*2
ff18 : 0de8                  	db	AM_IMP,		0xe8
ff1a : 696e7902              	db	"iny",		1*2
ff1e : 0dc8                  	db	AM_IMP,		0xc8
ff20 : 6c64780a              	db	"ldx",		5*2
ff24 : 0ca2                  	db	AM_IMM,		0xa2
ff26 : 04a6                  	db	AM_ZP,		0xa6
ff28 : 06b6                  	db	AM_ZPY,		0xb6
ff2a : 01ae                  	db	AM_ABS,		0xae
ff2c : 03be                  	db	AM_ABSY,	0xbe
ff2e : 6c64790a              	db	"ldy",		5*2
ff32 : 0ca0                  	db	AM_IMM,		0xa0
ff34 : 04a4                  	db	AM_ZP,		0xa4
ff36 : 05b4                  	db	AM_ZPX,		0xb4
ff38 : 01ac                  	db	AM_ABS,		0xac
ff3a : 02bc                  	db	AM_ABSX,	0xbc
ff3c : 73747806              	db	"stx",		3*2
ff40 : 0486                  	db	AM_ZP,		0x86
ff42 : 0696                  	db	AM_ZPY,		0x96
ff44 : 018e                  	db	AM_ABS,		0x8e
ff46 : 73747906              	db	"sty",		3*2
ff4a : 0484                  	db	AM_ZP,		0x84
ff4c : 0594                  	db	AM_ZPX,		0x94
ff4e : 018c                  	db	AM_ABS,		0x8c
                             
ff50 : 62636302              	db	"bcc",		1*2
ff54 : 0f90                  	db	AM_REL,		0x90
ff56 : 62637302              	db	"bcs",		1*2
ff5a : 0fb0                  	db	AM_REL,		0xb0
ff5c : 62657102              	db	"beq",		1*2
ff60 : 0ff0                  	db	AM_REL,		0xf0
ff62 : 626d6902              	db	"bmi",		1*2
ff66 : 0f30                  	db	AM_REL,		0x30
AS65 Assembler for R6502 [1.42].                                     Page  301
---------------------------------- bank0.s -----------------------------------

ff68 : 626e6502              	db	"bne",		1*2
ff6c : 0fd0                  	db	AM_REL,		0xd0
ff6e : 62706c02              	db	"bpl",		1*2
ff72 : 0f10                  	db	AM_REL,		0x10
ff74 : 62766302              	db	"bvc",		1*2
ff78 : 0f50                  	db	AM_REL,		0x50
ff7a : 62767302              	db	"bvs",		1*2
ff7e : 0f70                  	db	AM_REL,		0x70
ff80 : 6a6d7004              	db	"jmp",		2*2
ff84 : 014c                  	db	AM_ABS,		0x4c
ff86 : 0a6c                  	db	AM_ABSIND,	0x6c
ff88 : 6a737202              	db	"jsr",		1*2
ff8c : 0120                  	db	AM_ABS,		0x20
                             	
ff8e : 6e6f7002              	db	"nop",		1*2
ff92 : 0dea                  	db	AM_IMP,		0xea
ff94 : 70686102              	db	"pha",		1*2
ff98 : 0d48                  	db	AM_IMP,		0x48
ff9a : 70687002              	db	"php",		1*2
ff9e : 0d08                  	db	AM_IMP,		0x08
ffa0 : 706c6102              	db	"pla",		1*2
ffa4 : 0d68                  	db	AM_IMP,		0x68
ffa6 : 706c7002              	db	"plp",		1*2
ffaa : 0d28                  	db	AM_IMP,		0x28
ffac : 72746902              	db	"rti",		1*2
ffb0 : 0d40                  	db	AM_IMP,		0x40
ffb2 : 72747302              	db	"rts",		1*2
ffb6 : 0d60                  	db	AM_IMP,		0x60
ffb8 : 74617802              	db	"tax",		1*2
ffbc : 0daa                  	db	AM_IMP,		0xaa
ffbe : 74617902              	db	"tay",		1*2
ffc2 : 0da8                  	db	AM_IMP,		0xa8
ffc4 : 74737802              	db	"tsx",		1*2
ffc8 : 0dba                  	db	AM_IMP,		0xba
ffca : 74786102              	db	"txa",		1*2
ffce : 0d8a                  	db	AM_IMP,		0x8a
ffd0 : 74787302              	db	"txs",		1*2
ffd4 : 0d9a                  	db	AM_IMP,		0x9a
ffd6 : 74796102              	db	"tya",		1*2
ffda : 0d98                  	db	AM_IMP,		0x98	
                             	
                             	;* Terminates with a zero
ffdc : 00                    	db	0
                             
                             	include	"dflat/asmjmptab.s"
                             ;************************************************
                             ;*
                             ;*	ORIC DFLAT
                             ;*	Dolo Miah (@6502Nerd)
                             ;*	Copyright (c) 2020
                             ;*  Free to use for any non-commercial purpose su
                             ;*  credit of original my authorship please!
                             ;*
                             ;*  ASMJUMPTAB.S
                             ;*  Runtime token jump table for assembler.
                             ;*  dflat uses four key tables to tokenise and ru
                             ;*  - df_tokensyms    - table of token symbols
                             ;*  - df_tk_tokentype - table of token types
                             ;*  - df_tk_tokenjmp  - table of tokenising routi
                             ;*  - df_rt_tokenjmp  - table of runtime routines
                             ;*  The key is the token symbols.  When a line is
                             ;*  in to the raw (untokenised) buffer, df_tokens
AS65 Assembler for R6502 [1.42].                                     Page  302
---------------------------------- bank0.s -----------------------------------

                             ;*  used to identify tokens.  The position of the
                             ;*  token is used to then look up type and jump v
                             ;*  in the other tables.
                             ;*
                             ;************************************************
                             
                             	; ROM code
                             	code  
                             
                             ; Tokeniser jump table
                             ; Only directives needed as all opcodes are handl
                             ; through a single routine
ffdd :                       df_tk_asm_tokenjmp
ffdd : 27e0                  	dw	df_tk_asm_org
ffdf : 27e0                  	dw	df_tk_asm_opt
ffe1 : 89df                  	dw	df_tk_asm_db
ffe3 : 89df                  	dw	df_tk_asm_dw
ffe5 : 27e0                  	dw	df_tk_asm_ds
                             
ffe7 :                       df_rt_asm_tokenjmp
ffe7 : d9fa                  	dw	df_rt_asm_org
ffe9 : ebfa                  	dw	df_rt_asm_opt
ffeb : f3fa                  	dw	df_rt_asm_db
ffed : f6fa                  	dw	df_rt_asm_dw
ffef : 6ffb                  	dw	df_rt_asm_ds
                             
                             
                             ;****************************************
                             ;* as_init
                             ;* Initialise assembler settings
                             ;****************************************
fff1 :                       asm_init
                             	; Zero the PC
fff1 : a900             [ 2] 	lda #0
fff3 : 859a             [ 3] 	sta df_asmpc
fff5 : 859b             [ 3] 	sta df_asmpc+1
                             	; Zero the option
fff7 : 859c             [ 3] 	sta df_asmopt
fff9 : 60               [ 6] 	rts
                             
fffa :                       mod_sz_asm_e
                             
fffa :                       mod_sz_language_e
                             	; End of Code
fffa :                       _code_end
                             
No errors in pass 2.
Wrote binary from address $c000 through $ffff.
Total size 16384 bytes.
